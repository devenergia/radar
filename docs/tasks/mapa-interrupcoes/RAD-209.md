# RAD-209: Materialized View MV_PORTAL_PUBLICO

**Fase:** 3 - Infrastructure Layer
**Tipo:** Database
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-208
**Base Legal:** REN 1.137/2025 - Art. 106

## Objetivo

Criar Materialized View para otimizar consultas do portal publico.

## Localizacao

`backend/migrations/versions/xxx_create_mv_portal_publico.py`

## Especificacao

### Motivacao

- Reduzir carga nos bancos de origem (INSERVICE, INDICADORES)
- Garantir tempo de resposta < 2s
- Permitir refresh a cada 30 minutos (REN 1.137)

### Estrutura da View

| Coluna | Tipo | Origem |
|--------|------|--------|
| id | NUMBER | AGENCY_EVENT.NUM_1 |
| numero_ocorrencia | VARCHAR2(50) | AGENCY_EVENT.NUM_1 |
| codigo_ibge | VARCHAR2(7) | IND_UNIVERSOS.CD_UNIVERSO |
| bairro | VARCHAR2(200) | AGENCY_EVENT.ADDR_TXT |
| latitude | NUMBER | OMS_CONNECTIVITY.LATITUDE |
| longitude | NUMBER | OMS_CONNECTIVITY.LONGITUDE |
| data_inicio | DATE | AGENCY_EVENT.CREATE_DATE |
| tipo | VARCHAR2(20) | Calculado |
| status_codigo | VARCHAR2(10) | AGENCY_EVENT.STATUS_CODE |
| ucs_afetadas | NUMBER | AGENCY_EVENT.NUM_CUST |
| equipes_designadas | NUMBER | CREW_ASSIGNMENT (agregado) |
| causa | VARCHAR2(500) | AGENCY_EVENT.REMARKS |
| previsao_restabelecimento | DATE | AGENCY_EVENT.ESTIMATED_RESTORE_DATE |
| ultima_atualizacao | DATE | SYSDATE |

## Implementacao

### DDL da Materialized View

```sql
-- migrations/sql/create_mv_portal_publico.sql

-- Drop se existir
DROP MATERIALIZED VIEW IF EXISTS RADAR.MV_PORTAL_PUBLICO;

-- Criar Materialized View
CREATE MATERIALIZED VIEW RADAR.MV_PORTAL_PUBLICO
BUILD IMMEDIATE
REFRESH COMPLETE ON DEMAND
AS
SELECT
    ae.NUM_1 AS id,
    ae.NUM_1 AS numero_ocorrencia,
    iu.CD_UNIVERSO AS codigo_ibge,
    COALESCE(ae.ADDR_TXT, 'Nao informado') AS bairro,
    oc.LATITUDE AS latitude,
    oc.LONGITUDE AS longitude,
    ae.CREATE_DATE AS data_inicio,
    CASE
        WHEN spt.PLAN_ID IS NOT NULL THEN 'PROGRAMADA'
        ELSE 'NAO_PROGRAMADA'
    END AS tipo,
    ae.STATUS_CODE AS status_codigo,
    NVL(ae.NUM_CUST, 0) AS ucs_afetadas,
    NVL(eq.QTD_EQUIPES, 0) AS equipes_designadas,
    ae.REMARKS AS causa,
    ae.ESTIMATED_RESTORE_DATE AS previsao_restabelecimento,
    SYSDATE AS ultima_atualizacao
FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
    ON spt.OUTAGE_NUM = ae.NUM_1
INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
    ON oc.MSLINK = ae.DEV_ID
INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
    ON iu.ID_DISPOSITIVO = ae.DEV_ID
    AND iu.CD_TIPO_UNIVERSO = 2  -- Municipio
LEFT JOIN (
    SELECT OUTAGE_NUM, COUNT(*) AS QTD_EQUIPES
    FROM INSERVICE.CREW_ASSIGNMENT@DBLINK_INSERVICE
    WHERE STATUS = 'ASSIGNED'
    GROUP BY OUTAGE_NUM
) eq ON eq.OUTAGE_NUM = ae.NUM_1
WHERE ae.IS_OPEN = 'T'
    AND ae.AG_ID = 370;  -- Roraima Energia

-- Criar indices para otimizacao
CREATE INDEX IDX_MV_PORTAL_IBGE ON RADAR.MV_PORTAL_PUBLICO(codigo_ibge);
CREATE INDEX IDX_MV_PORTAL_TIPO ON RADAR.MV_PORTAL_PUBLICO(tipo);
CREATE INDEX IDX_MV_PORTAL_STATUS ON RADAR.MV_PORTAL_PUBLICO(status_codigo);

-- Criar job para refresh automatico a cada 30 minutos
BEGIN
    DBMS_SCHEDULER.CREATE_JOB (
        job_name        => 'JOB_REFRESH_MV_PORTAL_PUBLICO',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN DBMS_MVIEW.REFRESH(''RADAR.MV_PORTAL_PUBLICO'', ''C''); END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=MINUTELY;INTERVAL=30',
        enabled         => TRUE,
        comments        => 'Refresh da MV do Portal Publico - REN 1.137'
    );
END;
/

-- Grants
GRANT SELECT ON RADAR.MV_PORTAL_PUBLICO TO RADAR_APP;
```

### Migration Alembic

```python
# migrations/versions/20251219_create_mv_portal_publico.py
"""Create Materialized View MV_PORTAL_PUBLICO

Revision ID: mv_portal_publico
Revises: previous_migration
Create Date: 2025-12-19

Conforme REN 1.137/2025 Art. 106, o portal deve ser
atualizado a cada 30 minutos.
"""
from alembic import op
import sqlalchemy as sa


revision = 'mv_portal_publico'
down_revision = 'previous_migration'
branch_labels = None
depends_on = None


def upgrade() -> None:
    """Cria Materialized View e Job de refresh."""
    # Executar DDL via raw SQL
    op.execute("""
        CREATE MATERIALIZED VIEW RADAR.MV_PORTAL_PUBLICO
        BUILD IMMEDIATE
        REFRESH COMPLETE ON DEMAND
        AS
        SELECT
            ae.NUM_1 AS id,
            ae.NUM_1 AS numero_ocorrencia,
            iu.CD_UNIVERSO AS codigo_ibge,
            COALESCE(ae.ADDR_TXT, 'Nao informado') AS bairro,
            oc.LATITUDE AS latitude,
            oc.LONGITUDE AS longitude,
            ae.CREATE_DATE AS data_inicio,
            CASE
                WHEN spt.PLAN_ID IS NOT NULL THEN 'PROGRAMADA'
                ELSE 'NAO_PROGRAMADA'
            END AS tipo,
            ae.STATUS_CODE AS status_codigo,
            NVL(ae.NUM_CUST, 0) AS ucs_afetadas,
            NVL(eq.QTD_EQUIPES, 0) AS equipes_designadas,
            ae.REMARKS AS causa,
            ae.ESTIMATED_RESTORE_DATE AS previsao_restabelecimento,
            SYSDATE AS ultima_atualizacao
        FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
        LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
            ON spt.OUTAGE_NUM = ae.NUM_1
        INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
            ON oc.MSLINK = ae.DEV_ID
        INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
            ON iu.ID_DISPOSITIVO = ae.DEV_ID
            AND iu.CD_TIPO_UNIVERSO = 2
        LEFT JOIN (
            SELECT OUTAGE_NUM, COUNT(*) AS QTD_EQUIPES
            FROM INSERVICE.CREW_ASSIGNMENT@DBLINK_INSERVICE
            WHERE STATUS = 'ASSIGNED'
            GROUP BY OUTAGE_NUM
        ) eq ON eq.OUTAGE_NUM = ae.NUM_1
        WHERE ae.IS_OPEN = 'T'
            AND ae.AG_ID = 370
    """)

    # Criar indices
    op.execute("""
        CREATE INDEX IDX_MV_PORTAL_IBGE
        ON RADAR.MV_PORTAL_PUBLICO(codigo_ibge)
    """)
    op.execute("""
        CREATE INDEX IDX_MV_PORTAL_TIPO
        ON RADAR.MV_PORTAL_PUBLICO(tipo)
    """)

    # Criar job de refresh
    op.execute("""
        BEGIN
            DBMS_SCHEDULER.CREATE_JOB (
                job_name        => 'JOB_REFRESH_MV_PORTAL_PUBLICO',
                job_type        => 'PLSQL_BLOCK',
                job_action      => 'BEGIN DBMS_MVIEW.REFRESH(''RADAR.MV_PORTAL_PUBLICO'', ''C''); END;',
                start_date      => SYSTIMESTAMP,
                repeat_interval => 'FREQ=MINUTELY;INTERVAL=30',
                enabled         => TRUE,
                comments        => 'Refresh da MV Portal Publico - REN 1.137'
            );
        END;
    """)


def downgrade() -> None:
    """Remove Materialized View e Job."""
    op.execute("""
        BEGIN
            DBMS_SCHEDULER.DROP_JOB('JOB_REFRESH_MV_PORTAL_PUBLICO');
        END;
    """)
    op.execute("DROP MATERIALIZED VIEW RADAR.MV_PORTAL_PUBLICO")
```

### Repository Otimizado

```python
# apps/mapa_interrupcoes/repositories/mv_mapa_repository.py
"""Repository otimizado usando Materialized View."""
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession


class MVMapaRepository:
    """
    Repository que usa MV_PORTAL_PUBLICO.

    Mais performatico que o OracleMapaRepository pois:
    - Dados pre-calculados
    - Sem JOINs em runtime
    - Indices otimizados
    """

    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def buscar_interrupcoes_ativas(self) -> list:
        """Busca usando MV."""
        query = """
            SELECT *
            FROM RADAR.MV_PORTAL_PUBLICO
            ORDER BY ucs_afetadas DESC
        """
        result = await self._session.execute(text(query))
        return result.fetchall()

    async def get_ultima_atualizacao(self) -> str:
        """Retorna timestamp da ultima atualizacao."""
        query = """
            SELECT MAX(ultima_atualizacao)
            FROM RADAR.MV_PORTAL_PUBLICO
        """
        result = await self._session.execute(text(query))
        row = result.fetchone()
        return row[0].isoformat() if row and row[0] else None
```

## Testes

```python
# tests/integration/database/test_mv_portal_publico.py
import pytest
from sqlalchemy import text


@pytest.mark.integration
class TestMVPortalPublico:
    """Testes para Materialized View."""

    @pytest.mark.asyncio
    async def test_mv_existe(self, db_session):
        """MV deve existir no banco."""
        query = """
            SELECT COUNT(*)
            FROM USER_MVIEWS
            WHERE MVIEW_NAME = 'MV_PORTAL_PUBLICO'
        """
        result = await db_session.execute(text(query))
        count = result.scalar()

        assert count == 1

    @pytest.mark.asyncio
    async def test_mv_tem_dados(self, db_session):
        """MV deve ter dados."""
        query = "SELECT COUNT(*) FROM RADAR.MV_PORTAL_PUBLICO"
        result = await db_session.execute(text(query))
        count = result.scalar()

        # Pode ter 0 se nao houver interrupcoes
        assert count >= 0

    @pytest.mark.asyncio
    async def test_indices_existem(self, db_session):
        """Indices devem existir."""
        query = """
            SELECT INDEX_NAME
            FROM USER_INDEXES
            WHERE TABLE_NAME = 'MV_PORTAL_PUBLICO'
        """
        result = await db_session.execute(text(query))
        indices = [row[0] for row in result.fetchall()]

        assert "IDX_MV_PORTAL_IBGE" in indices
        assert "IDX_MV_PORTAL_TIPO" in indices

    @pytest.mark.asyncio
    async def test_job_refresh_existe(self, db_session):
        """Job de refresh deve existir."""
        query = """
            SELECT COUNT(*)
            FROM USER_SCHEDULER_JOBS
            WHERE JOB_NAME = 'JOB_REFRESH_MV_PORTAL_PUBLICO'
        """
        result = await db_session.execute(text(query))
        count = result.scalar()

        assert count == 1
```

## Criterios de Aceite

- [ ] Migration Alembic criada
- [ ] MV criada com todos campos necessarios
- [ ] Indices criados para otimizacao
- [ ] Job de refresh a cada 30 minutos
- [ ] Grants configurados
- [ ] Testes de integracao passando
- [ ] Documentacao de rollback

## Comando de Execucao

```bash
# Aplicar migration
alembic upgrade head

# Verificar MV
sqlplus radar/password@xe -c "SELECT COUNT(*) FROM MV_PORTAL_PUBLICO"

# Forcar refresh
sqlplus radar/password@xe -c "BEGIN DBMS_MVIEW.REFRESH('MV_PORTAL_PUBLICO', 'C'); END;"

# Executar testes
pytest tests/integration/database/test_mv_portal_publico.py -v
```
