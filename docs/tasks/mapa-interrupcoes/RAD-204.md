# RAD-204: Domain Service CalculadorCHI

**Fase:** 1 - Domain Layer
**Tipo:** Domain Service
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-203
**Base Legal:** REN 1.137/2025 - Art. 107 alinea "h"

## Objetivo

Criar Domain Service para calcular CHI (Consumidor Hora Interrompido).

## Localizacao

`backend/shared/domain/services/calculador_chi.py`

## Especificacao

### Formula CHI

```
CHI = Quantidade de UCs Afetadas x Duracao em Horas
```

### Funcionalidades

1. **calcular_chi_individual(ucs, minutos):** Calcula CHI para uma interrupcao
2. **calcular_chi_total(interrupcoes):** Soma CHI de varias interrupcoes
3. **calcular_chi_por_municipio(interrupcoes):** Agrupa CHI por municipio
4. **calcular_chi_por_faixa(interrupcoes):** Agrupa CHI por faixa de duracao

## Implementacao

```python
# shared/domain/services/calculador_chi.py
from collections import defaultdict
from dataclasses import dataclass
from ..entities.interrupcao_mapa import InterrupcaoMapa
from ..value_objects.codigo_ibge import CodigoIBGE
from ..value_objects.faixa_duracao import FaixaDuracao


@dataclass(frozen=True)
class CHIPorMunicipio:
    """Agregado de CHI por municipio."""

    municipio: CodigoIBGE
    chi_total: float
    ucs_total: int
    qtd_interrupcoes: int


@dataclass(frozen=True)
class CHIPorFaixa:
    """Agregado de CHI por faixa de duracao."""

    faixa: FaixaDuracao
    chi_total: float
    ucs_total: int
    qtd_interrupcoes: int


class CalculadorCHI:
    """
    Domain Service para calculos de CHI.

    CHI = Consumidor Hora Interrompido
    Formula: UCs afetadas x Duracao em horas
    """

    @staticmethod
    def calcular_chi_individual(
        ucs_afetadas: int,
        duracao_minutos: int,
    ) -> float:
        """
        Calcula CHI para uma interrupcao.

        Args:
            ucs_afetadas: Quantidade de UCs afetadas
            duracao_minutos: Duracao em minutos

        Returns:
            CHI calculado
        """
        if ucs_afetadas < 0:
            raise ValueError("UCs afetadas nao pode ser negativo")
        if duracao_minutos < 0:
            raise ValueError("Duracao nao pode ser negativa")

        horas = duracao_minutos / 60.0
        return ucs_afetadas * horas

    @staticmethod
    def calcular_chi_total(
        interrupcoes: list[InterrupcaoMapa],
    ) -> float:
        """
        Calcula CHI total de varias interrupcoes.

        Args:
            interrupcoes: Lista de interrupcoes

        Returns:
            Soma de todos os CHIs
        """
        return sum(i.chi for i in interrupcoes)

    @staticmethod
    def calcular_ucs_total(
        interrupcoes: list[InterrupcaoMapa],
    ) -> int:
        """
        Calcula total de UCs afetadas.

        Args:
            interrupcoes: Lista de interrupcoes

        Returns:
            Soma de UCs afetadas
        """
        return sum(i.ucs_afetadas for i in interrupcoes)

    @staticmethod
    def calcular_chi_por_municipio(
        interrupcoes: list[InterrupcaoMapa],
    ) -> list[CHIPorMunicipio]:
        """
        Agrupa CHI por municipio.

        Args:
            interrupcoes: Lista de interrupcoes

        Returns:
            Lista de agregados por municipio
        """
        agrupado: dict[str, dict] = defaultdict(lambda: {
            "municipio": None,
            "chi_total": 0.0,
            "ucs_total": 0,
            "qtd": 0,
        })

        for i in interrupcoes:
            chave = i.municipio.valor
            if agrupado[chave]["municipio"] is None:
                agrupado[chave]["municipio"] = i.municipio
            agrupado[chave]["chi_total"] += i.chi
            agrupado[chave]["ucs_total"] += i.ucs_afetadas
            agrupado[chave]["qtd"] += 1

        return [
            CHIPorMunicipio(
                municipio=grupo["municipio"],
                chi_total=grupo["chi_total"],
                ucs_total=grupo["ucs_total"],
                qtd_interrupcoes=grupo["qtd"],
            )
            for grupo in agrupado.values()
        ]

    @staticmethod
    def calcular_chi_por_faixa(
        interrupcoes: list[InterrupcaoMapa],
    ) -> list[CHIPorFaixa]:
        """
        Agrupa CHI por faixa de duracao.

        Args:
            interrupcoes: Lista de interrupcoes

        Returns:
            Lista de agregados por faixa
        """
        agrupado: dict[FaixaDuracao, dict] = defaultdict(lambda: {
            "chi_total": 0.0,
            "ucs_total": 0,
            "qtd": 0,
        })

        for i in interrupcoes:
            agrupado[i.faixa_duracao]["chi_total"] += i.chi
            agrupado[i.faixa_duracao]["ucs_total"] += i.ucs_afetadas
            agrupado[i.faixa_duracao]["qtd"] += 1

        return [
            CHIPorFaixa(
                faixa=faixa,
                chi_total=grupo["chi_total"],
                ucs_total=grupo["ucs_total"],
                qtd_interrupcoes=grupo["qtd"],
            )
            for faixa, grupo in agrupado.items()
        ]

    @staticmethod
    def calcular_equipes_em_campo(
        interrupcoes: list[InterrupcaoMapa],
    ) -> int:
        """
        Calcula total de equipes em campo.

        Args:
            interrupcoes: Lista de interrupcoes ativas

        Returns:
            Total de equipes designadas
        """
        return sum(i.equipes_designadas for i in interrupcoes if i.is_ativa())
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/services/test_calculador_chi.py
import pytest
from datetime import datetime, timedelta

from shared.domain.services.calculador_chi import (
    CalculadorCHI,
    CHIPorMunicipio,
    CHIPorFaixa,
)
from shared.domain.entities.interrupcao_mapa import InterrupcaoMapa
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.coordenadas import Coordenadas
from shared.domain.value_objects.faixa_duracao import FaixaDuracao
from shared.domain.value_objects.status_ocorrencia import StatusOcorrencia
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


def criar_interrupcao(
    ucs: int = 100,
    horas: int = 2,
    municipio_codigo: str = "1400100",
    status: StatusOcorrencia = StatusOcorrencia.EM_EXECUCAO,
    equipes: int = 1,
) -> InterrupcaoMapa:
    """Helper para criar interrupcoes de teste."""
    return InterrupcaoMapa.create({
        "id": f"INT-{ucs}-{horas}",
        "numero_ocorrencia": "2025-001",
        "municipio": CodigoIBGE.create(municipio_codigo).value,
        "bairro": "Centro",
        "coordenadas": Coordenadas.create(2.823841, -60.675833).value,
        "data_hora": datetime.now(),
        "tipo": TipoInterrupcao.NAO_PROGRAMADA,
        "status": status,
        "ucs_afetadas": ucs,
        "equipes_designadas": equipes,
        "data_inicio": datetime.now() - timedelta(hours=horas),
    }).value


class TestCalculadorCHI:
    """Testes para Domain Service CalculadorCHI."""

    class TestCalcularChiIndividual:
        """Testes para calcular_chi_individual()."""

        def test_deve_calcular_chi_corretamente(self):
            """100 UCs * 2 horas = 200 CHI."""
            chi = CalculadorCHI.calcular_chi_individual(100, 120)

            assert chi == 200.0

        def test_deve_calcular_chi_com_minutos_fracionados(self):
            """100 UCs * 1.5 horas = 150 CHI."""
            chi = CalculadorCHI.calcular_chi_individual(100, 90)

            assert chi == 150.0

        def test_deve_retornar_zero_para_zero_ucs(self):
            """0 UCs = 0 CHI."""
            chi = CalculadorCHI.calcular_chi_individual(0, 120)

            assert chi == 0.0

        def test_deve_retornar_zero_para_zero_minutos(self):
            """0 minutos = 0 CHI."""
            chi = CalculadorCHI.calcular_chi_individual(100, 0)

            assert chi == 0.0

        def test_deve_rejeitar_ucs_negativas(self):
            """UCs negativas devem lancar excecao."""
            with pytest.raises(ValueError, match="negativo"):
                CalculadorCHI.calcular_chi_individual(-100, 120)

        def test_deve_rejeitar_duracao_negativa(self):
            """Duracao negativa deve lancar excecao."""
            with pytest.raises(ValueError, match="negativa"):
                CalculadorCHI.calcular_chi_individual(100, -60)

    class TestCalcularChiTotal:
        """Testes para calcular_chi_total()."""

        def test_deve_somar_chi_de_todas_interrupcoes(self):
            """Soma de CHIs deve estar correta."""
            interrupcoes = [
                criar_interrupcao(ucs=100, horas=2),  # ~200 CHI
                criar_interrupcao(ucs=50, horas=1),   # ~50 CHI
            ]

            chi_total = CalculadorCHI.calcular_chi_total(interrupcoes)

            # Aproximadamente 250 CHI
            assert 240 < chi_total < 260

        def test_deve_retornar_zero_para_lista_vazia(self):
            """Lista vazia = 0 CHI."""
            chi_total = CalculadorCHI.calcular_chi_total([])

            assert chi_total == 0.0

    class TestCalcularChiPorMunicipio:
        """Testes para calcular_chi_por_municipio()."""

        def test_deve_agrupar_por_municipio(self):
            """Deve agrupar interrupcoes por municipio."""
            interrupcoes = [
                criar_interrupcao(ucs=100, municipio_codigo="1400100"),
                criar_interrupcao(ucs=50, municipio_codigo="1400100"),
                criar_interrupcao(ucs=75, municipio_codigo="1400209"),
            ]

            resultado = CalculadorCHI.calcular_chi_por_municipio(interrupcoes)

            assert len(resultado) == 2

            boa_vista = next(
                r for r in resultado if r.municipio.valor == "1400100"
            )
            assert boa_vista.ucs_total == 150
            assert boa_vista.qtd_interrupcoes == 2

            caracarai = next(
                r for r in resultado if r.municipio.valor == "1400209"
            )
            assert caracarai.ucs_total == 75
            assert caracarai.qtd_interrupcoes == 1

    class TestCalcularChiPorFaixa:
        """Testes para calcular_chi_por_faixa()."""

        def test_deve_agrupar_por_faixa(self):
            """Deve agrupar interrupcoes por faixa de duracao."""
            interrupcoes = [
                criar_interrupcao(ucs=100, horas=2),   # DE_1_A_3H
                criar_interrupcao(ucs=50, horas=2),    # DE_1_A_3H
                criar_interrupcao(ucs=75, horas=5),    # DE_3_A_6H
            ]

            resultado = CalculadorCHI.calcular_chi_por_faixa(interrupcoes)

            faixa_1_3 = next(
                r for r in resultado if r.faixa == FaixaDuracao.DE_1_A_3H
            )
            assert faixa_1_3.ucs_total == 150
            assert faixa_1_3.qtd_interrupcoes == 2

    class TestCalcularEquipesEmCampo:
        """Testes para calcular_equipes_em_campo()."""

        def test_deve_somar_apenas_interrupcoes_ativas(self):
            """Deve somar equipes apenas de interrupcoes ativas."""
            interrupcoes = [
                criar_interrupcao(equipes=2, status=StatusOcorrencia.EM_EXECUCAO),
                criar_interrupcao(equipes=3, status=StatusOcorrencia.DESLOCAMENTO),
                criar_interrupcao(equipes=1, status=StatusOcorrencia.CONCLUIDA),
            ]

            total = CalculadorCHI.calcular_equipes_em_campo(interrupcoes)

            assert total == 5  # 2 + 3, excluindo a concluida
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Calculo CHI individual correto
- [ ] Soma de CHI total
- [ ] Agrupamento por municipio
- [ ] Agrupamento por faixa
- [ ] Calculo de equipes em campo
- [ ] Validacao de parametros
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/services/test_calculador_chi.py -v

# Com cobertura
pytest tests/unit/domain/services/test_calculador_chi.py --cov=shared/domain/services/calculador_chi --cov-report=term-missing
```
