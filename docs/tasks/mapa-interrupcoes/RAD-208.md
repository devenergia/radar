# RAD-208: Oracle MapaRepository

**Fase:** 3 - Infrastructure Layer
**Tipo:** Adapter/Repository
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-203, RAD-205, RAD-108 (Connection Pool)
**Base Legal:** REN 1.137/2025 - Art. 106

## Objetivo

Implementar Adapter do MapaRepository para Oracle via DBLink.

## Localizacao

`backend/apps/mapa_interrupcoes/repositories/oracle_mapa_repository.py`

## Especificacao

### Principios Aplicados

- **Hexagonal Architecture:** Adapter implementa Port
- **Dependency Inversion:** Implementa Protocol do dominio
- **Single Responsibility:** Apenas acesso a dados Oracle

### Fontes de Dados

| Dado | Fonte | DBLink |
|------|-------|--------|
| Interrupcoes ativas | AGENCY_EVENT | DBLINK_INSERVICE |
| Tipo (programada) | SWITCH_PLAN_TASKS | DBLINK_INSERVICE |
| Municipio | IND_UNIVERSOS | DBLINK_INDICADORES |
| Coordenadas | OMS_CONNECTIVITY | DBLINK_INSERVICE |

### Query Principal

```sql
SELECT
    ae.NUM_1 AS id,
    ae.NUM_1 AS numero_ocorrencia,
    iu.CD_UNIVERSO AS codigo_ibge,
    -- Bairro via ADDR_TXT ou lookup
    COALESCE(ae.ADDR_TXT, 'Nao informado') AS bairro,
    -- Coordenadas do dispositivo
    oc.LATITUDE AS latitude,
    oc.LONGITUDE AS longitude,
    ae.CREATE_DATE AS data_hora,
    ae.CREATE_DATE AS data_inicio,
    -- Tipo via PLAN_ID
    CASE WHEN spt.PLAN_ID IS NOT NULL THEN 'PROGRAMADA' ELSE 'NAO_PROGRAMADA' END AS tipo,
    -- Status via STATUS_CODE
    ae.STATUS_CODE AS status_codigo,
    ae.NUM_CUST AS ucs_afetadas,
    -- Equipes designadas
    NVL(eq.QTD_EQUIPES, 0) AS equipes_designadas,
    -- Causa
    ae.REMARKS AS causa,
    -- Previsao
    ae.ESTIMATED_RESTORE_DATE AS previsao_restabelecimento
FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
    ON spt.OUTAGE_NUM = ae.NUM_1
INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
    ON oc.MSLINK = ae.DEV_ID
INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
    ON iu.ID_DISPOSITIVO = ae.DEV_ID
    AND iu.CD_TIPO_UNIVERSO = 2  -- Municipio
LEFT JOIN (
    SELECT OUTAGE_NUM, COUNT(*) AS QTD_EQUIPES
    FROM INSERVICE.CREW_ASSIGNMENT@DBLINK_INSERVICE
    WHERE STATUS = 'ASSIGNED'
    GROUP BY OUTAGE_NUM
) eq ON eq.OUTAGE_NUM = ae.NUM_1
WHERE ae.IS_OPEN = 'T'
    AND ae.AG_ID = 370  -- Roraima Energia
```

## Implementacao

```python
# apps/mapa_interrupcoes/repositories/oracle_mapa_repository.py
from datetime import datetime
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from shared.domain.entities.interrupcao_mapa import InterrupcaoMapa
from shared.domain.repositories.mapa_repository import (
    MapaRepository,
    EstatisticasMapa,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.coordenadas import Coordenadas
from shared.domain.value_objects.faixa_duracao import FaixaDuracao
from shared.domain.value_objects.status_ocorrencia import StatusOcorrencia
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao
from shared.domain.services.calculador_chi import CalculadorCHI


class OracleMapaRepository:
    """
    Adapter que implementa MapaRepository para Oracle.

    Busca dados via DBLinks:
    - DBLINK_INSERVICE: Dados do OMS (interrupcoes)
    - DBLINK_INDICADORES: Dados geograficos
    """

    # ID da Roraima Energia no sistema
    RORAIMA_AG_ID = 370

    def __init__(self, session: AsyncSession) -> None:
        """
        Inicializa repository.

        Args:
            session: Sessao async do SQLAlchemy
        """
        self._session = session
        self._calculador = CalculadorCHI()

    async def buscar_interrupcoes_ativas(self) -> list[InterrupcaoMapa]:
        """
        Busca todas as interrupcoes ativas.

        Returns:
            Lista de InterrupcaoMapa
        """
        query = self._get_base_query()
        result = await self._session.execute(text(query))
        rows = result.fetchall()

        return [self._map_to_entity(row) for row in rows]

    async def buscar_por_municipio(
        self,
        codigo_ibge: CodigoIBGE,
    ) -> list[InterrupcaoMapa]:
        """
        Busca interrupcoes por municipio.

        Args:
            codigo_ibge: Codigo IBGE do municipio

        Returns:
            Lista de InterrupcaoMapa
        """
        query = f"""
            {self._get_base_query()}
            AND iu.CD_UNIVERSO = :codigo_ibge
        """
        result = await self._session.execute(
            text(query),
            {"codigo_ibge": codigo_ibge.valor},
        )
        rows = result.fetchall()

        return [self._map_to_entity(row) for row in rows]

    async def buscar_por_faixa(
        self,
        faixa: FaixaDuracao,
    ) -> list[InterrupcaoMapa]:
        """
        Busca interrupcoes por faixa de duracao.

        Args:
            faixa: Faixa de duracao

        Returns:
            Lista filtrada por faixa
        """
        # Buscar todas e filtrar em memoria (faixa e calculada)
        todas = await self.buscar_interrupcoes_ativas()
        return [i for i in todas if i.faixa_duracao == faixa]

    async def buscar_estatisticas(self) -> EstatisticasMapa:
        """
        Busca estatisticas agregadas.

        Returns:
            EstatisticasMapa com metricas
        """
        interrupcoes = await self.buscar_interrupcoes_ativas()

        chi_por_faixa = self._calculador.calcular_chi_por_faixa(interrupcoes)
        chi_por_mun = self._calculador.calcular_chi_por_municipio(interrupcoes)

        return EstatisticasMapa(
            total_interrupcoes=len(interrupcoes),
            total_ucs_afetadas=self._calculador.calcular_ucs_total(
                interrupcoes
            ),
            chi_total=self._calculador.calcular_chi_total(interrupcoes),
            equipes_em_campo=self._calculador.calcular_equipes_em_campo(
                interrupcoes
            ),
            por_faixa={f.faixa: f.qtd_interrupcoes for f in chi_por_faixa},
            por_municipio={
                m.municipio.valor: m.qtd_interrupcoes for m in chi_por_mun
            },
        )

    async def buscar_por_id(
        self,
        interrupcao_id: str,
    ) -> InterrupcaoMapa | None:
        """
        Busca interrupcao por ID.

        Args:
            interrupcao_id: ID da interrupcao

        Returns:
            InterrupcaoMapa ou None
        """
        query = f"""
            {self._get_base_query()}
            AND ae.NUM_1 = :id
        """
        result = await self._session.execute(
            text(query),
            {"id": interrupcao_id},
        )
        row = result.fetchone()

        return self._map_to_entity(row) if row else None

    def _get_base_query(self) -> str:
        """Retorna query base para interrupcoes."""
        return f"""
            SELECT
                ae.NUM_1 AS id,
                ae.NUM_1 AS numero_ocorrencia,
                iu.CD_UNIVERSO AS codigo_ibge,
                COALESCE(ae.ADDR_TXT, 'Nao informado') AS bairro,
                oc.LATITUDE AS latitude,
                oc.LONGITUDE AS longitude,
                ae.CREATE_DATE AS data_hora,
                ae.CREATE_DATE AS data_inicio,
                CASE
                    WHEN spt.PLAN_ID IS NOT NULL THEN 'PROGRAMADA'
                    ELSE 'NAO_PROGRAMADA'
                END AS tipo,
                ae.STATUS_CODE AS status_codigo,
                ae.NUM_CUST AS ucs_afetadas,
                NVL(eq.QTD_EQUIPES, 0) AS equipes_designadas,
                ae.REMARKS AS causa,
                ae.ESTIMATED_RESTORE_DATE AS previsao_restabelecimento
            FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
            LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
                ON spt.OUTAGE_NUM = ae.NUM_1
            INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
                ON oc.MSLINK = ae.DEV_ID
            INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
                ON iu.ID_DISPOSITIVO = ae.DEV_ID
                AND iu.CD_TIPO_UNIVERSO = 2
            LEFT JOIN (
                SELECT OUTAGE_NUM, COUNT(*) AS QTD_EQUIPES
                FROM INSERVICE.CREW_ASSIGNMENT@DBLINK_INSERVICE
                WHERE STATUS = 'ASSIGNED'
                GROUP BY OUTAGE_NUM
            ) eq ON eq.OUTAGE_NUM = ae.NUM_1
            WHERE ae.IS_OPEN = 'T'
                AND ae.AG_ID = {self.RORAIMA_AG_ID}
        """

    def _map_to_entity(self, row) -> InterrupcaoMapa:
        """
        Mapeia row do banco para Entity.

        Args:
            row: Linha do resultado

        Returns:
            InterrupcaoMapa
        """
        # Mapear tipo
        tipo = TipoInterrupcao(row.tipo)

        # Mapear status
        status = self._map_status(row.status_codigo)

        # Criar coordenadas
        coords_result = Coordenadas.create(
            row.latitude or 2.823841,  # Default: Boa Vista
            row.longitude or -60.675833,
        )
        coordenadas = (
            coords_result.value if coords_result.is_success
            else Coordenadas(2.823841, -60.675833)
        )

        # Criar municipio
        ibge_result = CodigoIBGE.create(str(row.codigo_ibge))
        municipio = (
            ibge_result.value if ibge_result.is_success
            else CodigoIBGE.create("1400100").value  # Default: Boa Vista
        )

        return InterrupcaoMapa.create({
            "id": str(row.id),
            "numero_ocorrencia": str(row.numero_ocorrencia),
            "municipio": municipio,
            "bairro": row.bairro or "Nao informado",
            "coordenadas": coordenadas,
            "data_hora": row.data_hora or datetime.now(),
            "tipo": tipo,
            "status": status,
            "ucs_afetadas": row.ucs_afetadas or 0,
            "equipes_designadas": row.equipes_designadas or 0,
            "data_inicio": row.data_inicio or datetime.now(),
            "causa": row.causa,
            "causa_conhecida": bool(row.causa),
            "previsao_restabelecimento": row.previsao_restabelecimento,
        }).value

    def _map_status(self, codigo: str | None) -> StatusOcorrencia:
        """Mapeia codigo de status do banco para enum."""
        return StatusOcorrencia.from_codigo(codigo)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/integration/repositories/test_oracle_mapa_repository.py
import pytest
from unittest.mock import AsyncMock, MagicMock
from datetime import datetime

from apps.mapa_interrupcoes.repositories.oracle_mapa_repository import (
    OracleMapaRepository,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.faixa_duracao import FaixaDuracao


def criar_row_mock(
    id: int = 12345,
    codigo_ibge: str = "1400100",
    latitude: float = 2.823841,
    longitude: float = -60.675833,
    tipo: str = "NAO_PROGRAMADA",
    status_codigo: str = "E",
    ucs_afetadas: int = 150,
):
    """Helper para criar row mock."""
    mock = MagicMock()
    mock.id = id
    mock.numero_ocorrencia = id
    mock.codigo_ibge = codigo_ibge
    mock.bairro = "Centro"
    mock.latitude = latitude
    mock.longitude = longitude
    mock.data_hora = datetime.now()
    mock.data_inicio = datetime.now()
    mock.tipo = tipo
    mock.status_codigo = status_codigo
    mock.ucs_afetadas = ucs_afetadas
    mock.equipes_designadas = 2
    mock.causa = "Queda de arvore"
    mock.previsao_restabelecimento = None
    return mock


class TestOracleMapaRepository:
    """Testes para OracleMapaRepository."""

    @pytest.fixture
    def mock_session(self):
        """Mock da sessao SQLAlchemy."""
        session = AsyncMock()
        return session

    @pytest.fixture
    def repository(self, mock_session):
        """Repository com mock."""
        return OracleMapaRepository(mock_session)

    class TestBuscarInterrupcoesAtivas:
        """Testes para buscar_interrupcoes_ativas()."""

        @pytest.mark.asyncio
        async def test_deve_executar_query_correta(
            self, repository, mock_session
        ):
            """Query deve filtrar por IS_OPEN e AG_ID."""
            mock_result = AsyncMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            await repository.buscar_interrupcoes_ativas()

            call_args = mock_session.execute.call_args
            query_str = str(call_args[0][0])

            assert "IS_OPEN = 'T'" in query_str
            assert "AG_ID = 370" in query_str

        @pytest.mark.asyncio
        async def test_deve_mapear_rows_para_entities(
            self, repository, mock_session
        ):
            """Rows devem ser convertidas para InterrupcaoMapa."""
            mock_result = AsyncMock()
            mock_result.fetchall.return_value = [criar_row_mock()]
            mock_session.execute.return_value = mock_result

            result = await repository.buscar_interrupcoes_ativas()

            assert len(result) == 1
            assert result[0].ucs_afetadas == 150

    class TestBuscarPorMunicipio:
        """Testes para buscar_por_municipio()."""

        @pytest.mark.asyncio
        async def test_deve_filtrar_por_ibge(
            self, repository, mock_session
        ):
            """Query deve incluir filtro de municipio."""
            mock_result = AsyncMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            municipio = CodigoIBGE.create("1400100").value
            await repository.buscar_por_municipio(municipio)

            call_args = mock_session.execute.call_args
            assert "CD_UNIVERSO = :codigo_ibge" in str(call_args[0][0])

    class TestBuscarEstatisticas:
        """Testes para buscar_estatisticas()."""

        @pytest.mark.asyncio
        async def test_deve_retornar_estatisticas_agregadas(
            self, repository, mock_session
        ):
            """Deve calcular estatisticas corretamente."""
            mock_result = AsyncMock()
            mock_result.fetchall.return_value = [
                criar_row_mock(ucs_afetadas=100),
                criar_row_mock(id=2, ucs_afetadas=50),
            ]
            mock_session.execute.return_value = mock_result

            stats = await repository.buscar_estatisticas()

            assert stats.total_interrupcoes == 2
            assert stats.total_ucs_afetadas == 150

    class TestMapToEntity:
        """Testes para _map_to_entity()."""

        def test_deve_mapear_todos_campos(self, repository):
            """Todos os campos devem ser mapeados."""
            row = criar_row_mock()

            entity = repository._map_to_entity(row)

            assert entity.id == "12345"
            assert entity.ucs_afetadas == 150
            assert entity.bairro == "Centro"

        def test_deve_usar_defaults_para_valores_nulos(self, repository):
            """Valores nulos devem usar defaults."""
            row = criar_row_mock()
            row.latitude = None
            row.longitude = None

            entity = repository._map_to_entity(row)

            # Default: Boa Vista
            assert entity.coordenadas.latitude == 2.823841
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Query usa AG_ID = 370 (Roraima)
- [ ] Mapeamento correto de todos campos
- [ ] Tratamento de valores nulos
- [ ] Implementa Protocol MapaRepository
- [ ] Usa DBLinks corretos
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/integration/repositories/test_oracle_mapa_repository.py -v

# Com cobertura
pytest tests/integration/repositories/test_oracle_mapa_repository.py --cov=apps/mapa_interrupcoes/repositories/oracle_mapa_repository --cov-report=term-missing
```
