# RAD-207: Use Case GetEquipesEmCampo

**Fase:** 2 - Application Layer
**Tipo:** Use Case
**Prioridade:** Media
**Status:** PENDENTE
**Dependencias:** RAD-203, RAD-205
**Base Legal:** REN 1.137/2025 - Art. 107 alinea "k"

## Objetivo

Criar Use Case para buscar quantidade de equipes em campo.

## Localizacao

`backend/apps/mapa_interrupcoes/use_cases/get_equipes_em_campo.py`

## Especificacao

### Requisito Legal (REN 1.137 Art. 107 alinea k)

> "quantidade de equipes em campo para atendimento as ocorrencias abertas"

### Funcionalidades

1. Total de equipes em campo
2. Equipes por municipio
3. Equipes por status de ocorrencia

## Implementacao

```python
# apps/mapa_interrupcoes/use_cases/get_equipes_em_campo.py
from dataclasses import dataclass
from shared.domain.repositories.mapa_repository import MapaRepository
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.status_ocorrencia import StatusOcorrencia
from shared.domain.result import Result
from shared.application.cache_service import CacheService
from collections import defaultdict


@dataclass(frozen=True)
class EquipesPorMunicipio:
    """Equipes agrupadas por municipio."""

    municipio: CodigoIBGE
    nome_municipio: str
    total_equipes: int
    ocorrencias_atendidas: int


@dataclass(frozen=True)
class EquipesPorStatus:
    """Equipes agrupadas por status."""

    status: StatusOcorrencia
    total_equipes: int
    ocorrencias: int


@dataclass(frozen=True)
class GetEquipesEmCampoOutput:
    """Output do Use Case."""

    total_equipes: int
    por_municipio: list[EquipesPorMunicipio]
    por_status: list[EquipesPorStatus]
    from_cache: bool


class GetEquipesEmCampoUseCase:
    """
    Use Case para buscar equipes em campo.

    Conforme REN 1.137/2025 Art. 107 alinea "k":
    - Quantidade de equipes em campo para atendimento as ocorrencias abertas
    """

    CACHE_TTL_SECONDS = 30 * 60  # 30 minutos

    # Mapeamento IBGE -> Nome do municipio
    NOMES_MUNICIPIOS = {
        "1400050": "Alto Alegre",
        "1400027": "Amajari",
        "1400100": "Boa Vista",
        "1400159": "Bonfim",
        "1400175": "Canta",
        "1400209": "Caracarai",
        "1400233": "Caroebe",
        "1400282": "Iracema",
        "1400308": "Mucajai",
        "1400407": "Normandia",
        "1400456": "Pacaraima",
        "1400472": "Rorainopolis",
        "1400506": "Sao Joao da Baliza",
        "1400605": "Sao Luiz",
        "1400704": "Uiramuta",
    }

    def __init__(
        self,
        repository: MapaRepository,
        cache: CacheService,
    ) -> None:
        """
        Inicializa Use Case.

        Args:
            repository: Repositorio de dados do mapa
            cache: Servico de cache
        """
        self._repository = repository
        self._cache = cache

    async def execute(self) -> Result[GetEquipesEmCampoOutput]:
        """
        Busca equipes em campo.

        Returns:
            Result com Output ou erro
        """
        cache_key = "mapa:equipes_em_campo"

        try:
            # Verificar cache
            cached = await self._cache.get(cache_key)
            if cached:
                return Result.ok(GetEquipesEmCampoOutput(
                    total_equipes=cached["total"],
                    por_municipio=cached["por_municipio"],
                    por_status=cached["por_status"],
                    from_cache=True,
                ))

            # Buscar interrupcoes ativas
            interrupcoes = await self._repository.buscar_interrupcoes_ativas()

            # Filtrar apenas ativas
            ativas = [i for i in interrupcoes if i.is_ativa()]

            # Calcular agregados
            total = sum(i.equipes_designadas for i in ativas)
            por_municipio = self._agrupar_por_municipio(ativas)
            por_status = self._agrupar_por_status(ativas)

            # Salvar no cache
            await self._cache.set(
                cache_key,
                {
                    "total": total,
                    "por_municipio": por_municipio,
                    "por_status": por_status,
                },
                self.CACHE_TTL_SECONDS,
            )

            return Result.ok(GetEquipesEmCampoOutput(
                total_equipes=total,
                por_municipio=por_municipio,
                por_status=por_status,
                from_cache=False,
            ))

        except Exception as e:
            return Result.fail(f"Erro ao buscar equipes: {e}")

    def _agrupar_por_municipio(
        self,
        interrupcoes: list,
    ) -> list[EquipesPorMunicipio]:
        """
        Agrupa equipes por municipio.

        Args:
            interrupcoes: Lista de interrupcoes ativas

        Returns:
            Lista de agregados por municipio
        """
        agrupado: dict[str, dict] = defaultdict(lambda: {
            "equipes": 0,
            "ocorrencias": 0,
            "municipio": None,
        })

        for i in interrupcoes:
            chave = i.municipio.valor
            if agrupado[chave]["municipio"] is None:
                agrupado[chave]["municipio"] = i.municipio
            agrupado[chave]["equipes"] += i.equipes_designadas
            agrupado[chave]["ocorrencias"] += 1

        return [
            EquipesPorMunicipio(
                municipio=grupo["municipio"],
                nome_municipio=self.NOMES_MUNICIPIOS.get(
                    grupo["municipio"].valor, "Desconhecido"
                ),
                total_equipes=grupo["equipes"],
                ocorrencias_atendidas=grupo["ocorrencias"],
            )
            for grupo in agrupado.values()
        ]

    def _agrupar_por_status(
        self,
        interrupcoes: list,
    ) -> list[EquipesPorStatus]:
        """
        Agrupa equipes por status.

        Args:
            interrupcoes: Lista de interrupcoes ativas

        Returns:
            Lista de agregados por status
        """
        agrupado: dict[StatusOcorrencia, dict] = defaultdict(lambda: {
            "equipes": 0,
            "ocorrencias": 0,
        })

        for i in interrupcoes:
            agrupado[i.status]["equipes"] += i.equipes_designadas
            agrupado[i.status]["ocorrencias"] += 1

        return [
            EquipesPorStatus(
                status=status,
                total_equipes=grupo["equipes"],
                ocorrencias=grupo["ocorrencias"],
            )
            for status, grupo in agrupado.items()
        ]
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/use_cases/test_get_equipes_em_campo.py
import pytest
from unittest.mock import AsyncMock, MagicMock

from apps.mapa_interrupcoes.use_cases.get_equipes_em_campo import (
    GetEquipesEmCampoUseCase,
    GetEquipesEmCampoOutput,
    EquipesPorMunicipio,
    EquipesPorStatus,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.status_ocorrencia import StatusOcorrencia


def criar_interrupcao_mock(
    municipio_codigo: str = "1400100",
    status: StatusOcorrencia = StatusOcorrencia.EM_EXECUCAO,
    equipes: int = 2,
    ativa: bool = True,
):
    """Helper para criar mock de interrupcao."""
    mock = MagicMock()
    mock.municipio = CodigoIBGE.create(municipio_codigo).value
    mock.status = status
    mock.equipes_designadas = equipes
    mock.is_ativa.return_value = ativa
    return mock


class TestGetEquipesEmCampoUseCase:
    """Testes para Use Case GetEquipesEmCampo."""

    @pytest.fixture
    def mock_repository(self):
        return AsyncMock()

    @pytest.fixture
    def mock_cache(self):
        return AsyncMock()

    @pytest.fixture
    def use_case(self, mock_repository, mock_cache):
        return GetEquipesEmCampoUseCase(
            repository=mock_repository,
            cache=mock_cache,
        )

    class TestExecute:
        """Testes para metodo execute()."""

        @pytest.mark.asyncio
        async def test_deve_retornar_do_cache(
            self, use_case, mock_cache
        ):
            """Cache hit deve retornar dados cacheados."""
            mock_cache.get.return_value = {
                "total": 10,
                "por_municipio": [],
                "por_status": [],
            }

            result = await use_case.execute()

            assert result.is_success
            assert result.value.from_cache is True
            assert result.value.total_equipes == 10

        @pytest.mark.asyncio
        async def test_deve_calcular_total_equipes(
            self, use_case, mock_repository, mock_cache
        ):
            """Total deve somar equipes de todas interrupcoes ativas."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = [
                criar_interrupcao_mock(equipes=3),
                criar_interrupcao_mock(equipes=2),
            ]

            result = await use_case.execute()

            assert result.is_success
            assert result.value.total_equipes == 5

        @pytest.mark.asyncio
        async def test_deve_ignorar_interrupcoes_concluidas(
            self, use_case, mock_repository, mock_cache
        ):
            """Nao deve contar equipes de interrupcoes concluidas."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = [
                criar_interrupcao_mock(equipes=3, ativa=True),
                criar_interrupcao_mock(equipes=2, ativa=False),
            ]

            result = await use_case.execute()

            assert result.is_success
            assert result.value.total_equipes == 3

        @pytest.mark.asyncio
        async def test_deve_agrupar_por_municipio(
            self, use_case, mock_repository, mock_cache
        ):
            """Deve agrupar equipes por municipio."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = [
                criar_interrupcao_mock(
                    municipio_codigo="1400100", equipes=3
                ),
                criar_interrupcao_mock(
                    municipio_codigo="1400100", equipes=2
                ),
                criar_interrupcao_mock(
                    municipio_codigo="1400209", equipes=1
                ),
            ]

            result = await use_case.execute()

            assert result.is_success
            por_mun = {
                m.municipio.valor: m for m in result.value.por_municipio
            }
            assert por_mun["1400100"].total_equipes == 5
            assert por_mun["1400209"].total_equipes == 1

        @pytest.mark.asyncio
        async def test_deve_agrupar_por_status(
            self, use_case, mock_repository, mock_cache
        ):
            """Deve agrupar equipes por status."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = [
                criar_interrupcao_mock(
                    status=StatusOcorrencia.EM_EXECUCAO, equipes=3
                ),
                criar_interrupcao_mock(
                    status=StatusOcorrencia.DESLOCAMENTO, equipes=2
                ),
            ]

            result = await use_case.execute()

            assert result.is_success
            por_status = {
                s.status: s for s in result.value.por_status
            }
            assert por_status[StatusOcorrencia.EM_EXECUCAO].total_equipes == 3
            assert por_status[StatusOcorrencia.DESLOCAMENTO].total_equipes == 2

        @pytest.mark.asyncio
        async def test_deve_salvar_no_cache(
            self, use_case, mock_repository, mock_cache
        ):
            """Resultado deve ser salvo no cache."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = []

            await use_case.execute()

            mock_cache.set.assert_called_once()

        @pytest.mark.asyncio
        async def test_deve_retornar_erro_em_excecao(
            self, use_case, mock_repository, mock_cache
        ):
            """Excecoes devem ser tratadas."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.side_effect = (
                Exception("Erro")
            )

            result = await use_case.execute()

            assert result.is_failure


class TestEquipesPorMunicipio:
    """Testes para dataclass EquipesPorMunicipio."""

    def test_deve_ser_imutavel(self):
        """Deve ser frozen."""
        eq = EquipesPorMunicipio(
            municipio=CodigoIBGE.create("1400100").value,
            nome_municipio="Boa Vista",
            total_equipes=5,
            ocorrencias_atendidas=3,
        )

        with pytest.raises(AttributeError):
            eq.total_equipes = 10
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Total de equipes calculado corretamente
- [ ] Agrupamento por municipio funcional
- [ ] Agrupamento por status funcional
- [ ] Cache com TTL de 30 minutos
- [ ] Result Pattern para erros
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/use_cases/test_get_equipes_em_campo.py -v

# Com cobertura
pytest tests/unit/use_cases/test_get_equipes_em_campo.py --cov=apps/mapa_interrupcoes/use_cases/get_equipes_em_campo --cov-report=term-missing
```
