# RAD-213: Endpoint GET /api/mapa/interrupcoes

**Fase:** 4 - Interfaces Layer
**Tipo:** API Endpoint
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-206, RAD-212
**Base Legal:** REN 1.137/2025 - Art. 106-107

## Objetivo

Criar endpoint principal para listar interrupcoes do mapa publico.

## Localizacao

`backend/apps/mapa_interrupcoes/routes.py`

## Especificacao

### Endpoint

```
GET /api/mapa/interrupcoes
```

### Query Parameters

| Parametro | Tipo | Obrigatorio | Descricao |
|-----------|------|-------------|-----------|
| `municipio` | string | Nao | Codigo IBGE para filtrar |
| `faixa` | string | Nao | Faixa de duracao para filtrar |
| `incluir_estatisticas` | bool | Nao | Incluir estatisticas (default: true) |

### Response (200 OK)

```json
{
  "success": true,
  "data": [
    {
      "id": "INT-001",
      "numeroOcorrencia": "2025-001234",
      "codigoIbge": "1400100",
      "nomeMunicipio": "Boa Vista",
      "bairro": "Centro",
      "coordenadas": {
        "latitude": 2.823841,
        "longitude": -60.675833
      },
      "dataHora": "2025-12-19T10:30:00",
      "tipo": "NAO_PROGRAMADA",
      "faixaDuracao": "DE_1_A_3H",
      "status": "EM_EXECUCAO",
      "ucsAfetadas": 150,
      "chi": 300.0,
      "equipesDesignadas": 2
    }
  ],
  "estatisticas": {
    "totalInterrupcoes": 1,
    "totalUcsAfetadas": 150,
    "chiTotal": 300.0,
    "equipesEmCampo": 2
  },
  "fromCache": false
}
```

## Implementacao

```python
# apps/mapa_interrupcoes/routes.py
"""Rotas da API do Mapa de Interrupcoes."""
from fastapi import APIRouter, Depends, Query, HTTPException
from typing import Annotated

from .schemas import (
    MapaInterrupcoesResponse,
    InterrupcaoMapaResponse,
    EstatisticasResponse,
    ErrorResponse,
)
from .dependencies import get_interrupcoes_use_case
from .use_cases.get_interrupcoes_mapa import (
    GetInterrupcoesMapaUseCase,
    GetInterrupcoesMapaInput,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.faixa_duracao import FaixaDuracao


router = APIRouter(prefix="/api/mapa", tags=["Mapa de Interrupcoes"])


@router.get(
    "/interrupcoes",
    response_model=MapaInterrupcoesResponse,
    responses={
        200: {
            "description": "Lista de interrupcoes ativas",
            "model": MapaInterrupcoesResponse,
        },
        400: {
            "description": "Parametros invalidos",
            "model": ErrorResponse,
        },
        500: {
            "description": "Erro interno",
            "model": ErrorResponse,
        },
    },
    summary="Lista interrupcoes ativas no mapa",
    description="""
    Retorna todas as interrupcoes ativas para exibicao no mapa publico.

    **Conforme REN 1.137/2025 Art. 107, inclui:**
    - Numero da ocorrencia
    - Municipio/bairro
    - Data e hora
    - Tipo (programada/nao programada)
    - Faixa de duracao
    - Status
    - UCs afetadas
    - CHI (Consumidor Hora Interrompido)
    - Equipes em campo

    **Cache:** Dados atualizados a cada 30 minutos (Art. 106)
    """,
)
async def get_interrupcoes(
    municipio: Annotated[
        str | None,
        Query(
            description="Codigo IBGE do municipio (7 digitos)",
            min_length=7,
            max_length=7,
            pattern=r"^14\d{5}$",
            examples=["1400100"],
        ),
    ] = None,
    faixa: Annotated[
        str | None,
        Query(
            description="Faixa de duracao",
            examples=["ATE_1H", "DE_1_A_3H", "DE_3_A_6H"],
        ),
    ] = None,
    incluir_estatisticas: Annotated[
        bool,
        Query(
            alias="incluirEstatisticas",
            description="Incluir estatisticas agregadas",
        ),
    ] = True,
    use_case: GetInterrupcoesMapaUseCase = Depends(get_interrupcoes_use_case),
) -> MapaInterrupcoesResponse:
    """
    Lista interrupcoes ativas para o mapa publico.

    Args:
        municipio: Codigo IBGE para filtrar
        faixa: Faixa de duracao para filtrar
        incluir_estatisticas: Se deve incluir estatisticas
        use_case: Use case injetado

    Returns:
        MapaInterrupcoesResponse com lista de interrupcoes
    """
    # Validar municipio se fornecido
    municipio_vo = None
    if municipio:
        result = CodigoIBGE.create(municipio)
        if result.is_failure:
            raise HTTPException(
                status_code=400,
                detail={
                    "error": "Codigo IBGE invalido",
                    "code": "INVALID_IBGE",
                    "details": {"municipio": municipio},
                },
            )
        municipio_vo = result.value

    # Validar faixa se fornecida
    faixa_vo = None
    if faixa:
        try:
            faixa_vo = FaixaDuracao(faixa)
        except ValueError:
            raise HTTPException(
                status_code=400,
                detail={
                    "error": "Faixa de duracao invalida",
                    "code": "INVALID_FAIXA",
                    "details": {
                        "faixa": faixa,
                        "validas": [f.value for f in FaixaDuracao],
                    },
                },
            )

    # Executar use case
    input_data = GetInterrupcoesMapaInput(
        municipio=municipio_vo,
        faixa=faixa_vo,
        incluir_estatisticas=incluir_estatisticas,
    )

    result = await use_case.execute(input_data)

    if result.is_failure:
        raise HTTPException(
            status_code=500,
            detail={
                "error": result.error,
                "code": "USE_CASE_ERROR",
            },
        )

    # Converter para response
    output = result.value

    return MapaInterrupcoesResponse(
        success=True,
        data=[
            InterrupcaoMapaResponse.from_entity(i)
            for i in output.interrupcoes
        ],
        estatisticas=_build_estatisticas(output.estatisticas)
        if output.estatisticas
        else None,
        from_cache=output.from_cache,
    )


def _build_estatisticas(stats) -> EstatisticasResponse:
    """Converte estatisticas para schema."""
    from datetime import datetime

    return EstatisticasResponse(
        totalInterrupcoes=stats.total_interrupcoes,
        totalUcsAfetadas=stats.total_ucs_afetadas,
        chiTotal=stats.chi_total,
        equipesEmCampo=stats.equipes_em_campo,
        porFaixa=[
            {
                "faixa": faixa.value,
                "label": faixa.get_label(),
                "cor": faixa.get_cor(),
                "quantidade": qtd,
                "ucsAfetadas": 0,  # TODO: calcular
            }
            for faixa, qtd in stats.por_faixa.items()
        ],
        porMunicipio=[
            {
                "codigoIbge": ibge,
                "nome": InterrupcaoMapaResponse._get_nome_municipio(ibge),
                "quantidade": qtd,
                "ucsAfetadas": 0,  # TODO: calcular
            }
            for ibge, qtd in stats.por_municipio.items()
        ],
        ultimaAtualizacao=datetime.now(),
    )
```

### Dependencies

```python
# apps/mapa_interrupcoes/dependencies.py
"""Injecao de dependencias para API do Mapa."""
from functools import lru_cache
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from shared.infrastructure.database.oracle_connection import get_session
from shared.infrastructure.cache.memory_cache import MemoryCacheService
from .repositories.oracle_mapa_repository import OracleMapaRepository
from .use_cases.get_interrupcoes_mapa import GetInterrupcoesMapaUseCase


@lru_cache
def get_cache_service() -> MemoryCacheService:
    """Singleton do servico de cache."""
    return MemoryCacheService()


async def get_repository(
    session: AsyncSession = Depends(get_session),
) -> OracleMapaRepository:
    """Factory do repositorio."""
    return OracleMapaRepository(session)


async def get_interrupcoes_use_case(
    repository: OracleMapaRepository = Depends(get_repository),
    cache: MemoryCacheService = Depends(get_cache_service),
) -> GetInterrupcoesMapaUseCase:
    """Factory do use case."""
    return GetInterrupcoesMapaUseCase(
        repository=repository,
        cache=cache,
    )
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/e2e/api/test_mapa_interrupcoes.py
import pytest
from httpx import AsyncClient
from fastapi import status


@pytest.mark.e2e
class TestGetInterrupcoes:
    """Testes E2E para GET /api/mapa/interrupcoes."""

    @pytest.mark.asyncio
    async def test_deve_retornar_200_sem_filtros(
        self, client: AsyncClient
    ):
        """Requisicao sem filtros deve retornar 200."""
        response = await client.get("/api/mapa/interrupcoes")

        assert response.status_code == status.HTTP_200_OK

        body = response.json()
        assert body["success"] is True
        assert isinstance(body["data"], list)

    @pytest.mark.asyncio
    async def test_deve_retornar_campos_obrigatorios(
        self, client: AsyncClient
    ):
        """Response deve ter todos campos do Art. 107."""
        response = await client.get("/api/mapa/interrupcoes")

        body = response.json()

        if body["data"]:
            item = body["data"][0]

            # (a) numero da ocorrencia
            assert "numeroOcorrencia" in item
            # (b) municipio/bairro
            assert "codigoIbge" in item
            assert "bairro" in item
            # (c) data e hora
            assert "dataHora" in item
            # (d) tipo e faixa
            assert "tipo" in item
            assert "faixaDuracao" in item
            # (f) status
            assert "status" in item
            # (g) UCs afetadas
            assert "ucsAfetadas" in item
            # (h) CHI
            assert "chi" in item
            # (k) equipes
            assert "equipesDesignadas" in item

    @pytest.mark.asyncio
    async def test_deve_filtrar_por_municipio(
        self, client: AsyncClient
    ):
        """Filtro por municipio deve funcionar."""
        response = await client.get(
            "/api/mapa/interrupcoes",
            params={"municipio": "1400100"},
        )

        assert response.status_code == status.HTTP_200_OK

        body = response.json()
        for item in body["data"]:
            assert item["codigoIbge"] == "1400100"

    @pytest.mark.asyncio
    async def test_deve_filtrar_por_faixa(
        self, client: AsyncClient
    ):
        """Filtro por faixa deve funcionar."""
        response = await client.get(
            "/api/mapa/interrupcoes",
            params={"faixa": "DE_1_A_3H"},
        )

        assert response.status_code == status.HTTP_200_OK

        body = response.json()
        for item in body["data"]:
            assert item["faixaDuracao"] == "DE_1_A_3H"

    @pytest.mark.asyncio
    async def test_deve_retornar_400_municipio_invalido(
        self, client: AsyncClient
    ):
        """Municipio invalido deve retornar 400."""
        response = await client.get(
            "/api/mapa/interrupcoes",
            params={"municipio": "3550308"},  # Sao Paulo
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    @pytest.mark.asyncio
    async def test_deve_retornar_400_faixa_invalida(
        self, client: AsyncClient
    ):
        """Faixa invalida deve retornar 400."""
        response = await client.get(
            "/api/mapa/interrupcoes",
            params={"faixa": "INVALIDA"},
        )

        assert response.status_code == status.HTTP_400_BAD_REQUEST

    @pytest.mark.asyncio
    async def test_deve_incluir_estatisticas_por_padrao(
        self, client: AsyncClient
    ):
        """Estatisticas devem ser incluidas por padrao."""
        response = await client.get("/api/mapa/interrupcoes")

        body = response.json()
        assert "estatisticas" in body
        assert body["estatisticas"] is not None

    @pytest.mark.asyncio
    async def test_deve_omitir_estatisticas_quando_solicitado(
        self, client: AsyncClient
    ):
        """Estatisticas podem ser omitidas."""
        response = await client.get(
            "/api/mapa/interrupcoes",
            params={"incluirEstatisticas": False},
        )

        body = response.json()
        assert body["estatisticas"] is None

    @pytest.mark.asyncio
    async def test_deve_indicar_origem_cache(
        self, client: AsyncClient
    ):
        """Response deve indicar se veio do cache."""
        response = await client.get("/api/mapa/interrupcoes")

        body = response.json()
        assert "fromCache" in body
        assert isinstance(body["fromCache"], bool)
```

## Criterios de Aceite

- [ ] Testes E2E escritos e passando
- [ ] Endpoint acessivel sem autenticacao (publico)
- [ ] Filtro por municipio funcional
- [ ] Filtro por faixa funcional
- [ ] Estatisticas incluidas por padrao
- [ ] Todos campos do Art. 107 presentes
- [ ] Validacao de parametros
- [ ] Documentacao OpenAPI gerada
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/e2e/api/test_mapa_interrupcoes.py -v

# Testar manualmente
curl http://localhost:8000/api/mapa/interrupcoes

# Com filtro
curl "http://localhost:8000/api/mapa/interrupcoes?municipio=1400100"
```
