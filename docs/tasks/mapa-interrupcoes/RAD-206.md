# RAD-206: Use Case GetInterrupcoesMapa

**Fase:** 2 - Application Layer
**Tipo:** Use Case
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-203, RAD-204, RAD-205
**Base Legal:** REN 1.137/2025 - Art. 106-107

## Objetivo

Criar Use Case para buscar interrupcoes do mapa com cache e agregacoes.

## Localizacao

`backend/apps/mapa_interrupcoes/use_cases/get_interrupcoes_mapa.py`

## Especificacao

### Principios Aplicados

- **Single Responsibility (SOLID):** Apenas orquestra busca de interrupcoes
- **Dependency Inversion (SOLID):** Depende de Protocols
- **Clean Architecture:** Use Case na camada Application

### Fluxo de Execucao

```
1. Verificar cache
2. Se cache valido, retornar
3. Buscar do repositorio
4. Calcular estatisticas
5. Salvar no cache (TTL 30 min - REN 1.137)
6. Retornar resultado
```

### Input/Output

- **Input:** Filtros opcionais (municipio, faixa)
- **Output:** Result com lista de InterrupcaoMapa + estatisticas

## Implementacao

```python
# apps/mapa_interrupcoes/use_cases/get_interrupcoes_mapa.py
from dataclasses import dataclass
from shared.domain.entities.interrupcao_mapa import InterrupcaoMapa
from shared.domain.repositories.mapa_repository import (
    MapaRepository,
    EstatisticasMapa,
)
from shared.domain.services.calculador_chi import CalculadorCHI
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.faixa_duracao import FaixaDuracao
from shared.domain.result import Result
from shared.application.cache_service import CacheService


@dataclass(frozen=True)
class GetInterrupcoesMapaInput:
    """Input para o Use Case."""

    municipio: CodigoIBGE | None = None
    faixa: FaixaDuracao | None = None
    incluir_estatisticas: bool = True


@dataclass(frozen=True)
class GetInterrupcoesMapaOutput:
    """Output do Use Case."""

    interrupcoes: list[InterrupcaoMapa]
    estatisticas: EstatisticasMapa | None
    from_cache: bool


class GetInterrupcoesMapaUseCase:
    """
    Use Case para buscar interrupcoes do mapa.

    Responsabilidades:
    - Orquestrar busca de dados
    - Gerenciar cache (TTL 30 min por REN 1.137)
    - Calcular estatisticas agregadas

    Dependencias injetadas (DIP):
    - MapaRepository (Protocol)
    - CacheService (Protocol)
    - CalculadorCHI (Domain Service)
    """

    # TTL de 30 minutos conforme REN 1.137 Art. 106
    CACHE_TTL_SECONDS = 30 * 60

    def __init__(
        self,
        repository: MapaRepository,
        cache: CacheService,
        calculador_chi: CalculadorCHI | None = None,
    ) -> None:
        """
        Inicializa Use Case com dependencias.

        Args:
            repository: Repositorio de dados do mapa
            cache: Servico de cache
            calculador_chi: Servico de calculo CHI (opcional)
        """
        self._repository = repository
        self._cache = cache
        self._calculador_chi = calculador_chi or CalculadorCHI()

    async def execute(
        self,
        input_data: GetInterrupcoesMapaInput | None = None,
    ) -> Result[GetInterrupcoesMapaOutput]:
        """
        Executa busca de interrupcoes do mapa.

        Args:
            input_data: Filtros opcionais

        Returns:
            Result com Output ou erro
        """
        input_data = input_data or GetInterrupcoesMapaInput()

        try:
            # Gerar chave de cache
            cache_key = self._build_cache_key(input_data)

            # Verificar cache
            cached = await self._cache.get(cache_key)
            if cached:
                return Result.ok(GetInterrupcoesMapaOutput(
                    interrupcoes=cached["interrupcoes"],
                    estatisticas=cached.get("estatisticas"),
                    from_cache=True,
                ))

            # Buscar do repositorio
            interrupcoes = await self._fetch_interrupcoes(input_data)

            # Calcular estatisticas
            estatisticas = None
            if input_data.incluir_estatisticas:
                estatisticas = self._calcular_estatisticas(interrupcoes)

            # Salvar no cache
            await self._cache.set(
                cache_key,
                {
                    "interrupcoes": interrupcoes,
                    "estatisticas": estatisticas,
                },
                self.CACHE_TTL_SECONDS,
            )

            return Result.ok(GetInterrupcoesMapaOutput(
                interrupcoes=interrupcoes,
                estatisticas=estatisticas,
                from_cache=False,
            ))

        except Exception as e:
            return Result.fail(f"Erro ao buscar interrupcoes: {e}")

    def _build_cache_key(
        self,
        input_data: GetInterrupcoesMapaInput,
    ) -> str:
        """
        Constroi chave de cache baseada nos filtros.

        Args:
            input_data: Filtros de busca

        Returns:
            Chave de cache unica
        """
        parts = ["mapa:interrupcoes"]

        if input_data.municipio:
            parts.append(f"mun:{input_data.municipio.valor}")

        if input_data.faixa:
            parts.append(f"faixa:{input_data.faixa.value}")

        return ":".join(parts)

    async def _fetch_interrupcoes(
        self,
        input_data: GetInterrupcoesMapaInput,
    ) -> list[InterrupcaoMapa]:
        """
        Busca interrupcoes do repositorio com filtros.

        Args:
            input_data: Filtros de busca

        Returns:
            Lista de interrupcoes filtradas
        """
        if input_data.municipio:
            return await self._repository.buscar_por_municipio(
                input_data.municipio
            )

        if input_data.faixa:
            return await self._repository.buscar_por_faixa(input_data.faixa)

        return await self._repository.buscar_interrupcoes_ativas()

    def _calcular_estatisticas(
        self,
        interrupcoes: list[InterrupcaoMapa],
    ) -> EstatisticasMapa:
        """
        Calcula estatisticas agregadas.

        Args:
            interrupcoes: Lista de interrupcoes

        Returns:
            Estatisticas agregadas
        """
        chi_por_faixa = self._calculador_chi.calcular_chi_por_faixa(
            interrupcoes
        )
        chi_por_mun = self._calculador_chi.calcular_chi_por_municipio(
            interrupcoes
        )

        por_faixa = {f.faixa: f.qtd_interrupcoes for f in chi_por_faixa}
        por_municipio = {
            m.municipio.valor: m.qtd_interrupcoes for m in chi_por_mun
        }

        return EstatisticasMapa(
            total_interrupcoes=len(interrupcoes),
            total_ucs_afetadas=self._calculador_chi.calcular_ucs_total(
                interrupcoes
            ),
            chi_total=self._calculador_chi.calcular_chi_total(interrupcoes),
            equipes_em_campo=self._calculador_chi.calcular_equipes_em_campo(
                interrupcoes
            ),
            por_faixa=por_faixa,
            por_municipio=por_municipio,
        )
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/use_cases/test_get_interrupcoes_mapa.py
import pytest
from unittest.mock import AsyncMock, MagicMock
from datetime import datetime, timedelta

from apps.mapa_interrupcoes.use_cases.get_interrupcoes_mapa import (
    GetInterrupcoesMapaUseCase,
    GetInterrupcoesMapaInput,
    GetInterrupcoesMapaOutput,
)
from shared.domain.repositories.mapa_repository import EstatisticasMapa
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.faixa_duracao import FaixaDuracao


def criar_interrupcao_mock(
    id: str = "INT-001",
    ucs: int = 100,
    chi: float = 200.0,
):
    """Helper para criar mock de interrupcao."""
    mock = MagicMock()
    mock.id = id
    mock.ucs_afetadas = ucs
    mock.chi = chi
    mock.is_ativa.return_value = True
    mock.faixa_duracao = FaixaDuracao.DE_1_A_3H
    mock.municipio = CodigoIBGE.create("1400100").value
    mock.equipes_designadas = 1
    return mock


class TestGetInterrupcoesMapaUseCase:
    """Testes para Use Case GetInterrupcoesMapa."""

    @pytest.fixture
    def mock_repository(self):
        """Mock do repositorio."""
        return AsyncMock()

    @pytest.fixture
    def mock_cache(self):
        """Mock do cache."""
        return AsyncMock()

    @pytest.fixture
    def use_case(self, mock_repository, mock_cache):
        """Use case com mocks."""
        return GetInterrupcoesMapaUseCase(
            repository=mock_repository,
            cache=mock_cache,
        )

    class TestExecute:
        """Testes para metodo execute()."""

        @pytest.mark.asyncio
        async def test_deve_retornar_do_cache_quando_disponivel(
            self, use_case, mock_cache
        ):
            """Cache hit deve retornar dados cacheados."""
            interrupcoes = [criar_interrupcao_mock()]
            mock_cache.get.return_value = {
                "interrupcoes": interrupcoes,
                "estatisticas": None,
            }

            result = await use_case.execute()

            assert result.is_success
            assert result.value.from_cache is True
            assert result.value.interrupcoes == interrupcoes

        @pytest.mark.asyncio
        async def test_deve_buscar_repositorio_quando_cache_vazio(
            self, use_case, mock_repository, mock_cache
        ):
            """Cache miss deve buscar do repositorio."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = [
                criar_interrupcao_mock()
            ]

            result = await use_case.execute()

            assert result.is_success
            assert result.value.from_cache is False
            mock_repository.buscar_interrupcoes_ativas.assert_called_once()

        @pytest.mark.asyncio
        async def test_deve_salvar_no_cache_apos_busca(
            self, use_case, mock_repository, mock_cache
        ):
            """Resultado deve ser salvo no cache."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = []

            await use_case.execute()

            mock_cache.set.assert_called_once()
            call_args = mock_cache.set.call_args
            assert call_args[0][2] == 30 * 60  # 30 min TTL

        @pytest.mark.asyncio
        async def test_deve_filtrar_por_municipio(
            self, use_case, mock_repository, mock_cache
        ):
            """Filtro por municipio deve usar metodo correto."""
            mock_cache.get.return_value = None
            mock_repository.buscar_por_municipio.return_value = []
            municipio = CodigoIBGE.create("1400100").value

            input_data = GetInterrupcoesMapaInput(municipio=municipio)
            await use_case.execute(input_data)

            mock_repository.buscar_por_municipio.assert_called_once_with(
                municipio
            )

        @pytest.mark.asyncio
        async def test_deve_filtrar_por_faixa(
            self, use_case, mock_repository, mock_cache
        ):
            """Filtro por faixa deve usar metodo correto."""
            mock_cache.get.return_value = None
            mock_repository.buscar_por_faixa.return_value = []
            faixa = FaixaDuracao.DE_1_A_3H

            input_data = GetInterrupcoesMapaInput(faixa=faixa)
            await use_case.execute(input_data)

            mock_repository.buscar_por_faixa.assert_called_once_with(faixa)

        @pytest.mark.asyncio
        async def test_deve_calcular_estatisticas(
            self, use_case, mock_repository, mock_cache
        ):
            """Estatisticas devem ser calculadas."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = [
                criar_interrupcao_mock(ucs=100, chi=200.0),
                criar_interrupcao_mock(id="INT-002", ucs=50, chi=100.0),
            ]

            result = await use_case.execute()

            assert result.is_success
            assert result.value.estatisticas is not None
            assert result.value.estatisticas.total_interrupcoes == 2

        @pytest.mark.asyncio
        async def test_deve_omitir_estatisticas_quando_solicitado(
            self, use_case, mock_repository, mock_cache
        ):
            """Estatisticas podem ser omitidas."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.return_value = []

            input_data = GetInterrupcoesMapaInput(incluir_estatisticas=False)
            result = await use_case.execute(input_data)

            assert result.is_success
            assert result.value.estatisticas is None

        @pytest.mark.asyncio
        async def test_deve_retornar_erro_em_caso_de_excecao(
            self, use_case, mock_repository, mock_cache
        ):
            """Excecoes devem ser tratadas."""
            mock_cache.get.return_value = None
            mock_repository.buscar_interrupcoes_ativas.side_effect = (
                Exception("Erro de conexao")
            )

            result = await use_case.execute()

            assert result.is_failure
            assert "Erro" in result.error

    class TestBuildCacheKey:
        """Testes para metodo _build_cache_key()."""

        def test_chave_sem_filtros(self, use_case):
            """Chave sem filtros."""
            input_data = GetInterrupcoesMapaInput()

            key = use_case._build_cache_key(input_data)

            assert key == "mapa:interrupcoes"

        def test_chave_com_municipio(self, use_case):
            """Chave com filtro de municipio."""
            municipio = CodigoIBGE.create("1400100").value
            input_data = GetInterrupcoesMapaInput(municipio=municipio)

            key = use_case._build_cache_key(input_data)

            assert "mun:1400100" in key

        def test_chave_com_faixa(self, use_case):
            """Chave com filtro de faixa."""
            input_data = GetInterrupcoesMapaInput(faixa=FaixaDuracao.DE_1_A_3H)

            key = use_case._build_cache_key(input_data)

            assert "faixa:DE_1_A_3H" in key
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Use Case segue Single Responsibility
- [ ] Dependencias injetadas via construtor
- [ ] Cache com TTL de 30 minutos (REN 1.137)
- [ ] Filtros por municipio e faixa
- [ ] Estatisticas calculadas corretamente
- [ ] Result Pattern para erros
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/use_cases/test_get_interrupcoes_mapa.py -v

# Com cobertura
pytest tests/unit/use_cases/test_get_interrupcoes_mapa.py --cov=apps/mapa_interrupcoes/use_cases/get_interrupcoes_mapa --cov-report=term-missing
```
