# RAD-214: Endpoint GET /api/mapa/municipios

**Fase:** 4 - Interfaces Layer
**Tipo:** API Endpoint
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-211
**Base Legal:** REN 1.137/2025 - Art. 106

## Objetivo

Criar endpoint para retornar dados dos municipios com estatisticas.

## Localizacao

`backend/apps/mapa_interrupcoes/routes.py`

## Especificacao

### Endpoint

```
GET /api/mapa/municipios
```

### Response (200 OK)

```json
{
  "success": true,
  "data": [
    {
      "codigoIbge": "1400100",
      "nome": "Boa Vista",
      "capital": true,
      "areaKm2": 5687,
      "centroid": {
        "latitude": 2.823841,
        "longitude": -60.675833
      },
      "estatisticas": {
        "totalInterrupcoes": 5,
        "ucsAfetadas": 500,
        "chi": 1000.0,
        "equipesEmCampo": 3
      }
    }
  ],
  "geojsonUrl": "/api/mapa/municipios/geojson"
}
```

## Implementacao

```python
# apps/mapa_interrupcoes/routes.py (adicionar ao arquivo existente)

from pydantic import BaseModel, Field
from typing import Annotated


class CentroidSchema(BaseModel):
    """Schema para centroide do municipio."""

    latitude: float
    longitude: float


class MunicipioEstatisticas(BaseModel):
    """Schema para estatisticas do municipio."""

    total_interrupcoes: int = Field(..., alias="totalInterrupcoes", ge=0)
    ucs_afetadas: int = Field(..., alias="ucsAfetadas", ge=0)
    chi: float = Field(..., ge=0)
    equipes_em_campo: int = Field(..., alias="equipesEmCampo", ge=0)

    model_config = ConfigDict(populate_by_name=True)


class MunicipioResponse(BaseModel):
    """Schema para municipio."""

    codigo_ibge: str = Field(..., alias="codigoIbge")
    nome: str
    capital: bool
    area_km2: float = Field(..., alias="areaKm2")
    centroid: CentroidSchema
    estatisticas: MunicipioEstatisticas | None = None

    model_config = ConfigDict(populate_by_name=True)


class MunicipiosResponse(BaseModel):
    """Response da lista de municipios."""

    success: bool = True
    data: list[MunicipioResponse]
    geojson_url: str = Field(..., alias="geojsonUrl")

    model_config = ConfigDict(populate_by_name=True)


# Dados estaticos dos municipios
MUNICIPIOS_RR = [
    {
        "codigo_ibge": "1400050",
        "nome": "Alto Alegre",
        "capital": False,
        "area_km2": 25567.0,
        "centroid": {"latitude": 2.990833, "longitude": -61.307222},
    },
    {
        "codigo_ibge": "1400027",
        "nome": "Amajari",
        "capital": False,
        "area_km2": 28472.0,
        "centroid": {"latitude": 3.643889, "longitude": -61.371944},
    },
    {
        "codigo_ibge": "1400100",
        "nome": "Boa Vista",
        "capital": True,
        "area_km2": 5687.0,
        "centroid": {"latitude": 2.823841, "longitude": -60.675833},
    },
    {
        "codigo_ibge": "1400159",
        "nome": "Bonfim",
        "capital": False,
        "area_km2": 8095.0,
        "centroid": {"latitude": 3.362500, "longitude": -59.830278},
    },
    {
        "codigo_ibge": "1400175",
        "nome": "Canta",
        "capital": False,
        "area_km2": 7664.0,
        "centroid": {"latitude": 2.610000, "longitude": -60.586111},
    },
    {
        "codigo_ibge": "1400209",
        "nome": "Caracarai",
        "capital": False,
        "area_km2": 47411.0,
        "centroid": {"latitude": 1.816944, "longitude": -61.127778},
    },
    {
        "codigo_ibge": "1400233",
        "nome": "Caroebe",
        "capital": False,
        "area_km2": 12065.0,
        "centroid": {"latitude": 0.883889, "longitude": -59.695556},
    },
    {
        "codigo_ibge": "1400282",
        "nome": "Iracema",
        "capital": False,
        "area_km2": 14412.0,
        "centroid": {"latitude": 2.182500, "longitude": -61.041944},
    },
    {
        "codigo_ibge": "1400308",
        "nome": "Mucajai",
        "capital": False,
        "area_km2": 11247.0,
        "centroid": {"latitude": 2.439722, "longitude": -60.909722},
    },
    {
        "codigo_ibge": "1400407",
        "nome": "Normandia",
        "capital": False,
        "area_km2": 6966.0,
        "centroid": {"latitude": 3.880278, "longitude": -59.622778},
    },
    {
        "codigo_ibge": "1400456",
        "nome": "Pacaraima",
        "capital": False,
        "area_km2": 8028.0,
        "centroid": {"latitude": 4.480000, "longitude": -61.147778},
    },
    {
        "codigo_ibge": "1400472",
        "nome": "Rorainopolis",
        "capital": False,
        "area_km2": 33594.0,
        "centroid": {"latitude": 0.939167, "longitude": -60.439722},
    },
    {
        "codigo_ibge": "1400506",
        "nome": "Sao Joao da Baliza",
        "capital": False,
        "area_km2": 4284.0,
        "centroid": {"latitude": 0.950833, "longitude": -59.908333},
    },
    {
        "codigo_ibge": "1400605",
        "nome": "Sao Luiz",
        "capital": False,
        "area_km2": 1526.0,
        "centroid": {"latitude": 1.010833, "longitude": -60.035556},
    },
    {
        "codigo_ibge": "1400704",
        "nome": "Uiramuta",
        "capital": False,
        "area_km2": 8065.0,
        "centroid": {"latitude": 4.596944, "longitude": -60.182778},
    },
]


@router.get(
    "/municipios",
    response_model=MunicipiosResponse,
    summary="Lista municipios de Roraima",
    description="""
    Retorna lista dos 15 municipios de Roraima com:
    - Dados geograficos (codigo IBGE, nome, area, centroide)
    - Estatisticas de interrupcoes (opcional)
    - URL para GeoJSON com limites geograficos
    """,
)
async def get_municipios(
    incluir_estatisticas: Annotated[
        bool,
        Query(
            alias="incluirEstatisticas",
            description="Incluir estatisticas por municipio",
        ),
    ] = True,
    use_case: GetInterrupcoesMapaUseCase = Depends(get_interrupcoes_use_case),
) -> MunicipiosResponse:
    """
    Lista municipios de Roraima com estatisticas.

    Args:
        incluir_estatisticas: Se deve calcular estatisticas
        use_case: Use case injetado

    Returns:
        MunicipiosResponse com lista de municipios
    """
    municipios_data = []

    # Buscar estatisticas se solicitado
    stats_por_municipio = {}
    if incluir_estatisticas:
        result = await use_case.execute()
        if result.is_success and result.value.estatisticas:
            # Agrupar por municipio
            for i in result.value.interrupcoes:
                ibge = i.municipio.valor
                if ibge not in stats_por_municipio:
                    stats_por_municipio[ibge] = {
                        "total": 0,
                        "ucs": 0,
                        "chi": 0.0,
                        "equipes": 0,
                    }
                stats_por_municipio[ibge]["total"] += 1
                stats_por_municipio[ibge]["ucs"] += i.ucs_afetadas
                stats_por_municipio[ibge]["chi"] += i.chi
                stats_por_municipio[ibge]["equipes"] += i.equipes_designadas

    # Montar response
    for mun in MUNICIPIOS_RR:
        ibge = mun["codigo_ibge"]

        estatisticas = None
        if incluir_estatisticas and ibge in stats_por_municipio:
            stats = stats_por_municipio[ibge]
            estatisticas = MunicipioEstatisticas(
                totalInterrupcoes=stats["total"],
                ucsAfetadas=stats["ucs"],
                chi=stats["chi"],
                equipesEmCampo=stats["equipes"],
            )
        elif incluir_estatisticas:
            estatisticas = MunicipioEstatisticas(
                totalInterrupcoes=0,
                ucsAfetadas=0,
                chi=0.0,
                equipesEmCampo=0,
            )

        municipios_data.append(
            MunicipioResponse(
                codigoIbge=mun["codigo_ibge"],
                nome=mun["nome"],
                capital=mun["capital"],
                areaKm2=mun["area_km2"],
                centroid=CentroidSchema(**mun["centroid"]),
                estatisticas=estatisticas,
            )
        )

    return MunicipiosResponse(
        success=True,
        data=municipios_data,
        geojsonUrl="/api/mapa/municipios/geojson",
    )
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/e2e/api/test_mapa_municipios.py
import pytest
from httpx import AsyncClient
from fastapi import status


@pytest.mark.e2e
class TestGetMunicipios:
    """Testes E2E para GET /api/mapa/municipios."""

    @pytest.mark.asyncio
    async def test_deve_retornar_200(self, client: AsyncClient):
        """Requisicao deve retornar 200."""
        response = await client.get("/api/mapa/municipios")

        assert response.status_code == status.HTTP_200_OK

    @pytest.mark.asyncio
    async def test_deve_retornar_15_municipios(self, client: AsyncClient):
        """Deve retornar exatamente 15 municipios."""
        response = await client.get("/api/mapa/municipios")

        body = response.json()
        assert len(body["data"]) == 15

    @pytest.mark.asyncio
    async def test_deve_incluir_boa_vista_como_capital(
        self, client: AsyncClient
    ):
        """Boa Vista deve estar marcada como capital."""
        response = await client.get("/api/mapa/municipios")

        body = response.json()
        boa_vista = next(
            m for m in body["data"] if m["codigoIbge"] == "1400100"
        )

        assert boa_vista["nome"] == "Boa Vista"
        assert boa_vista["capital"] is True

    @pytest.mark.asyncio
    async def test_deve_incluir_centroides(self, client: AsyncClient):
        """Cada municipio deve ter centroide."""
        response = await client.get("/api/mapa/municipios")

        body = response.json()
        for mun in body["data"]:
            assert "centroid" in mun
            assert "latitude" in mun["centroid"]
            assert "longitude" in mun["centroid"]

    @pytest.mark.asyncio
    async def test_deve_incluir_url_geojson(self, client: AsyncClient):
        """Response deve incluir URL do GeoJSON."""
        response = await client.get("/api/mapa/municipios")

        body = response.json()
        assert "geojsonUrl" in body
        assert body["geojsonUrl"] == "/api/mapa/municipios/geojson"

    @pytest.mark.asyncio
    async def test_deve_incluir_estatisticas_por_padrao(
        self, client: AsyncClient
    ):
        """Estatisticas devem ser incluidas por padrao."""
        response = await client.get("/api/mapa/municipios")

        body = response.json()
        for mun in body["data"]:
            assert "estatisticas" in mun
            if mun["estatisticas"]:
                assert "totalInterrupcoes" in mun["estatisticas"]
                assert "ucsAfetadas" in mun["estatisticas"]

    @pytest.mark.asyncio
    async def test_deve_omitir_estatisticas_quando_solicitado(
        self, client: AsyncClient
    ):
        """Estatisticas podem ser omitidas."""
        response = await client.get(
            "/api/mapa/municipios",
            params={"incluirEstatisticas": False},
        )

        body = response.json()
        for mun in body["data"]:
            assert mun["estatisticas"] is None

    @pytest.mark.asyncio
    async def test_deve_validar_codigos_ibge(self, client: AsyncClient):
        """Todos codigos IBGE devem comecar com 14."""
        response = await client.get("/api/mapa/municipios")

        body = response.json()
        for mun in body["data"]:
            assert mun["codigoIbge"].startswith("14")
            assert len(mun["codigoIbge"]) == 7
```

## Criterios de Aceite

- [ ] Testes E2E escritos e passando
- [ ] Retorna exatamente 15 municipios
- [ ] Boa Vista marcada como capital
- [ ] Todos municipios com centroides
- [ ] URL do GeoJSON incluida
- [ ] Estatisticas por municipio
- [ ] Documentacao OpenAPI gerada
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/e2e/api/test_mapa_municipios.py -v

# Testar manualmente
curl http://localhost:8000/api/mapa/municipios
```
