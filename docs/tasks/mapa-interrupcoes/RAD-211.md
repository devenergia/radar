# RAD-211: GeoJSON dos Municipios Roraima

**Fase:** 3 - Infrastructure Layer
**Tipo:** Static Data
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** -
**Base Legal:** REN 1.137/2025 - Art. 106

## Objetivo

Criar arquivo GeoJSON com os limites geograficos dos 15 municipios de Roraima.

## Localizacao

`frontend/public/geojson/roraima-municipios.geojson`

## Especificacao

### Fonte de Dados

- **IBGE:** Malhas Municipais 2023
- **URL:** https://geoftp.ibge.gov.br/organizacao_do_territorio/malhas_territoriais/malhas_municipais/municipio_2023/UFs/RR/

### Municipios de Roraima (15)

| Codigo IBGE | Nome | Area (kmÂ²) |
|-------------|------|------------|
| 1400050 | Alto Alegre | 25.567 |
| 1400027 | Amajari | 28.472 |
| 1400100 | Boa Vista | 5.687 |
| 1400159 | Bonfim | 8.095 |
| 1400175 | Canta | 7.664 |
| 1400209 | Caracarai | 47.411 |
| 1400233 | Caroebe | 12.065 |
| 1400282 | Iracema | 14.412 |
| 1400308 | Mucajai | 11.247 |
| 1400407 | Normandia | 6.966 |
| 1400456 | Pacaraima | 8.028 |
| 1400472 | Rorainopolis | 33.594 |
| 1400506 | Sao Joao da Baliza | 4.284 |
| 1400605 | Sao Luiz | 1.526 |
| 1400704 | Uiramuta | 8.065 |

### Estrutura do GeoJSON

```json
{
  "type": "FeatureCollection",
  "name": "roraima_municipios",
  "crs": {
    "type": "name",
    "properties": {
      "name": "urn:ogc:def:crs:EPSG::4326"
    }
  },
  "features": [
    {
      "type": "Feature",
      "properties": {
        "codigo_ibge": "1400100",
        "nome": "Boa Vista",
        "area_km2": 5687.0,
        "capital": true
      },
      "geometry": {
        "type": "Polygon",
        "coordinates": [[[...]]]
      }
    }
  ]
}
```

## Implementacao

### Script de Download e Processamento

```python
# scripts/download_geojson_roraima.py
"""
Script para baixar e processar GeoJSON dos municipios de Roraima.

Fonte: IBGE - Malhas Municipais 2023
"""
import json
import requests
from pathlib import Path


# Municipios de Roraima com metadata
MUNICIPIOS_RR = {
    "1400050": {"nome": "Alto Alegre", "area": 25567, "capital": False},
    "1400027": {"nome": "Amajari", "area": 28472, "capital": False},
    "1400100": {"nome": "Boa Vista", "area": 5687, "capital": True},
    "1400159": {"nome": "Bonfim", "area": 8095, "capital": False},
    "1400175": {"nome": "Canta", "area": 7664, "capital": False},
    "1400209": {"nome": "Caracarai", "area": 47411, "capital": False},
    "1400233": {"nome": "Caroebe", "area": 12065, "capital": False},
    "1400282": {"nome": "Iracema", "area": 14412, "capital": False},
    "1400308": {"nome": "Mucajai", "area": 11247, "capital": False},
    "1400407": {"nome": "Normandia", "area": 6966, "capital": False},
    "1400456": {"nome": "Pacaraima", "area": 8028, "capital": False},
    "1400472": {"nome": "Rorainopolis", "area": 33594, "capital": False},
    "1400506": {"nome": "Sao Joao da Baliza", "area": 4284, "capital": False},
    "1400605": {"nome": "Sao Luiz", "area": 1526, "capital": False},
    "1400704": {"nome": "Uiramuta", "area": 8065, "capital": False},
}

IBGE_URL = (
    "https://servicodados.ibge.gov.br/api/v3/malhas/estados/14"
    "?formato=application/vnd.geo+json&resolucao=2&intrarregiao=municipio"
)


def download_geojson() -> dict:
    """Baixa GeoJSON do IBGE."""
    print(f"Baixando de: {IBGE_URL}")
    response = requests.get(IBGE_URL, timeout=60)
    response.raise_for_status()
    return response.json()


def process_geojson(raw_data: dict) -> dict:
    """
    Processa GeoJSON adicionando metadata.

    Args:
        raw_data: GeoJSON bruto do IBGE

    Returns:
        GeoJSON processado
    """
    features = []

    for feature in raw_data.get("features", []):
        codigo = feature.get("properties", {}).get("codarea", "")

        if codigo in MUNICIPIOS_RR:
            metadata = MUNICIPIOS_RR[codigo]

            processed_feature = {
                "type": "Feature",
                "properties": {
                    "codigo_ibge": codigo,
                    "nome": metadata["nome"],
                    "area_km2": metadata["area"],
                    "capital": metadata["capital"],
                },
                "geometry": feature.get("geometry"),
            }
            features.append(processed_feature)

    return {
        "type": "FeatureCollection",
        "name": "roraima_municipios",
        "crs": {
            "type": "name",
            "properties": {
                "name": "urn:ogc:def:crs:EPSG::4326"
            }
        },
        "features": features,
    }


def calculate_centroid(geometry: dict) -> tuple[float, float]:
    """
    Calcula centroide de um poligono.

    Args:
        geometry: Geometria do GeoJSON

    Returns:
        Tupla (latitude, longitude)
    """
    if geometry["type"] == "Polygon":
        coords = geometry["coordinates"][0]
    elif geometry["type"] == "MultiPolygon":
        # Usar o maior poligono
        coords = max(geometry["coordinates"], key=len)[0]
    else:
        return (0, 0)

    lng = sum(c[0] for c in coords) / len(coords)
    lat = sum(c[1] for c in coords) / len(coords)

    return (lat, lng)


def add_centroids(geojson: dict) -> dict:
    """Adiciona centroides aos features."""
    for feature in geojson["features"]:
        lat, lng = calculate_centroid(feature["geometry"])
        feature["properties"]["centroid"] = {
            "latitude": lat,
            "longitude": lng,
        }
    return geojson


def save_geojson(data: dict, output_path: Path) -> None:
    """Salva GeoJSON no arquivo."""
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print(f"Salvo em: {output_path}")


def main():
    """Executa processamento."""
    output_path = Path("frontend/public/geojson/roraima-municipios.geojson")

    # Download
    raw_data = download_geojson()
    print(f"Features brutas: {len(raw_data.get('features', []))}")

    # Processar
    processed = process_geojson(raw_data)
    print(f"Features processadas: {len(processed['features'])}")

    # Adicionar centroides
    with_centroids = add_centroids(processed)

    # Salvar
    save_geojson(with_centroids, output_path)

    # Validar
    assert len(processed["features"]) == 15, "Deve ter 15 municipios"
    print("Validacao OK: 15 municipios")


if __name__ == "__main__":
    main()
```

### Endpoint para Servir GeoJSON

```python
# apps/mapa_interrupcoes/routes.py
from fastapi import APIRouter
from fastapi.responses import FileResponse
from pathlib import Path

router = APIRouter(prefix="/api/mapa", tags=["mapa"])


@router.get("/municipios/geojson")
async def get_municipios_geojson():
    """
    Retorna GeoJSON dos municipios de Roraima.

    Returns:
        FileResponse com GeoJSON
    """
    geojson_path = Path("frontend/public/geojson/roraima-municipios.geojson")

    if not geojson_path.exists():
        raise HTTPException(
            status_code=404,
            detail="GeoJSON nao encontrado"
        )

    return FileResponse(
        geojson_path,
        media_type="application/geo+json",
        headers={
            "Cache-Control": "public, max-age=86400",  # 24h
        },
    )
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/scripts/test_download_geojson.py
import pytest
import json
from pathlib import Path
from unittest.mock import patch, MagicMock

from scripts.download_geojson_roraima import (
    process_geojson,
    calculate_centroid,
    add_centroids,
    MUNICIPIOS_RR,
)


class TestProcessGeojson:
    """Testes para process_geojson()."""

    def test_deve_processar_15_municipios(self):
        """Deve retornar exatamente 15 features."""
        # Simular dados do IBGE
        raw_data = {
            "features": [
                {
                    "properties": {"codarea": codigo},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[[0, 0], [1, 0], [1, 1], [0, 0]]],
                    },
                }
                for codigo in MUNICIPIOS_RR.keys()
            ]
        }

        result = process_geojson(raw_data)

        assert len(result["features"]) == 15

    def test_deve_adicionar_metadata(self):
        """Deve adicionar nome, area e capital."""
        raw_data = {
            "features": [
                {
                    "properties": {"codarea": "1400100"},
                    "geometry": {"type": "Polygon", "coordinates": [[]]},
                }
            ]
        }

        result = process_geojson(raw_data)
        props = result["features"][0]["properties"]

        assert props["nome"] == "Boa Vista"
        assert props["capital"] is True
        assert props["area_km2"] == 5687


class TestCalculateCentroid:
    """Testes para calculate_centroid()."""

    def test_deve_calcular_centroid_poligono(self):
        """Deve calcular centroide de poligono simples."""
        geometry = {
            "type": "Polygon",
            "coordinates": [[[0, 0], [2, 0], [2, 2], [0, 2], [0, 0]]],
        }

        lat, lng = calculate_centroid(geometry)

        # Centro do quadrado: (1, 1)
        assert 0.9 < lat < 1.1
        assert 0.9 < lng < 1.1

    def test_deve_lidar_com_multipolygon(self):
        """Deve funcionar com MultiPolygon."""
        geometry = {
            "type": "MultiPolygon",
            "coordinates": [
                [[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]],
                [[[10, 10], [11, 10], [11, 11], [10, 11], [10, 10]]],
            ],
        }

        lat, lng = calculate_centroid(geometry)

        # Deve retornar algo valido
        assert lat != 0 or lng != 0


class TestAddCentroids:
    """Testes para add_centroids()."""

    def test_deve_adicionar_centroid_a_cada_feature(self):
        """Cada feature deve ter centroid."""
        geojson = {
            "features": [
                {
                    "properties": {"nome": "Test"},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [[[0, 0], [1, 0], [1, 1], [0, 0]]],
                    },
                }
            ]
        }

        result = add_centroids(geojson)

        assert "centroid" in result["features"][0]["properties"]
        assert "latitude" in result["features"][0]["properties"]["centroid"]
        assert "longitude" in result["features"][0]["properties"]["centroid"]


class TestGeojsonFile:
    """Testes para arquivo GeoJSON."""

    def test_arquivo_existe(self):
        """Arquivo deve existir."""
        path = Path("frontend/public/geojson/roraima-municipios.geojson")

        # Este teste pode falhar inicialmente (TDD)
        if path.exists():
            assert path.is_file()

    def test_arquivo_valido(self):
        """Arquivo deve ser JSON valido."""
        path = Path("frontend/public/geojson/roraima-municipios.geojson")

        if path.exists():
            with open(path) as f:
                data = json.load(f)

            assert data["type"] == "FeatureCollection"
            assert len(data["features"]) == 15
```

## Criterios de Aceite

- [ ] Script de download funcional
- [ ] GeoJSON com 15 municipios
- [ ] Metadata completa (nome, area, capital)
- [ ] Centroides calculados
- [ ] Arquivo salvo em frontend/public/geojson/
- [ ] Endpoint GET /api/mapa/municipios/geojson
- [ ] Cache-Control configurado
- [ ] Testes passando

## Comando de Execucao

```bash
# Baixar e processar GeoJSON
python scripts/download_geojson_roraima.py

# Validar arquivo
python -c "import json; d=json.load(open('frontend/public/geojson/roraima-municipios.geojson')); print(f'{len(d[\"features\"])} municipios')"

# Testes
pytest tests/unit/scripts/test_download_geojson.py -v
```
