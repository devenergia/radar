# RAD-203: Entity InterrupcaoMapa

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-200, RAD-201, RAD-202, RAD-100
**Base Legal:** REN 1.137/2025 - Art. 107

## Objetivo

Criar Entity para representar uma interrupcao no mapa publico conforme REN 1.137/2025.

## Localizacao

`backend/shared/domain/entities/interrupcao_mapa.py`

## Especificacao

### Atributos (REN 1.137 Art. 107)

| Atributo | Tipo | Art. 107 | Descricao |
|----------|------|----------|-----------|
| id | str | - | Identificador unico |
| numero_ocorrencia | str | (a) | Numero da ocorrencia |
| municipio | CodigoIBGE | (b) | Codigo IBGE do municipio |
| bairro | str | (b) | Bairro/localidade |
| coordenadas | Coordenadas | (b) | Lat/Lng para o mapa |
| data_hora | datetime | (c) | Data e hora da ocorrencia |
| tipo | TipoInterrupcao | (d) | Programada/Nao programada |
| faixa_duracao | FaixaDuracao | (d) | Faixa de duracao |
| status | StatusOcorrencia | (f) | Status atual |
| ucs_afetadas | int | (g) | UCs afetadas |
| chi | float | (h) | Consumidor Hora Interrompido |
| equipes_designadas | int | (k) | Equipes em campo |
| causa | str | None | (e) | Causa (se conhecida) |
| causa_conhecida | bool | (e) | Se causa foi identificada |
| previsao_restabelecimento | datetime | None | (i) | Previsao de retorno |
| data_inicio | datetime | - | Inicio da interrupcao |

### Comportamentos

1. **get_duracao_minutos():** Calcula duracao desde o inicio
2. **atualizar_faixa():** Recalcula faixa baseado na duracao atual
3. **is_ativa():** Verifica se ainda esta ativa

## Implementacao

```python
# shared/domain/entities/interrupcao_mapa.py
from dataclasses import dataclass, field
from datetime import datetime
from ..value_objects.codigo_ibge import CodigoIBGE
from ..value_objects.coordenadas import Coordenadas
from ..value_objects.faixa_duracao import FaixaDuracao
from ..value_objects.status_ocorrencia import StatusOcorrencia
from ..value_objects.tipo_interrupcao import TipoInterrupcao
from ..result import Result


@dataclass
class InterrupcaoMapa:
    """
    Entity que representa uma interrupcao no mapa publico.

    Conforme REN 1.137/2025 Art. 107, deve conter:
    a) numero da ocorrencia
    b) municipio ou bairro
    c) data e hora da ocorrencia
    d) tipo e faixa de duracao
    e) causa (se conhecida)
    f) status de cada ocorrencia
    g) quantidade de UCs afetadas
    h) CHI
    i) previsao de restabelecimento (se conhecida)
    j) quantidade de UCs por faixa de duracao
    k) quantidade de equipes em campo
    """

    id: str
    numero_ocorrencia: str
    municipio: CodigoIBGE
    bairro: str
    coordenadas: Coordenadas
    data_hora: datetime
    tipo: TipoInterrupcao
    status: StatusOcorrencia
    ucs_afetadas: int
    equipes_designadas: int
    data_inicio: datetime
    faixa_duracao: FaixaDuracao = field(init=False)
    chi: float = field(init=False)
    causa: str | None = None
    causa_conhecida: bool = False
    previsao_restabelecimento: datetime | None = None

    def __post_init__(self) -> None:
        """Calcula campos derivados."""
        self._atualizar_faixa()
        self._calcular_chi()

    def _atualizar_faixa(self) -> None:
        """Atualiza faixa de duracao baseado no tempo decorrido."""
        minutos = self.get_duracao_minutos()
        self.faixa_duracao = FaixaDuracao.from_minutos(minutos)

    def _calcular_chi(self) -> None:
        """Calcula CHI (Consumidor Hora Interrompido)."""
        horas = self.get_duracao_minutos() / 60.0
        self.chi = self.ucs_afetadas * horas

    @classmethod
    def create(cls, props: dict) -> "Result[InterrupcaoMapa]":
        """
        Factory method com validacao.

        Args:
            props: Dicionario com propriedades

        Returns:
            Result com InterrupcaoMapa ou erro
        """
        # Validar UCs afetadas
        if props.get("ucs_afetadas", 0) < 0:
            return Result.fail("UCs afetadas nao pode ser negativo")

        # Validar equipes
        if props.get("equipes_designadas", 0) < 0:
            return Result.fail("Equipes designadas nao pode ser negativo")

        # Validar datas
        data_inicio = props.get("data_inicio")
        previsao = props.get("previsao_restabelecimento")

        if previsao and data_inicio and previsao < data_inicio:
            return Result.fail("Previsao nao pode ser anterior ao inicio")

        try:
            return Result.ok(cls(
                id=props["id"],
                numero_ocorrencia=props["numero_ocorrencia"],
                municipio=props["municipio"],
                bairro=props.get("bairro", ""),
                coordenadas=props["coordenadas"],
                data_hora=props["data_hora"],
                tipo=props["tipo"],
                status=props["status"],
                ucs_afetadas=props["ucs_afetadas"],
                equipes_designadas=props.get("equipes_designadas", 0),
                data_inicio=props["data_inicio"],
                causa=props.get("causa"),
                causa_conhecida=props.get("causa_conhecida", False),
                previsao_restabelecimento=props.get("previsao_restabelecimento"),
            ))
        except Exception as e:
            return Result.fail(f"Erro ao criar InterrupcaoMapa: {e}")

    def get_duracao_minutos(self) -> int:
        """
        Calcula duracao da interrupcao em minutos.

        Returns:
            Duracao em minutos desde o inicio
        """
        agora = datetime.now()
        delta = agora - self.data_inicio
        return max(0, int(delta.total_seconds() / 60))

    def is_ativa(self) -> bool:
        """
        Verifica se a interrupcao ainda esta ativa.

        Returns:
            True se status nao e CONCLUIDA
        """
        return self.status.is_ativa()

    def atualizar(self) -> None:
        """Atualiza campos calculados (faixa e CHI)."""
        self._atualizar_faixa()
        self._calcular_chi()

    def to_popup_html(self) -> str:
        """
        Gera HTML para popup do mapa.

        Returns:
            HTML formatado para Leaflet popup
        """
        causa_texto = self.causa if self.causa_conhecida else "Em investigacao"
        previsao_texto = (
            self.previsao_restabelecimento.strftime("%d/%m/%Y %H:%M")
            if self.previsao_restabelecimento
            else "A definir"
        )

        return f"""
        <div class="popup-interrupcao">
            <h4>Ocorrencia #{self.numero_ocorrencia}</h4>
            <p><strong>Local:</strong> {self.bairro}, {self.municipio}</p>
            <p><strong>Inicio:</strong> {self.data_inicio.strftime('%d/%m/%Y %H:%M')}</p>
            <p><strong>Status:</strong> {self.status.get_label()}</p>
            <p><strong>Tipo:</strong> {self.tipo.value}</p>
            <p><strong>Duracao:</strong> {self.faixa_duracao.get_label()}</p>
            <p><strong>UCs Afetadas:</strong> {self.ucs_afetadas:,}</p>
            <p><strong>CHI:</strong> {self.chi:,.2f}</p>
            <p><strong>Equipes:</strong> {self.equipes_designadas}</p>
            <p><strong>Causa:</strong> {causa_texto}</p>
            <p><strong>Previsao:</strong> {previsao_texto}</p>
        </div>
        """

    def __eq__(self, other: object) -> bool:
        """Igualdade baseada em ID."""
        if not isinstance(other, InterrupcaoMapa):
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/entities/test_interrupcao_mapa.py
import pytest
from datetime import datetime, timedelta

from shared.domain.entities.interrupcao_mapa import InterrupcaoMapa
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.coordenadas import Coordenadas
from shared.domain.value_objects.faixa_duracao import FaixaDuracao
from shared.domain.value_objects.status_ocorrencia import StatusOcorrencia
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestInterrupcaoMapa:
    """Testes para Entity InterrupcaoMapa."""

    @pytest.fixture
    def props_validas(self) -> dict:
        """Fixture com propriedades validas."""
        agora = datetime.now()
        return {
            "id": "INT-001",
            "numero_ocorrencia": "2025-001234",
            "municipio": CodigoIBGE.create("1400100").value,
            "bairro": "Centro",
            "coordenadas": Coordenadas.create(2.823841, -60.675833).value,
            "data_hora": agora,
            "tipo": TipoInterrupcao.NAO_PROGRAMADA,
            "status": StatusOcorrencia.EM_EXECUCAO,
            "ucs_afetadas": 150,
            "equipes_designadas": 2,
            "data_inicio": agora - timedelta(hours=2),
            "causa": "Queda de arvore",
            "causa_conhecida": True,
            "previsao_restabelecimento": agora + timedelta(hours=1),
        }

    class TestCreate:
        """Testes para factory create()."""

        def test_deve_criar_interrupcao_valida(self, props_validas):
            """Criacao com dados validos retorna sucesso."""
            result = InterrupcaoMapa.create(props_validas)

            assert result.is_success
            assert result.value.id == "INT-001"
            assert result.value.ucs_afetadas == 150

        def test_deve_calcular_faixa_automaticamente(self, props_validas):
            """Faixa deve ser calculada no __post_init__."""
            result = InterrupcaoMapa.create(props_validas)

            assert result.is_success
            # 2 horas = DE_1_A_3H
            assert result.value.faixa_duracao == FaixaDuracao.DE_1_A_3H

        def test_deve_calcular_chi_automaticamente(self, props_validas):
            """CHI deve ser calculado no __post_init__."""
            result = InterrupcaoMapa.create(props_validas)

            assert result.is_success
            # 150 UCs * 2 horas = 300 CHI
            assert 290 < result.value.chi < 310  # Aproximado

        def test_deve_rejeitar_ucs_negativas(self, props_validas):
            """UCs afetadas negativas retorna erro."""
            props_validas["ucs_afetadas"] = -10

            result = InterrupcaoMapa.create(props_validas)

            assert result.is_failure

        def test_deve_rejeitar_equipes_negativas(self, props_validas):
            """Equipes negativas retorna erro."""
            props_validas["equipes_designadas"] = -1

            result = InterrupcaoMapa.create(props_validas)

            assert result.is_failure

    class TestIsAtiva:
        """Testes para metodo is_ativa()."""

        def test_deve_ser_ativa_quando_em_execucao(self, props_validas):
            """Interrupcao EM_EXECUCAO e ativa."""
            props_validas["status"] = StatusOcorrencia.EM_EXECUCAO
            interrupcao = InterrupcaoMapa.create(props_validas).value

            assert interrupcao.is_ativa() is True

        def test_nao_deve_ser_ativa_quando_concluida(self, props_validas):
            """Interrupcao CONCLUIDA nao e ativa."""
            props_validas["status"] = StatusOcorrencia.CONCLUIDA
            interrupcao = InterrupcaoMapa.create(props_validas).value

            assert interrupcao.is_ativa() is False

    class TestGetDuracaoMinutos:
        """Testes para metodo get_duracao_minutos()."""

        def test_deve_calcular_duracao_corretamente(self, props_validas):
            """Duracao deve ser calculada desde data_inicio."""
            props_validas["data_inicio"] = datetime.now() - timedelta(hours=3)
            interrupcao = InterrupcaoMapa.create(props_validas).value

            duracao = interrupcao.get_duracao_minutos()

            # Aproximadamente 180 minutos
            assert 175 < duracao < 185

    class TestAtualizar:
        """Testes para metodo atualizar()."""

        def test_deve_recalcular_faixa_e_chi(self, props_validas):
            """Atualizar deve recalcular faixa e CHI."""
            interrupcao = InterrupcaoMapa.create(props_validas).value
            chi_inicial = interrupcao.chi

            # Simular passagem de tempo alterando data_inicio
            interrupcao.data_inicio = datetime.now() - timedelta(hours=5)
            interrupcao.atualizar()

            assert interrupcao.chi > chi_inicial
            assert interrupcao.faixa_duracao == FaixaDuracao.DE_3_A_6H

    class TestToPopupHtml:
        """Testes para metodo to_popup_html()."""

        def test_deve_gerar_html_com_informacoes(self, props_validas):
            """Popup deve conter informacoes principais."""
            interrupcao = InterrupcaoMapa.create(props_validas).value

            html = interrupcao.to_popup_html()

            assert "2025-001234" in html
            assert "Centro" in html
            assert "Em Execucao" in html
            assert "150" in html

        def test_deve_mostrar_em_investigacao_quando_causa_desconhecida(
            self, props_validas
        ):
            """Causa desconhecida deve mostrar 'Em investigacao'."""
            props_validas["causa_conhecida"] = False
            interrupcao = InterrupcaoMapa.create(props_validas).value

            html = interrupcao.to_popup_html()

            assert "Em investigacao" in html
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Todos atributos do Art. 107 presentes
- [ ] Calculo automatico de faixa e CHI
- [ ] Metodo is_ativa() funcional
- [ ] Metodo atualizar() funcional
- [ ] Metodo to_popup_html() funcional
- [ ] Igualdade por ID
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/entities/test_interrupcao_mapa.py -v

# Com cobertura
pytest tests/unit/domain/entities/test_interrupcao_mapa.py --cov=shared/domain/entities/interrupcao_mapa --cov-report=term-missing
```
