# RAD-205: Protocol MapaRepository

**Fase:** 2 - Application Layer
**Tipo:** Port/Protocol
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-203
**Base Legal:** REN 1.137/2025 - Art. 106

## Objetivo

Criar Protocol (Port) para repositorio de dados do mapa, seguindo Arquitetura Hexagonal (Ports & Adapters).

## Localizacao

`backend/shared/domain/repositories/mapa_repository.py`

## Especificacao

### Principios Aplicados

- **Hexagonal Architecture:** Port na camada de dominio
- **Dependency Inversion (SOLID):** Dominio define interface, infra implementa
- **Interface Segregation (SOLID):** Interfaces pequenas e focadas

### Metodos Requeridos

| Metodo | Retorno | Descricao |
|--------|---------|-----------|
| `buscar_interrupcoes_ativas()` | `list[InterrupcaoMapa]` | Todas interrupcoes ativas |
| `buscar_por_municipio(ibge)` | `list[InterrupcaoMapa]` | Filtro por municipio |
| `buscar_por_faixa(faixa)` | `list[InterrupcaoMapa]` | Filtro por faixa |
| `buscar_estatisticas()` | `EstatisticasMapa` | Metricas agregadas |

## Implementacao

```python
# shared/domain/repositories/mapa_repository.py
from typing import Protocol
from dataclasses import dataclass
from ..entities.interrupcao_mapa import InterrupcaoMapa
from ..value_objects.codigo_ibge import CodigoIBGE
from ..value_objects.faixa_duracao import FaixaDuracao


@dataclass(frozen=True)
class EstatisticasMapa:
    """Agregado de estatisticas do mapa."""

    total_interrupcoes: int
    total_ucs_afetadas: int
    chi_total: float
    equipes_em_campo: int
    por_faixa: dict[FaixaDuracao, int]
    por_municipio: dict[str, int]


class MapaRepository(Protocol):
    """
    Port para repositorio de dados do mapa.

    Este Protocol define o contrato que deve ser implementado
    pela camada de infraestrutura (Adapter).

    Segue os principios:
    - Hexagonal Architecture (Port)
    - Dependency Inversion Principle
    - Interface Segregation Principle
    """

    async def buscar_interrupcoes_ativas(self) -> list[InterrupcaoMapa]:
        """
        Busca todas as interrupcoes ativas.

        Returns:
            Lista de interrupcoes com status != CONCLUIDA
        """
        ...

    async def buscar_por_municipio(
        self,
        codigo_ibge: CodigoIBGE,
    ) -> list[InterrupcaoMapa]:
        """
        Busca interrupcoes por municipio.

        Args:
            codigo_ibge: Codigo IBGE do municipio

        Returns:
            Lista de interrupcoes do municipio
        """
        ...

    async def buscar_por_faixa(
        self,
        faixa: FaixaDuracao,
    ) -> list[InterrupcaoMapa]:
        """
        Busca interrupcoes por faixa de duracao.

        Args:
            faixa: Faixa de duracao desejada

        Returns:
            Lista de interrupcoes na faixa
        """
        ...

    async def buscar_estatisticas(self) -> EstatisticasMapa:
        """
        Busca estatisticas agregadas do mapa.

        Returns:
            Agregado com metricas do mapa
        """
        ...

    async def buscar_por_id(
        self,
        interrupcao_id: str,
    ) -> InterrupcaoMapa | None:
        """
        Busca interrupcao por ID.

        Args:
            interrupcao_id: ID da interrupcao

        Returns:
            Interrupcao ou None se nao encontrada
        """
        ...


class MunicipioRepository(Protocol):
    """
    Port para dados de municipios.

    Interface segregada para dados geograficos dos municipios.
    """

    async def buscar_todos(self) -> list[dict]:
        """
        Busca todos os municipios com geometria.

        Returns:
            Lista de municipios com dados GeoJSON
        """
        ...

    async def buscar_por_ibge(
        self,
        codigo_ibge: CodigoIBGE,
    ) -> dict | None:
        """
        Busca municipio por codigo IBGE.

        Args:
            codigo_ibge: Codigo IBGE

        Returns:
            Dados do municipio ou None
        """
        ...
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/repositories/test_mapa_repository_protocol.py
import pytest
from typing import get_type_hints
from shared.domain.repositories.mapa_repository import (
    MapaRepository,
    MunicipioRepository,
    EstatisticasMapa,
)
from shared.domain.entities.interrupcao_mapa import InterrupcaoMapa
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.faixa_duracao import FaixaDuracao


class TestMapaRepositoryProtocol:
    """Testes para Protocol MapaRepository."""

    def test_protocol_deve_definir_buscar_interrupcoes_ativas(self):
        """Protocol deve ter metodo buscar_interrupcoes_ativas."""
        assert hasattr(MapaRepository, "buscar_interrupcoes_ativas")

    def test_protocol_deve_definir_buscar_por_municipio(self):
        """Protocol deve ter metodo buscar_por_municipio."""
        assert hasattr(MapaRepository, "buscar_por_municipio")

    def test_protocol_deve_definir_buscar_por_faixa(self):
        """Protocol deve ter metodo buscar_por_faixa."""
        assert hasattr(MapaRepository, "buscar_por_faixa")

    def test_protocol_deve_definir_buscar_estatisticas(self):
        """Protocol deve ter metodo buscar_estatisticas."""
        assert hasattr(MapaRepository, "buscar_estatisticas")

    def test_protocol_deve_definir_buscar_por_id(self):
        """Protocol deve ter metodo buscar_por_id."""
        assert hasattr(MapaRepository, "buscar_por_id")


class TestMunicipioRepositoryProtocol:
    """Testes para Protocol MunicipioRepository."""

    def test_protocol_deve_definir_buscar_todos(self):
        """Protocol deve ter metodo buscar_todos."""
        assert hasattr(MunicipioRepository, "buscar_todos")

    def test_protocol_deve_definir_buscar_por_ibge(self):
        """Protocol deve ter metodo buscar_por_ibge."""
        assert hasattr(MunicipioRepository, "buscar_por_ibge")


class TestEstatisticasMapa:
    """Testes para dataclass EstatisticasMapa."""

    def test_deve_ser_imutavel(self):
        """EstatisticasMapa deve ser frozen."""
        stats = EstatisticasMapa(
            total_interrupcoes=10,
            total_ucs_afetadas=1000,
            chi_total=5000.0,
            equipes_em_campo=5,
            por_faixa={FaixaDuracao.ATE_1H: 3},
            por_municipio={"1400100": 5},
        )

        with pytest.raises(AttributeError):
            stats.total_interrupcoes = 20

    def test_deve_conter_todos_atributos(self):
        """Deve ter todos os atributos necessarios."""
        stats = EstatisticasMapa(
            total_interrupcoes=10,
            total_ucs_afetadas=1000,
            chi_total=5000.0,
            equipes_em_campo=5,
            por_faixa={},
            por_municipio={},
        )

        assert stats.total_interrupcoes == 10
        assert stats.total_ucs_afetadas == 1000
        assert stats.chi_total == 5000.0
        assert stats.equipes_em_campo == 5


class TestImplementacaoFake:
    """Testes com implementacao fake para validar contrato."""

    class FakeMapaRepository:
        """Implementacao fake para testes."""

        async def buscar_interrupcoes_ativas(self) -> list[InterrupcaoMapa]:
            return []

        async def buscar_por_municipio(
            self, codigo_ibge: CodigoIBGE
        ) -> list[InterrupcaoMapa]:
            return []

        async def buscar_por_faixa(
            self, faixa: FaixaDuracao
        ) -> list[InterrupcaoMapa]:
            return []

        async def buscar_estatisticas(self) -> EstatisticasMapa:
            return EstatisticasMapa(
                total_interrupcoes=0,
                total_ucs_afetadas=0,
                chi_total=0.0,
                equipes_em_campo=0,
                por_faixa={},
                por_municipio={},
            )

        async def buscar_por_id(
            self, interrupcao_id: str
        ) -> InterrupcaoMapa | None:
            return None

    def test_fake_implementa_protocol(self):
        """FakeMapaRepository deve implementar Protocol."""
        repo = self.FakeMapaRepository()

        # Se nao lancar erro, implementa o Protocol
        assert isinstance(repo, MapaRepository)

    @pytest.mark.asyncio
    async def test_fake_retorna_tipos_corretos(self):
        """Fake deve retornar tipos corretos."""
        repo = self.FakeMapaRepository()

        interrupcoes = await repo.buscar_interrupcoes_ativas()
        assert isinstance(interrupcoes, list)

        stats = await repo.buscar_estatisticas()
        assert isinstance(stats, EstatisticasMapa)
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Protocol definido (nao ABC)
- [ ] Todos os metodos documentados
- [ ] Type hints corretos
- [ ] Dataclass EstatisticasMapa frozen
- [ ] Interface segregada (2 Protocols)
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/repositories/test_mapa_repository_protocol.py -v

# Com cobertura
pytest tests/unit/domain/repositories/test_mapa_repository_protocol.py --cov=shared/domain/repositories/mapa_repository --cov-report=term-missing
```
