# RAD-229: Monitoramento (Health Check)

**Fase:** 7 - Deploy
**Tipo:** Monitoring
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-213, RAD-228

## Objetivo

Implementar health checks e monitoramento do portal.

## Localizacao

`backend/apps/mapa_interrupcoes/health.py`

## Implementacao

```python
# apps/mapa_interrupcoes/health.py
"""Health checks para o portal de interrupcoes."""
from datetime import datetime, timedelta
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from sqlalchemy import text
from shared.infrastructure.database.oracle_connection import get_session
from shared.infrastructure.cache.memory_cache import MemoryCacheService

router = APIRouter(tags=["Health"])


class HealthStatus(BaseModel):
    """Schema de status de saude."""

    status: str  # healthy, degraded, unhealthy
    timestamp: datetime
    version: str
    components: dict


class ComponentHealth(BaseModel):
    """Schema de saude de componente."""

    status: str
    message: str | None = None
    latency_ms: float | None = None


@router.get("/health", response_model=HealthStatus)
async def health_check():
    """
    Health check completo do sistema.

    Verifica:
    - Conexao com Oracle
    - Servico de cache
    - Ultima atualizacao dos dados
    """
    components = {}
    overall_status = "healthy"

    # Verificar Oracle
    oracle_health = await check_oracle()
    components["oracle"] = oracle_health
    if oracle_health["status"] != "healthy":
        overall_status = "degraded"

    # Verificar Cache
    cache_health = await check_cache()
    components["cache"] = cache_health
    if cache_health["status"] != "healthy":
        overall_status = "degraded"

    # Verificar dados atualizados
    data_health = await check_data_freshness()
    components["data_freshness"] = data_health
    if data_health["status"] != "healthy":
        overall_status = "degraded"

    return HealthStatus(
        status=overall_status,
        timestamp=datetime.now(),
        version="1.0.0",
        components=components,
    )


@router.get("/health/live")
async def liveness():
    """
    Liveness probe (Kubernetes).

    Retorna 200 se o processo esta rodando.
    """
    return {"status": "alive"}


@router.get("/health/ready")
async def readiness():
    """
    Readiness probe (Kubernetes).

    Retorna 200 se o servico esta pronto para receber trafego.
    """
    # Verificar Oracle
    oracle_health = await check_oracle()
    if oracle_health["status"] != "healthy":
        raise HTTPException(status_code=503, detail="Oracle not ready")

    return {"status": "ready"}


async def check_oracle() -> dict:
    """Verifica conexao com Oracle."""
    try:
        start = datetime.now()
        async with get_session() as session:
            result = await session.execute(text("SELECT 1 FROM DUAL"))
            result.fetchone()
        latency = (datetime.now() - start).total_seconds() * 1000

        return {
            "status": "healthy",
            "latency_ms": round(latency, 2),
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "message": str(e),
        }


async def check_cache() -> dict:
    """Verifica servico de cache."""
    try:
        cache = MemoryCacheService()
        start = datetime.now()

        # Teste de escrita e leitura
        await cache.set("health_check", "ok", 10)
        value = await cache.get("health_check")

        latency = (datetime.now() - start).total_seconds() * 1000

        if value != "ok":
            return {
                "status": "unhealthy",
                "message": "Cache read/write failed",
            }

        return {
            "status": "healthy",
            "latency_ms": round(latency, 2),
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "message": str(e),
        }


async def check_data_freshness() -> dict:
    """
    Verifica se os dados estao atualizados.

    REN 1.137 exige atualizacao a cada 30 minutos.
    """
    try:
        cache = MemoryCacheService()
        cached_data = await cache.get("mapa:interrupcoes")

        if not cached_data:
            return {
                "status": "degraded",
                "message": "No cached data",
            }

        # Verificar timestamp (se implementado)
        # if "timestamp" in cached_data:
        #     last_update = datetime.fromisoformat(cached_data["timestamp"])
        #     if datetime.now() - last_update > timedelta(minutes=35):
        #         return {
        #             "status": "degraded",
        #             "message": "Data older than 35 minutes",
        #         }

        return {
            "status": "healthy",
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "message": str(e),
        }
```

### Prometheus Metrics

```python
# apps/mapa_interrupcoes/metrics.py
"""Metricas Prometheus para monitoramento."""
from prometheus_client import Counter, Histogram, Gauge, generate_latest
from fastapi import APIRouter, Response

router = APIRouter()

# Metricas
REQUEST_COUNT = Counter(
    "mapa_requests_total",
    "Total de requisicoes",
    ["method", "endpoint", "status"],
)

REQUEST_LATENCY = Histogram(
    "mapa_request_latency_seconds",
    "Latencia das requisicoes",
    ["method", "endpoint"],
)

INTERRUPCOES_ATIVAS = Gauge(
    "mapa_interrupcoes_ativas",
    "Numero de interrupcoes ativas",
)

UCS_AFETADAS = Gauge(
    "mapa_ucs_afetadas_total",
    "Total de UCs afetadas",
)

CHI_TOTAL = Gauge(
    "mapa_chi_total",
    "CHI total",
)

EQUIPES_CAMPO = Gauge(
    "mapa_equipes_em_campo",
    "Equipes em campo",
)

CACHE_HITS = Counter(
    "mapa_cache_hits_total",
    "Cache hits",
)

CACHE_MISSES = Counter(
    "mapa_cache_misses_total",
    "Cache misses",
)


@router.get("/metrics")
async def metrics():
    """Endpoint de metricas Prometheus."""
    return Response(
        content=generate_latest(),
        media_type="text/plain; version=0.0.4",
    )


def atualizar_metricas(stats):
    """Atualiza metricas com estatisticas."""
    INTERRUPCOES_ATIVAS.set(stats.total_interrupcoes)
    UCS_AFETADAS.set(stats.total_ucs_afetadas)
    CHI_TOTAL.set(stats.chi_total)
    EQUIPES_CAMPO.set(stats.equipes_em_campo)
```

### Alertas (Prometheus Rules)

```yaml
# deploy/prometheus/alerts.yml
groups:
  - name: mapa_interrupcoes
    rules:
      - alert: MapaUnavailable
        expr: up{job="mapa-portal"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: Portal de interrupcoes indisponivel

      - alert: MapaHighLatency
        expr: histogram_quantile(0.95, rate(mapa_request_latency_seconds_bucket[5m])) > 2
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: Latencia alta no portal (P95 > 2s)

      - alert: MapaDataStale
        expr: time() - mapa_last_update_timestamp > 2100  # 35 min
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: Dados do mapa desatualizados (> 35 min)

      - alert: MapaHighInterrupcoes
        expr: mapa_interrupcoes_ativas > 50
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: Alto numero de interrupcoes ativas
```

## Criterios de Aceite

- [ ] Endpoint /health funcional
- [ ] Liveness probe (/health/live)
- [ ] Readiness probe (/health/ready)
- [ ] Verificacao Oracle
- [ ] Verificacao Cache
- [ ] Verificacao dados frescos
- [ ] Metricas Prometheus
- [ ] Alertas configurados

## Comando de Execucao

```bash
# Testar health check
curl http://localhost:8000/health

# Testar liveness
curl http://localhost:8000/health/live

# Testar readiness
curl http://localhost:8000/health/ready

# Ver metricas
curl http://localhost:8000/metrics
```
