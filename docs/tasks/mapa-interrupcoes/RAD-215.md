# RAD-215: Endpoint GET /api/mapa/estatisticas

**Fase:** 4 - Interfaces Layer
**Tipo:** API Endpoint
**Prioridade:** Alta
**Status:** PENDENTE
**Dependencias:** RAD-204, RAD-206, RAD-207
**Base Legal:** REN 1.137/2025 - Art. 107

## Objetivo

Criar endpoint para retornar estatisticas agregadas do mapa.

## Localizacao

`backend/apps/mapa_interrupcoes/routes.py`

## Especificacao

### Endpoint

```
GET /api/mapa/estatisticas
```

### Response (200 OK)

```json
{
  "success": true,
  "data": {
    "resumo": {
      "totalInterrupcoes": 25,
      "totalUcsAfetadas": 5000,
      "chiTotal": 15000.0,
      "equipesEmCampo": 15
    },
    "porFaixa": [
      {
        "faixa": "ATE_1H",
        "label": "Menos de 1 hora",
        "cor": "#4CAF50",
        "quantidade": 5,
        "percentual": 20.0,
        "ucsAfetadas": 500
      }
    ],
    "porMunicipio": [
      {
        "codigoIbge": "1400100",
        "nome": "Boa Vista",
        "quantidade": 10,
        "percentual": 40.0,
        "ucsAfetadas": 2000
      }
    ],
    "porTipo": {
      "programada": 5,
      "naoProgramada": 20
    },
    "porStatus": [
      {
        "status": "EM_EXECUCAO",
        "label": "Em Execucao",
        "quantidade": 15,
        "equipes": 10
      }
    ],
    "ultimaAtualizacao": "2025-12-19T10:30:00"
  },
  "fromCache": false
}
```

## Implementacao

```python
# apps/mapa_interrupcoes/routes.py (adicionar ao arquivo existente)

from datetime import datetime
from pydantic import BaseModel, Field, ConfigDict


class ResumoEstatisticas(BaseModel):
    """Schema para resumo geral."""

    total_interrupcoes: int = Field(..., alias="totalInterrupcoes", ge=0)
    total_ucs_afetadas: int = Field(..., alias="totalUcsAfetadas", ge=0)
    chi_total: float = Field(..., alias="chiTotal", ge=0)
    equipes_em_campo: int = Field(..., alias="equipesEmCampo", ge=0)

    model_config = ConfigDict(populate_by_name=True)


class EstatisticaPorFaixa(BaseModel):
    """Schema para estatistica por faixa."""

    faixa: str
    label: str
    cor: str
    quantidade: int = Field(..., ge=0)
    percentual: float = Field(..., ge=0, le=100)
    ucs_afetadas: int = Field(..., alias="ucsAfetadas", ge=0)

    model_config = ConfigDict(populate_by_name=True)


class EstatisticaPorMunicipio(BaseModel):
    """Schema para estatistica por municipio."""

    codigo_ibge: str = Field(..., alias="codigoIbge")
    nome: str
    quantidade: int = Field(..., ge=0)
    percentual: float = Field(..., ge=0, le=100)
    ucs_afetadas: int = Field(..., alias="ucsAfetadas", ge=0)

    model_config = ConfigDict(populate_by_name=True)


class EstatisticaPorTipo(BaseModel):
    """Schema para estatistica por tipo."""

    programada: int = Field(..., ge=0)
    nao_programada: int = Field(..., alias="naoProgramada", ge=0)

    model_config = ConfigDict(populate_by_name=True)


class EstatisticaPorStatus(BaseModel):
    """Schema para estatistica por status."""

    status: str
    label: str
    quantidade: int = Field(..., ge=0)
    equipes: int = Field(..., ge=0)


class EstatisticasData(BaseModel):
    """Schema para dados de estatisticas."""

    resumo: ResumoEstatisticas
    por_faixa: list[EstatisticaPorFaixa] = Field(..., alias="porFaixa")
    por_municipio: list[EstatisticaPorMunicipio] = Field(..., alias="porMunicipio")
    por_tipo: EstatisticaPorTipo = Field(..., alias="porTipo")
    por_status: list[EstatisticaPorStatus] = Field(..., alias="porStatus")
    ultima_atualizacao: datetime = Field(..., alias="ultimaAtualizacao")

    model_config = ConfigDict(populate_by_name=True)


class EstatisticasMapaResponse(BaseModel):
    """Response completa de estatisticas."""

    success: bool = True
    data: EstatisticasData
    from_cache: bool = Field(..., alias="fromCache")

    model_config = ConfigDict(populate_by_name=True)


@router.get(
    "/estatisticas",
    response_model=EstatisticasMapaResponse,
    summary="Estatisticas agregadas do mapa",
    description="""
    Retorna estatisticas agregadas das interrupcoes:

    **Resumo Geral:**
    - Total de interrupcoes ativas
    - Total de UCs afetadas
    - CHI total
    - Equipes em campo

    **Agrupamentos:**
    - Por faixa de duracao
    - Por municipio
    - Por tipo (programada/nao programada)
    - Por status

    **Cache:** Dados atualizados a cada 30 minutos (REN 1.137 Art. 106)
    """,
)
async def get_estatisticas(
    use_case: GetInterrupcoesMapaUseCase = Depends(get_interrupcoes_use_case),
    equipes_use_case: GetEquipesEmCampoUseCase = Depends(
        get_equipes_use_case
    ),
) -> EstatisticasMapaResponse:
    """
    Retorna estatisticas agregadas do mapa.

    Args:
        use_case: Use case de interrupcoes
        equipes_use_case: Use case de equipes

    Returns:
        EstatisticasMapaResponse com todos agregados
    """
    # Buscar interrupcoes
    result = await use_case.execute()

    if result.is_failure:
        raise HTTPException(
            status_code=500,
            detail={"error": result.error},
        )

    output = result.value
    interrupcoes = output.interrupcoes
    stats = output.estatisticas

    # Calcular agregados
    total = len(interrupcoes)

    # Por faixa
    por_faixa_map = {}
    for i in interrupcoes:
        faixa = i.faixa_duracao
        if faixa not in por_faixa_map:
            por_faixa_map[faixa] = {"qtd": 0, "ucs": 0}
        por_faixa_map[faixa]["qtd"] += 1
        por_faixa_map[faixa]["ucs"] += i.ucs_afetadas

    por_faixa = [
        EstatisticaPorFaixa(
            faixa=faixa.value,
            label=faixa.get_label(),
            cor=faixa.get_cor(),
            quantidade=data["qtd"],
            percentual=(data["qtd"] / total * 100) if total > 0 else 0,
            ucsAfetadas=data["ucs"],
        )
        for faixa, data in sorted(
            por_faixa_map.items(),
            key=lambda x: x[0].get_severidade(),
        )
    ]

    # Por municipio
    por_mun_map = {}
    for i in interrupcoes:
        ibge = i.municipio.valor
        if ibge not in por_mun_map:
            por_mun_map[ibge] = {"qtd": 0, "ucs": 0}
        por_mun_map[ibge]["qtd"] += 1
        por_mun_map[ibge]["ucs"] += i.ucs_afetadas

    por_municipio = [
        EstatisticaPorMunicipio(
            codigoIbge=ibge,
            nome=InterrupcaoMapaResponse._get_nome_municipio(ibge),
            quantidade=data["qtd"],
            percentual=(data["qtd"] / total * 100) if total > 0 else 0,
            ucsAfetadas=data["ucs"],
        )
        for ibge, data in sorted(
            por_mun_map.items(),
            key=lambda x: -x[1]["qtd"],
        )
    ]

    # Por tipo
    programadas = sum(1 for i in interrupcoes if i.tipo.is_programada())
    por_tipo = EstatisticaPorTipo(
        programada=programadas,
        naoProgramada=total - programadas,
    )

    # Por status
    por_status_map = {}
    for i in interrupcoes:
        status = i.status
        if status not in por_status_map:
            por_status_map[status] = {"qtd": 0, "equipes": 0}
        por_status_map[status]["qtd"] += 1
        por_status_map[status]["equipes"] += i.equipes_designadas

    por_status = [
        EstatisticaPorStatus(
            status=status.value,
            label=status.get_label(),
            quantidade=data["qtd"],
            equipes=data["equipes"],
        )
        for status, data in sorted(
            por_status_map.items(),
            key=lambda x: x[0].get_ordem(),
        )
    ]

    # Montar response
    return EstatisticasMapaResponse(
        success=True,
        data=EstatisticasData(
            resumo=ResumoEstatisticas(
                totalInterrupcoes=stats.total_interrupcoes if stats else total,
                totalUcsAfetadas=stats.total_ucs_afetadas if stats else sum(
                    i.ucs_afetadas for i in interrupcoes
                ),
                chiTotal=stats.chi_total if stats else sum(
                    i.chi for i in interrupcoes
                ),
                equipesEmCampo=stats.equipes_em_campo if stats else sum(
                    i.equipes_designadas for i in interrupcoes if i.is_ativa()
                ),
            ),
            porFaixa=por_faixa,
            porMunicipio=por_municipio,
            porTipo=por_tipo,
            porStatus=por_status,
            ultimaAtualizacao=datetime.now(),
        ),
        fromCache=output.from_cache,
    )
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/e2e/api/test_mapa_estatisticas.py
import pytest
from httpx import AsyncClient
from fastapi import status


@pytest.mark.e2e
class TestGetEstatisticas:
    """Testes E2E para GET /api/mapa/estatisticas."""

    @pytest.mark.asyncio
    async def test_deve_retornar_200(self, client: AsyncClient):
        """Requisicao deve retornar 200."""
        response = await client.get("/api/mapa/estatisticas")

        assert response.status_code == status.HTTP_200_OK

    @pytest.mark.asyncio
    async def test_deve_retornar_resumo(self, client: AsyncClient):
        """Response deve ter resumo geral."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        resumo = body["data"]["resumo"]

        assert "totalInterrupcoes" in resumo
        assert "totalUcsAfetadas" in resumo
        assert "chiTotal" in resumo
        assert "equipesEmCampo" in resumo

    @pytest.mark.asyncio
    async def test_deve_retornar_estatisticas_por_faixa(
        self, client: AsyncClient
    ):
        """Response deve ter estatisticas por faixa."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        por_faixa = body["data"]["porFaixa"]

        assert isinstance(por_faixa, list)

        if por_faixa:
            item = por_faixa[0]
            assert "faixa" in item
            assert "label" in item
            assert "cor" in item
            assert "quantidade" in item
            assert "percentual" in item

    @pytest.mark.asyncio
    async def test_deve_retornar_estatisticas_por_municipio(
        self, client: AsyncClient
    ):
        """Response deve ter estatisticas por municipio."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        por_mun = body["data"]["porMunicipio"]

        assert isinstance(por_mun, list)

        if por_mun:
            item = por_mun[0]
            assert "codigoIbge" in item
            assert "nome" in item
            assert "quantidade" in item

    @pytest.mark.asyncio
    async def test_deve_retornar_estatisticas_por_tipo(
        self, client: AsyncClient
    ):
        """Response deve ter estatisticas por tipo."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        por_tipo = body["data"]["porTipo"]

        assert "programada" in por_tipo
        assert "naoProgramada" in por_tipo

    @pytest.mark.asyncio
    async def test_deve_retornar_estatisticas_por_status(
        self, client: AsyncClient
    ):
        """Response deve ter estatisticas por status."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        por_status = body["data"]["porStatus"]

        assert isinstance(por_status, list)

        if por_status:
            item = por_status[0]
            assert "status" in item
            assert "label" in item
            assert "quantidade" in item

    @pytest.mark.asyncio
    async def test_deve_incluir_ultima_atualizacao(
        self, client: AsyncClient
    ):
        """Response deve ter timestamp da ultima atualizacao."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        assert "ultimaAtualizacao" in body["data"]

    @pytest.mark.asyncio
    async def test_percentuais_devem_somar_100(
        self, client: AsyncClient
    ):
        """Percentuais por faixa devem somar ~100%."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        por_faixa = body["data"]["porFaixa"]

        if por_faixa:
            total_percentual = sum(f["percentual"] for f in por_faixa)
            # Permitir pequena variacao por arredondamento
            assert 99.0 <= total_percentual <= 101.0

    @pytest.mark.asyncio
    async def test_deve_indicar_origem_cache(
        self, client: AsyncClient
    ):
        """Response deve indicar se veio do cache."""
        response = await client.get("/api/mapa/estatisticas")

        body = response.json()
        assert "fromCache" in body
```

## Criterios de Aceite

- [ ] Testes E2E escritos e passando
- [ ] Resumo geral com totais
- [ ] Estatisticas por faixa com percentuais
- [ ] Estatisticas por municipio
- [ ] Estatisticas por tipo
- [ ] Estatisticas por status
- [ ] Timestamp de ultima atualizacao
- [ ] Documentacao OpenAPI gerada
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/e2e/api/test_mapa_estatisticas.py -v

# Testar manualmente
curl http://localhost:8000/api/mapa/estatisticas
```
