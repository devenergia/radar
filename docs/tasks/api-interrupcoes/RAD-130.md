# RAD-130: IP Whitelist ANEEL

**Fase:** 6 - Seguranca e Compliance
**Tipo:** Security
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-116

## Objetivo

Implementar validacao de whitelist de IP conforme especificacao ANEEL, restringindo acesso apenas ao bloco de IPs autorizados.

## Localizacao

`backend/apps/api_interrupcoes/security/ip_whitelist.py`

## Especificacao

### Requisitos ANEEL (Secao 5 - 04-seguranca.md)

1. **Bloco autorizado:** `200.198.220.128/25` (128 enderecos)
2. **Range:** 200.198.220.128 a 200.198.220.255
3. **Ordem de validacao:** IP Whitelist **ANTES** de API Key
4. **Resposta para IP nao autorizado:** HTTP 403 Forbidden

### Fluxo de Validacao

```
Requisicao
   |
   v
+------------------+
| IP na whitelist? |
+--------+---------+
         |
    +----+----+
    |         |
   Nao       Sim
    |         |
    v         v
+--------+ +------------------+
| 403    | | Verificar        |
| Erro   | | API Key (RAD-122)|
+--------+ +------------------+
```

## Implementacao

```python
# apps/api_interrupcoes/security/ip_whitelist.py
from ipaddress import ip_address, ip_network
from fastapi import Request, HTTPException, status
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse

from shared.infrastructure.config import Settings, get_settings


class IpWhitelistConfig:
    """Configuracao de whitelist de IP."""

    # Bloco ANEEL conforme Oficio Circular 14/2025-SFE/ANEEL
    ANEEL_CIDR = "200.198.220.128/25"

    def __init__(self, settings: Settings | None = None) -> None:
        self._settings = settings or get_settings()
        self._allowed_networks = self._load_networks()

    def _load_networks(self) -> list:
        """Carrega redes permitidas."""
        networks = [ip_network(self.ANEEL_CIDR)]

        # Adicionar redes extras do settings (para desenvolvimento/testes)
        if self._settings.ip_whitelist_extra:
            for cidr in self._settings.ip_whitelist_extra.split(","):
                networks.append(ip_network(cidr.strip()))

        return networks

    def is_allowed(self, ip: str) -> bool:
        """Verifica se IP esta na whitelist."""
        try:
            client_ip = ip_address(ip)
            return any(client_ip in network for network in self._allowed_networks)
        except ValueError:
            return False


class IpWhitelistMiddleware(BaseHTTPMiddleware):
    """
    Middleware para validar whitelist de IP.

    IMPORTANTE: Este middleware deve ser adicionado ANTES
    do middleware de autenticacao (API Key).
    """

    def __init__(self, app, settings: Settings | None = None):
        super().__init__(app)
        self._config = IpWhitelistConfig(settings)
        self._bypass_paths = {"/health", "/docs", "/redoc", "/openapi.json"}

    async def dispatch(self, request: Request, call_next):
        # Bypass para endpoints publicos
        if request.url.path in self._bypass_paths:
            return await call_next(request)

        # Obter IP do cliente
        client_ip = self._get_client_ip(request)

        # Validar whitelist
        if not self._config.is_allowed(client_ip):
            return self._forbidden_response(client_ip)

        return await call_next(request)

    def _get_client_ip(self, request: Request) -> str:
        """
        Obtem IP real do cliente.

        Considera headers de proxy reverso:
        - X-Forwarded-For
        - X-Real-IP
        """
        # Tentar X-Forwarded-For primeiro (lista de IPs separados por virgula)
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            # Primeiro IP e o cliente original
            return forwarded_for.split(",")[0].strip()

        # Tentar X-Real-IP
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip.strip()

        # Fallback para IP direto
        if request.client:
            return request.client.host

        return "unknown"

    def _forbidden_response(self, ip: str) -> JSONResponse:
        """Resposta no formato ANEEL para IP nao autorizado."""
        return JSONResponse(
            status_code=403,
            content={
                "idcStatusRequisicao": 2,
                "desStatusRequisicao": "Acesso negado",
                "emailIndisponibilidade": "radar@roraimaenergia.com.br",
                "mensagem": "IP de origem nao autorizado",
                "interrupcaoFornecimento": [],
            },
        )


# Dependency para uso em rotas especificas
async def verify_ip_whitelist(request: Request) -> str:
    """
    Dependency para validar IP em rotas especificas.

    Returns:
        IP do cliente validado

    Raises:
        HTTPException: 403 se IP nao autorizado
    """
    config = IpWhitelistConfig()
    client_ip = request.headers.get("X-Forwarded-For", "").split(",")[0].strip()

    if not client_ip and request.client:
        client_ip = request.client.host

    if not config.is_allowed(client_ip):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail={
                "idcStatusRequisicao": 2,
                "desStatusRequisicao": "Acesso negado",
                "emailIndisponibilidade": "radar@roraimaenergia.com.br",
                "mensagem": "IP de origem nao autorizado",
                "interrupcaoFornecimento": [],
            },
        )

    return client_ip
```

## Configuracao

```python
# shared/infrastructure/config.py (adicionar)
class Settings(BaseSettings):
    # ... campos existentes ...

    # IP Whitelist - redes adicionais para dev/test (separadas por virgula)
    ip_whitelist_extra: str | None = Field(
        None,
        description="CIDRs adicionais para whitelist (ex: 10.0.0.0/8,192.168.0.0/16)",
    )

    class Config:
        env_file = ".env"
        env_prefix = "RADAR_"
```

```bash
# .env (desenvolvimento)
RADAR_IP_WHITELIST_EXTRA=127.0.0.0/8,10.0.0.0/8,192.168.0.0/16
```

## Configuracao no Main

```python
# apps/api_interrupcoes/main.py
from fastapi import FastAPI

from .security.ip_whitelist import IpWhitelistMiddleware
from .middleware import AuditMiddleware, RateLimitMiddleware


def create_app() -> FastAPI:
    app = FastAPI(
        title="API Interrupcoes - RADAR",
        description="API de Quantitativo de Interrupcoes Ativas",
        version="1.0.0",
    )

    # IMPORTANTE: Ordem dos middlewares
    # 1. IP Whitelist (primeiro - bloqueia antes de qualquer processamento)
    # 2. Rate Limiting (segundo)
    # 3. Audit/Logging (terceiro)
    app.add_middleware(AuditMiddleware)
    app.add_middleware(RateLimitMiddleware, requests_per_minute=10)
    app.add_middleware(IpWhitelistMiddleware)  # Executado primeiro

    # ... resto da configuracao ...

    return app
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/security/test_ip_whitelist.py
import pytest
from unittest.mock import MagicMock, patch
from fastapi import HTTPException

from apps.api_interrupcoes.security.ip_whitelist import (
    IpWhitelistConfig,
    IpWhitelistMiddleware,
    verify_ip_whitelist,
)
from shared.infrastructure.config import Settings


class TestIpWhitelistConfig:
    """Testes para configuracao de whitelist."""

    def test_deve_permitir_ip_do_bloco_aneel(self):
        """IP dentro do bloco ANEEL deve ser permitido."""
        config = IpWhitelistConfig()

        # IPs validos do bloco 200.198.220.128/25
        assert config.is_allowed("200.198.220.128") is True
        assert config.is_allowed("200.198.220.150") is True
        assert config.is_allowed("200.198.220.200") is True
        assert config.is_allowed("200.198.220.255") is True

    def test_deve_rejeitar_ip_fora_do_bloco_aneel(self):
        """IP fora do bloco ANEEL deve ser rejeitado."""
        config = IpWhitelistConfig()

        # IPs fora do bloco
        assert config.is_allowed("200.198.220.127") is False  # Antes do bloco
        assert config.is_allowed("200.198.221.1") is False    # Outro bloco
        assert config.is_allowed("192.168.1.1") is False      # IP privado
        assert config.is_allowed("8.8.8.8") is False          # IP publico

    def test_deve_rejeitar_ip_invalido(self):
        """IP invalido deve ser rejeitado."""
        config = IpWhitelistConfig()

        assert config.is_allowed("invalid") is False
        assert config.is_allowed("") is False
        assert config.is_allowed("256.256.256.256") is False

    def test_deve_permitir_ips_extras_do_settings(self):
        """IPs de redes extras devem ser permitidos."""
        settings = Settings(ip_whitelist_extra="192.168.0.0/16,10.0.0.0/8")
        config = IpWhitelistConfig(settings)

        # IPs das redes extras
        assert config.is_allowed("192.168.1.100") is True
        assert config.is_allowed("10.20.30.40") is True

        # IP ANEEL ainda deve funcionar
        assert config.is_allowed("200.198.220.150") is True


class TestIpWhitelistMiddleware:
    """Testes para middleware de whitelist."""

    @pytest.fixture
    def middleware(self):
        """Middleware com settings de teste."""
        app = MagicMock()
        settings = Settings(ip_whitelist_extra="127.0.0.0/8")
        return IpWhitelistMiddleware(app, settings)

    def test_deve_extrair_ip_de_x_forwarded_for(self, middleware):
        """Deve usar primeiro IP do X-Forwarded-For."""
        request = MagicMock()
        request.headers = {"X-Forwarded-For": "200.198.220.150, 10.0.0.1, 192.168.1.1"}
        request.client = MagicMock(host="127.0.0.1")

        ip = middleware._get_client_ip(request)

        assert ip == "200.198.220.150"

    def test_deve_extrair_ip_de_x_real_ip(self, middleware):
        """Deve usar X-Real-IP se X-Forwarded-For ausente."""
        request = MagicMock()
        request.headers = {"X-Real-IP": "200.198.220.150"}
        request.client = MagicMock(host="127.0.0.1")

        ip = middleware._get_client_ip(request)

        assert ip == "200.198.220.150"

    def test_deve_usar_client_host_como_fallback(self, middleware):
        """Deve usar request.client.host se headers ausentes."""
        request = MagicMock()
        request.headers = {}
        request.client = MagicMock(host="200.198.220.150")

        ip = middleware._get_client_ip(request)

        assert ip == "200.198.220.150"

    def test_resposta_403_deve_ter_formato_aneel(self, middleware):
        """Resposta 403 deve seguir formato ANEEL."""
        response = middleware._forbidden_response("192.168.1.1")

        assert response.status_code == 403
        body = response.body.decode()
        assert "idcStatusRequisicao" in body
        assert "IP de origem nao autorizado" in body


class TestVerifyIpWhitelistDependency:
    """Testes para dependency de validacao."""

    @pytest.mark.asyncio
    async def test_deve_retornar_ip_quando_valido(self):
        """Deve retornar IP quando na whitelist."""
        request = MagicMock()
        request.headers = {"X-Forwarded-For": "200.198.220.150"}
        request.client = None

        with patch.object(IpWhitelistConfig, "is_allowed", return_value=True):
            ip = await verify_ip_whitelist(request)
            assert ip == "200.198.220.150"

    @pytest.mark.asyncio
    async def test_deve_lancar_403_quando_ip_invalido(self):
        """Deve lancar 403 quando IP nao autorizado."""
        request = MagicMock()
        request.headers = {"X-Forwarded-For": "192.168.1.1"}
        request.client = None

        with patch.object(IpWhitelistConfig, "is_allowed", return_value=False):
            with pytest.raises(HTTPException) as exc_info:
                await verify_ip_whitelist(request)

            assert exc_info.value.status_code == 403

    @pytest.mark.asyncio
    async def test_resposta_erro_deve_ter_formato_aneel(self):
        """Erro deve ter formato ANEEL."""
        request = MagicMock()
        request.headers = {"X-Forwarded-For": "192.168.1.1"}
        request.client = None

        with patch.object(IpWhitelistConfig, "is_allowed", return_value=False):
            with pytest.raises(HTTPException) as exc_info:
                await verify_ip_whitelist(request)

            detail = exc_info.value.detail
            assert detail["idcStatusRequisicao"] == 2
            assert "IP de origem nao autorizado" in detail["mensagem"]


class TestIpWhitelistBypass:
    """Testes para bypass de endpoints publicos."""

    @pytest.fixture
    def middleware(self):
        app = MagicMock()
        return IpWhitelistMiddleware(app)

    @pytest.mark.asyncio
    async def test_deve_permitir_health_sem_validacao(self, middleware):
        """Endpoint /health deve ignorar whitelist."""
        request = MagicMock()
        request.url.path = "/health"
        request.client = MagicMock(host="192.168.1.1")  # IP nao autorizado

        call_next = MagicMock(return_value="response")

        result = await middleware.dispatch(request, call_next)

        call_next.assert_called_once_with(request)

    @pytest.mark.asyncio
    async def test_deve_permitir_docs_sem_validacao(self, middleware):
        """Endpoint /docs deve ignorar whitelist."""
        request = MagicMock()
        request.url.path = "/docs"
        request.client = MagicMock(host="192.168.1.1")

        call_next = MagicMock(return_value="response")

        result = await middleware.dispatch(request, call_next)

        call_next.assert_called_once_with(request)
```

## Criterios de Aceite

- [ ] Testes escritos PRIMEIRO e passando
- [ ] Validacao de bloco ANEEL (200.198.220.128/25)
- [ ] Suporte a headers de proxy (X-Forwarded-For, X-Real-IP)
- [ ] Resposta 403 no formato ANEEL
- [ ] Bypass para /health, /docs, /redoc
- [ ] Configuracao de IPs extras via environment
- [ ] Middleware adicionado ANTES de Rate Limiting e API Key
- [ ] Log de tentativas de acesso nao autorizado
- [ ] Cobertura de testes >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/security/test_ip_whitelist.py -v

# Com cobertura
pytest tests/unit/security/test_ip_whitelist.py --cov=apps/api_interrupcoes/security --cov-report=term-missing
```

## Relacionamento com Outras Tasks

- **RAD-116** (Main App): Adiciona middleware na ordem correta
- **RAD-122** (API Key): Executa DEPOIS da validacao de IP
- **RAD-123** (Rate Limiting): Executa DEPOIS da validacao de IP
- **RAD-124** (Logging): Registra tentativas de acesso nao autorizado

## Agentes Recomendados

- `@security-auditor` - Para validar implementacao de seguranca
- `@backend-architect` - Para revisar arquitetura de middlewares
