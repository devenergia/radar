# RAD-123: Rate Limiting (10 req/min)

**Fase:** 6 - Seguranca e Compliance
**Tipo:** Security
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-116

## Objetivo

Implementar rate limiting de 10 requisicoes por minuto conforme especificacao ANEEL (Secao 8.1 - 04-seguranca.md).

## IMPORTANTE: Requisitos ANEEL

- **Limite:** 10 requisicoes por minuto por IP/API Key
- **Intervalo recomendado:** 5 minutos entre consultas
- **Resposta quando excede:** HTTP 429 Too Many Requests

## Opcoes de Implementacao

### Opcao 1: slowapi (Recomendada)

```python
# Instalacao
# pip install slowapi

# apps/api_interrupcoes/rate_limiter.py
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded
from fastapi import FastAPI, Request

limiter = Limiter(key_func=get_remote_address)


def setup_rate_limiter(app: FastAPI) -> None:
    """Configura rate limiter na aplicacao."""
    app.state.limiter = limiter
    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
```

```python
# apps/api_interrupcoes/routes.py
from fastapi import APIRouter, Depends, Request
from slowapi import Limiter

from .rate_limiter import limiter
from .dependencies import verify_api_key, get_use_case
from .schemas import InterrupcoesAtivasResponse

router = APIRouter()


@router.get(
    "/quantitativointerrupcoesativas",
    response_model=InterrupcoesAtivasResponse,
)
@limiter.limit("10/minute")
async def get_interrupcoes_ativas(
    request: Request,  # Necessario para slowapi
    api_key: str = Depends(verify_api_key),
    use_case = Depends(get_use_case),
) -> InterrupcoesAtivasResponse:
    """Endpoint com rate limiting de 12 req/min."""
    result = await use_case.execute()
    return InterrupcoesAtivasResponse.from_result(result)
```

### Opcao 2: Middleware Customizado

```python
# apps/api_interrupcoes/middleware.py
import time
from collections import defaultdict
from fastapi import Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse


class RateLimitMiddleware(BaseHTTPMiddleware):
    """Middleware para rate limiting."""

    def __init__(self, app, requests_per_minute: int = 10):
        super().__init__(app)
        self.requests_per_minute = requests_per_minute
        self.requests: dict[str, list[float]] = defaultdict(list)

    async def dispatch(self, request: Request, call_next):
        # Ignora health check
        if request.url.path == "/health":
            return await call_next(request)

        # Identifica cliente por IP ou API Key
        client_id = self._get_client_id(request)

        # Verifica limite
        if not self._check_rate_limit(client_id):
            return JSONResponse(
                status_code=429,
                content={
                    "idcStatusRequisicao": 2,
                    "emailIndisponibilidade": "radar@roraimaenergia.com.br",
                    "mensagem": "Rate limit excedido. Maximo 10 requisicoes por minuto.",
                    "interrupcaoFornecimento": [],
                },
                headers={"Retry-After": "60"},
            )

        return await call_next(request)

    def _get_client_id(self, request: Request) -> str:
        """Retorna identificador do cliente."""
        api_key = request.headers.get("x-api-key", "")
        client_ip = request.client.host if request.client else "unknown"
        return f"{client_ip}:{api_key}"

    def _check_rate_limit(self, client_id: str) -> bool:
        """Verifica se cliente esta dentro do limite."""
        now = time.time()
        minute_ago = now - 60

        # Remove requisicoes antigas
        self.requests[client_id] = [
            t for t in self.requests[client_id]
            if t > minute_ago
        ]

        # Verifica limite
        if len(self.requests[client_id]) >= self.requests_per_minute:
            return False

        # Registra nova requisicao
        self.requests[client_id].append(now)
        return True
```

### Configuracao no Main

```python
# apps/api_interrupcoes/main.py
from contextlib import asynccontextmanager
from fastapi import FastAPI

from .routes import router
from .middleware import RateLimitMiddleware, RequestLoggingMiddleware
from .rate_limiter import setup_rate_limiter


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    yield
    # Shutdown


def create_app() -> FastAPI:
    app = FastAPI(
        title="API Interrupcoes - RADAR",
        description="API de Quantitativo de Interrupcoes Ativas (ANEEL)",
        version="1.0.0",
        lifespan=lifespan,
    )

    # Rate Limiter (Opcao 1 - slowapi)
    setup_rate_limiter(app)

    # Middlewares
    app.add_middleware(RateLimitMiddleware, requests_per_minute=10)  # Opcao 2
    app.add_middleware(RequestLoggingMiddleware)

    # Routes
    app.include_router(router)

    return app
```

## Resposta HTTP 429

```json
{
  "idcStatusRequisicao": 2,
  "emailIndisponibilidade": "radar@roraimaenergia.com.br",
  "mensagem": "Rate limit excedido. Maximo 10 requisicoes por minuto.",
  "interrupcaoFornecimento": []
}
```

Headers adicionais:
- `Retry-After: 60` (segundos)
- `X-RateLimit-Limit: 12`
- `X-RateLimit-Remaining: 0`
- `X-RateLimit-Reset: 1702999999` (timestamp)

## Arquivo de Saida

- `backend/apps/api_interrupcoes/rate_limiter.py` (se usar slowapi)
- Ou atualizar `backend/apps/api_interrupcoes/middleware.py`

## Testes a Criar

```python
# tests/e2e/api/test_rate_limiting.py
import pytest
from httpx import AsyncClient
import asyncio


@pytest.mark.e2e
class TestRateLimiting:
    async def test_deve_permitir_10_requisicoes_por_minuto(
        self, client, api_key
    ):
        """10 requisicoes em 1 minuto devem ser permitidas."""
        for i in range(10):
            response = await client.get(
                "/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key}
            )
            assert response.status_code == 200, f"Falhou na requisicao {i+1}"

    async def test_deve_bloquear_11a_requisicao(
        self, client, api_key
    ):
        """11a requisicao deve ser bloqueada com 429."""
        # Faz 10 requisicoes
        for _ in range(10):
            await client.get(
                "/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key}
            )

        # 11a requisicao deve falhar
        response = await client.get(
            "/quantitativointerrupcoesativas",
            headers={"x-api-key": api_key}
        )
        assert response.status_code == 429

    async def test_resposta_429_deve_ter_formato_aneel(
        self, client, api_key
    ):
        """Resposta 429 deve seguir formato ANEEL."""
        # Excede limite
        for _ in range(11):
            response = await client.get(
                "/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key}
            )

        # Verifica formato
        data = response.json()
        assert data["idcStatusRequisicao"] == 2
        assert "rate limit" in data["mensagem"].lower()

    async def test_deve_ter_header_retry_after(
        self, client, api_key
    ):
        """Resposta 429 deve incluir Retry-After."""
        # Excede limite
        for _ in range(11):
            response = await client.get(
                "/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key}
            )

        assert "Retry-After" in response.headers

    async def test_health_check_nao_conta_para_rate_limit(
        self, client, api_key
    ):
        """Health check nao deve consumir quota."""
        # Faz muitos health checks
        for _ in range(20):
            await client.get("/health")

        # Ainda deve poder fazer requisicao normal
        response = await client.get(
            "/quantitativointerrupcoesativas",
            headers={"x-api-key": api_key}
        )
        assert response.status_code == 200
```

## Criterios de Aceite

- [ ] Rate limiting de 10 req/min implementado
- [ ] Resposta 429 no formato ANEEL
- [ ] Header Retry-After incluido
- [ ] Health check excluido do rate limit
- [ ] Identificacao por IP + API Key
- [ ] Testes de rate limiting passando

## Comandos de Execucao

```bash
# Testar rate limiting manualmente
for i in {1..15}; do
  curl -s -o /dev/null -w "%{http_code}\n" \
    -H "x-api-key: test" \
    http://localhost:8001/quantitativointerrupcoesativas
done
```

## Agentes Recomendados

- `@backend-architect` - Para implementar middleware
- `@security-auditor` - Para validar seguranca
