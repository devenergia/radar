# RAD-105: Domain Service InterrupcaoAggregator

**Fase:** 2 - Application Layer
**Tipo:** Domain Service
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-100, RAD-101, RAD-102

## Objetivo

Implementar servico de dominio para agregacao de interrupcoes por municipio e conjunto eletrico.

## Localizacao

`backend/shared/domain/services/interrupcao_aggregator.py`

## Especificacao

### Regra de Negocio ANEEL

Os dados de interrupcao devem ser agregados por:
1. **Municipio (Codigo IBGE)** - Agrupamento geografico
2. **Conjunto Eletrico** - Agrupamento tecnico
3. **Tipo de Interrupcao** - Separacao PROGRAMADA vs NAO_PROGRAMADA

O resultado deve totalizar as UCs afetadas em cada combinacao.

### Diagrama de Agregacao

```
Interrupcoes Individuais          Resultado Agregado
┌─────────────────────────┐       ┌─────────────────────────┐
│ INT-1: BV, Conj-1, PROG │       │                         │
│ UCs: 50                 │       │ Municipio: 1400100 (BV) │
├─────────────────────────┤       │ Conjunto: 1             │
│ INT-2: BV, Conj-1, PROG │  ───► │ Programada: 80 UCs      │
│ UCs: 30                 │       │ Nao Programada: 20 UCs  │
├─────────────────────────┤       │                         │
│ INT-3: BV, Conj-1, N-PR │       └─────────────────────────┘
│ UCs: 20                 │
└─────────────────────────┘
```

## Implementacao

```python
# shared/domain/services/interrupcao_aggregator.py
from collections import defaultdict
from dataclasses import dataclass
from ..entities.interrupcao import Interrupcao
from ..value_objects.codigo_ibge import CodigoIBGE


@dataclass(frozen=True)
class InterrupcaoAgregada:
    """Aggregate que representa interrupcoes agregadas por municipio/conjunto."""

    id_conjunto: int
    municipio: CodigoIBGE
    qtd_ucs_atendidas: int
    qtd_programada: int
    qtd_nao_programada: int

    @property
    def total_interrupcoes(self) -> int:
        """Total de UCs com interrupcao."""
        return self.qtd_programada + self.qtd_nao_programada

    def has_interrupcoes(self) -> bool:
        """Verifica se ha interrupcoes neste agregado."""
        return self.total_interrupcoes > 0


class InterrupcaoAggregatorService:
    """
    Servico de dominio para agregacao de interrupcoes.

    Agrega interrupcoes por Municipio + Conjunto + Tipo,
    totalizando as UCs afetadas em cada categoria.
    """

    def agregar(
        self,
        interrupcoes: list[Interrupcao],
        universo: dict[tuple[int, str], int] | None = None,
    ) -> list[InterrupcaoAgregada]:
        """
        Agrega interrupcoes por municipio e conjunto.

        Args:
            interrupcoes: Lista de interrupcoes individuais
            universo: Mapa (conjunto, ibge) -> qtd_ucs_atendidas

        Returns:
            Lista de interrupcoes agregadas
        """
        if not interrupcoes:
            return []

        # Estrutura: {(conjunto, ibge): {prog: int, nao_prog: int}}
        agrupadas: dict[tuple[int, str], dict[str, int]] = defaultdict(
            lambda: {"programada": 0, "nao_programada": 0}
        )

        for interrupcao in interrupcoes:
            chave = (interrupcao.conjunto, interrupcao.municipio.valor)

            if interrupcao.is_programada():
                agrupadas[chave]["programada"] += interrupcao.ucs_afetadas
            else:
                agrupadas[chave]["nao_programada"] += interrupcao.ucs_afetadas

        universo = universo or {}

        return [
            InterrupcaoAgregada(
                id_conjunto=conjunto,
                municipio=CodigoIBGE.create(ibge).value,
                qtd_ucs_atendidas=universo.get((conjunto, ibge), 0),
                qtd_programada=dados["programada"],
                qtd_nao_programada=dados["nao_programada"],
            )
            for (conjunto, ibge), dados in agrupadas.items()
        ]

    def agregar_por_municipio(
        self,
        interrupcoes: list[Interrupcao],
    ) -> dict[str, dict[str, int]]:
        """
        Agrega apenas por municipio (sem considerar conjunto).

        Util para relatorios resumidos.
        """
        resultado: dict[str, dict[str, int]] = defaultdict(
            lambda: {"programada": 0, "nao_programada": 0, "total_ucs": 0}
        )

        for interrupcao in interrupcoes:
            ibge = interrupcao.municipio.valor

            if interrupcao.is_programada():
                resultado[ibge]["programada"] += interrupcao.ucs_afetadas
            else:
                resultado[ibge]["nao_programada"] += interrupcao.ucs_afetadas

            resultado[ibge]["total_ucs"] += interrupcao.ucs_afetadas

        return dict(resultado)
```

## Exemplo de Uso

```python
# Criando interrupcoes
interrupcoes = [
    Interrupcao.create({
        "id": 1,
        "tipo": TipoInterrupcao.PROGRAMADA,
        "municipio": CodigoIBGE.create("1400100").value,
        "conjunto": 1,
        "ucs_afetadas": 50,
        "data_inicio": datetime.now(),
    }).value,
    Interrupcao.create({
        "id": 2,
        "tipo": TipoInterrupcao.PROGRAMADA,
        "municipio": CodigoIBGE.create("1400100").value,
        "conjunto": 1,
        "ucs_afetadas": 30,
        "data_inicio": datetime.now(),
    }).value,
    Interrupcao.create({
        "id": 3,
        "tipo": TipoInterrupcao.NAO_PROGRAMADA,
        "municipio": CodigoIBGE.create("1400100").value,
        "conjunto": 1,
        "ucs_afetadas": 20,
        "data_inicio": datetime.now(),
    }).value,
]

# Agregando
aggregator = InterrupcaoAggregatorService()
agregadas = aggregator.agregar(interrupcoes)

# Resultado
# [InterrupcaoAgregada(
#     id_conjunto=1,
#     municipio=CodigoIBGE("1400100"),
#     qtd_programada=80,
#     qtd_nao_programada=20
# )]
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/services/test_interrupcao_aggregator.py
import pytest
from datetime import datetime

from shared.domain.services.interrupcao_aggregator import (
    InterrupcaoAggregatorService,
    InterrupcaoAgregada,
)
from shared.domain.entities.interrupcao import Interrupcao
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestInterrupcaoAggregatorService:
    """Testes para servico de agregacao."""

    @pytest.fixture
    def service(self) -> InterrupcaoAggregatorService:
        return InterrupcaoAggregatorService()

    @pytest.fixture
    def boa_vista(self) -> CodigoIBGE:
        return CodigoIBGE.create("1400100").value

    @pytest.fixture
    def caracarai(self) -> CodigoIBGE:
        return CodigoIBGE.create("1400209").value

    def _criar_interrupcao(
        self,
        id: int,
        municipio: CodigoIBGE,
        conjunto: int,
        tipo: TipoInterrupcao,
        ucs: int,
    ) -> Interrupcao:
        """Helper para criar interrupcao."""
        return Interrupcao.create({
            "id": id,
            "tipo": tipo,
            "municipio": municipio,
            "conjunto": conjunto,
            "ucs_afetadas": ucs,
            "data_inicio": datetime.now(),
            "data_fim": None,
        }).value

    class TestAgregar:
        """Testes para metodo agregar()."""

        def test_deve_retornar_lista_vazia_para_entrada_vazia(self, service):
            """Lista vazia de entrada retorna lista vazia."""
            resultado = service.agregar([])

            assert resultado == []

        def test_deve_agregar_por_municipio_e_conjunto(
            self, service, boa_vista, _criar_interrupcao
        ):
            """Agrega interrupcoes do mesmo municipio/conjunto."""
            interrupcoes = [
                _criar_interrupcao(1, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 50),
                _criar_interrupcao(2, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 30),
            ]

            resultado = service.agregar(interrupcoes)

            assert len(resultado) == 1
            assert resultado[0].qtd_programada == 80

        def test_deve_separar_por_tipo_programada_e_nao_programada(
            self, service, boa_vista, _criar_interrupcao
        ):
            """Separa contagem por tipo de interrupcao."""
            interrupcoes = [
                _criar_interrupcao(1, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 50),
                _criar_interrupcao(2, boa_vista, 1, TipoInterrupcao.NAO_PROGRAMADA, 30),
            ]

            resultado = service.agregar(interrupcoes)

            assert len(resultado) == 1
            assert resultado[0].qtd_programada == 50
            assert resultado[0].qtd_nao_programada == 30

        def test_deve_separar_por_conjunto_diferente(
            self, service, boa_vista, _criar_interrupcao
        ):
            """Conjuntos diferentes geram agregados separados."""
            interrupcoes = [
                _criar_interrupcao(1, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 50),
                _criar_interrupcao(2, boa_vista, 2, TipoInterrupcao.PROGRAMADA, 30),
            ]

            resultado = service.agregar(interrupcoes)

            assert len(resultado) == 2

        def test_deve_separar_por_municipio_diferente(
            self, service, boa_vista, caracarai, _criar_interrupcao
        ):
            """Municipios diferentes geram agregados separados."""
            interrupcoes = [
                _criar_interrupcao(1, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 50),
                _criar_interrupcao(2, caracarai, 1, TipoInterrupcao.PROGRAMADA, 30),
            ]

            resultado = service.agregar(interrupcoes)

            assert len(resultado) == 2

        def test_deve_incluir_dados_de_universo_quando_fornecido(
            self, service, boa_vista, _criar_interrupcao
        ):
            """Inclui qtd_ucs_atendidas do universo."""
            interrupcoes = [
                _criar_interrupcao(1, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 50),
            ]
            universo = {(1, "1400100"): 10000}

            resultado = service.agregar(interrupcoes, universo)

            assert resultado[0].qtd_ucs_atendidas == 10000

        def test_deve_usar_zero_quando_universo_nao_tem_dados(
            self, service, boa_vista, _criar_interrupcao
        ):
            """Usa 0 quando universo nao tem dados para combinacao."""
            interrupcoes = [
                _criar_interrupcao(1, boa_vista, 1, TipoInterrupcao.PROGRAMADA, 50),
            ]
            universo = {}  # Vazio

            resultado = service.agregar(interrupcoes, universo)

            assert resultado[0].qtd_ucs_atendidas == 0


class TestInterrupcaoAgregada:
    """Testes para dataclass InterrupcaoAgregada."""

    def test_deve_ser_frozen(self):
        """Agregado deve ser imutavel."""
        agregado = InterrupcaoAgregada(
            id_conjunto=1,
            municipio=CodigoIBGE.create("1400100").value,
            qtd_ucs_atendidas=10000,
            qtd_programada=100,
            qtd_nao_programada=50,
        )

        with pytest.raises(AttributeError):
            agregado.qtd_programada = 999

    def test_total_interrupcoes(self):
        """total_interrupcoes soma programada + nao programada."""
        agregado = InterrupcaoAgregada(
            id_conjunto=1,
            municipio=CodigoIBGE.create("1400100").value,
            qtd_ucs_atendidas=10000,
            qtd_programada=100,
            qtd_nao_programada=50,
        )

        assert agregado.total_interrupcoes == 150

    def test_has_interrupcoes_true(self):
        """has_interrupcoes retorna True quando ha interrupcoes."""
        agregado = InterrupcaoAgregada(
            id_conjunto=1,
            municipio=CodigoIBGE.create("1400100").value,
            qtd_ucs_atendidas=10000,
            qtd_programada=100,
            qtd_nao_programada=0,
        )

        assert agregado.has_interrupcoes() is True

    def test_has_interrupcoes_false(self):
        """has_interrupcoes retorna False quando nao ha interrupcoes."""
        agregado = InterrupcaoAgregada(
            id_conjunto=1,
            municipio=CodigoIBGE.create("1400100").value,
            qtd_ucs_atendidas=10000,
            qtd_programada=0,
            qtd_nao_programada=0,
        )

        assert agregado.has_interrupcoes() is False
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Agrega por municipio + conjunto
- [ ] Separa programada vs nao programada
- [ ] Totaliza UCs afetadas corretamente
- [ ] Retorna lista vazia para entrada vazia
- [ ] InterrupcaoAgregada e frozen dataclass
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/services/test_interrupcao_aggregator.py -v

# Com cobertura
pytest tests/unit/domain/services/test_interrupcao_aggregator.py --cov=shared/domain/services/interrupcao_aggregator --cov-report=term-missing
```
