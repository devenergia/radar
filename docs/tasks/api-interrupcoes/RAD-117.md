# RAD-117: Testes Unit - Value Objects

**Fase:** 5 - Testes TDD
**Tipo:** Test
**Prioridade:** Critica
**Status:** Pendente
**Dependencias:** RAD-100, RAD-101

## Objetivo

Criar testes unitarios para Value Objects CodigoIBGE e TipoInterrupcao.

## IMPORTANTE: Padroes do Projeto

- Testes ANTES do codigo (TDD)
- Cobertura >= 80%
- Markers: `@pytest.mark.unit`
- Pattern AAA (Arrange, Act, Assert)
- Nomes em portugues para testes de dominio

## Testes a Implementar

### TestCodigoIBGE

```python
# backend/tests/unit/domain/value_objects/test_codigo_ibge.py
import pytest
from shared.domain.value_objects.codigo_ibge import CodigoIBGE


class TestCodigoIBGE:
    """Testes para Value Object CodigoIBGE."""

    class TestCreate:
        """Testes do factory method create()."""

        @pytest.mark.unit
        def test_deve_criar_codigo_ibge_valido_para_boa_vista(self):
            """Codigo 1400100 (Boa Vista) deve ser valido."""
            # Arrange
            codigo_bv = "1400100"

            # Act
            result = CodigoIBGE.create(codigo_bv)

            # Assert
            assert result.is_success
            assert result.value.valor == "1400100"

        @pytest.mark.unit
        @pytest.mark.parametrize("codigo,nome", [
            ("1400050", "Alto Alegre"),
            ("1400027", "Amajari"),
            ("1400100", "Boa Vista"),
            ("1400159", "Bonfim"),
            ("1400175", "Canta"),
            ("1400209", "Caracarai"),
            ("1400233", "Caroebe"),
            ("1400282", "Iracema"),
            ("1400308", "Mucajai"),
            ("1400407", "Normandia"),
            ("1400456", "Pacaraima"),
            ("1400472", "Rorainopolis"),
            ("1400506", "Sao Joao da Baliza"),
            ("1400605", "Sao Luiz"),
            ("1400704", "Uiramuta"),
        ])
        def test_deve_aceitar_todos_municipios_roraima(self, codigo, nome):
            """Todos os 15 municipios de Roraima devem ser aceitos."""
            result = CodigoIBGE.create(codigo)
            assert result.is_success, f"Falhou para {nome} ({codigo})"

        @pytest.mark.unit
        def test_deve_adicionar_zeros_a_esquerda_se_necessario(self):
            """Codigo 1400100 passado como int deve funcionar."""
            # Arrange
            codigo_int = 1400100

            # Act
            result = CodigoIBGE.create(codigo_int)

            # Assert
            assert result.is_success
            assert result.value.valor == "1400100"

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_com_menos_de_7_digitos(self):
            """Codigo com menos de 7 digitos deve ser rejeitado."""
            # Arrange
            codigo_invalido = "140010"  # 6 digitos

            # Act
            result = CodigoIBGE.create(codigo_invalido)

            # Assert
            assert result.is_failure
            assert "invalido" in result.error.lower()

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_com_mais_de_7_digitos(self):
            """Codigo com mais de 7 digitos deve ser rejeitado."""
            # Arrange
            codigo_invalido = "14001001"  # 8 digitos

            # Act
            result = CodigoIBGE.create(codigo_invalido)

            # Assert
            assert result.is_failure

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_com_letras(self):
            """Codigo com letras deve ser rejeitado."""
            # Arrange
            codigo_invalido = "140010A"

            # Act
            result = CodigoIBGE.create(codigo_invalido)

            # Assert
            assert result.is_failure

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_de_outro_estado(self):
            """Codigo de outro estado deve ser rejeitado."""
            # Arrange
            codigo_sp = "3550308"  # Sao Paulo

            # Act
            result = CodigoIBGE.create(codigo_sp)

            # Assert
            assert result.is_failure
            assert "Roraima" in result.error

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_amazonas(self):
            """Codigo do Amazonas (13) deve ser rejeitado."""
            # Arrange
            codigo_am = "1300000"

            # Act
            result = CodigoIBGE.create(codigo_am)

            # Assert
            assert result.is_failure

    class TestEquals:
        """Testes de igualdade (Value Object)."""

        @pytest.mark.unit
        def test_deve_ser_igual_quando_valores_iguais(self):
            """Dois CodigoIBGE com mesmo valor devem ser iguais."""
            # Arrange
            ibge1 = CodigoIBGE.create("1400100").value
            ibge2 = CodigoIBGE.create("1400100").value

            # Assert
            assert ibge1 == ibge2

        @pytest.mark.unit
        def test_deve_ser_diferente_quando_valores_diferentes(self):
            """Dois CodigoIBGE com valores diferentes nao devem ser iguais."""
            # Arrange
            ibge1 = CodigoIBGE.create("1400100").value
            ibge2 = CodigoIBGE.create("1400050").value

            # Assert
            assert ibge1 != ibge2

        @pytest.mark.unit
        def test_deve_ter_mesmo_hash_quando_valores_iguais(self):
            """CodigoIBGE iguais devem ter mesmo hash (para uso em sets/dicts)."""
            # Arrange
            ibge1 = CodigoIBGE.create("1400100").value
            ibge2 = CodigoIBGE.create("1400100").value

            # Assert
            assert hash(ibge1) == hash(ibge2)

    class TestImutabilidade:
        """Testes de imutabilidade (frozen dataclass)."""

        @pytest.mark.unit
        def test_nao_deve_permitir_alteracao_de_valor(self):
            """Value Object deve ser imutavel."""
            # Arrange
            ibge = CodigoIBGE.create("1400100").value

            # Act & Assert
            with pytest.raises(AttributeError):
                ibge.valor = "1400050"
```

### TestTipoInterrupcao

```python
# backend/tests/unit/domain/value_objects/test_tipo_interrupcao.py
import pytest
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestTipoInterrupcao:
    """Testes para Value Object TipoInterrupcao."""

    class TestFromPlanId:
        """Testes do factory method from_plan_id()."""

        @pytest.mark.unit
        def test_deve_retornar_programada_quando_plan_id_existe(self):
            """Se PLAN_ID != None, interrupcao e programada."""
            # Arrange
            plan_id = 12345

            # Act
            tipo = TipoInterrupcao.from_plan_id(plan_id)

            # Assert
            assert tipo == TipoInterrupcao.PROGRAMADA

        @pytest.mark.unit
        def test_deve_retornar_nao_programada_quando_plan_id_none(self):
            """Se PLAN_ID == None, interrupcao e nao programada."""
            # Arrange
            plan_id = None

            # Act
            tipo = TipoInterrupcao.from_plan_id(plan_id)

            # Assert
            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

        @pytest.mark.unit
        def test_deve_retornar_programada_quando_plan_id_zero(self):
            """PLAN_ID = 0 ainda e um valor valido (programada)."""
            # Arrange
            plan_id = 0

            # Act
            tipo = TipoInterrupcao.from_plan_id(plan_id)

            # Assert
            assert tipo == TipoInterrupcao.PROGRAMADA

    class TestIsProgramada:
        """Testes do metodo is_programada()."""

        @pytest.mark.unit
        def test_programada_deve_retornar_true(self):
            """TipoInterrupcao.PROGRAMADA.is_programada() == True."""
            assert TipoInterrupcao.PROGRAMADA.is_programada() is True

        @pytest.mark.unit
        def test_nao_programada_deve_retornar_false(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_programada() == False."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_programada() is False

    class TestValores:
        """Testes dos valores do Enum."""

        @pytest.mark.unit
        def test_deve_ter_valor_programada(self):
            """Enum deve ter valor PROGRAMADA."""
            assert TipoInterrupcao.PROGRAMADA.value == "PROGRAMADA"

        @pytest.mark.unit
        def test_deve_ter_valor_nao_programada(self):
            """Enum deve ter valor NAO_PROGRAMADA."""
            assert TipoInterrupcao.NAO_PROGRAMADA.value == "NAO_PROGRAMADA"

        @pytest.mark.unit
        def test_deve_ter_apenas_dois_valores(self):
            """Enum deve ter exatamente 2 valores."""
            assert len(TipoInterrupcao) == 2
```

## Arquivo de Saida

- `backend/tests/unit/domain/value_objects/test_codigo_ibge.py`
- `backend/tests/unit/domain/value_objects/test_tipo_interrupcao.py`

## Criterios de Aceite

- [ ] Testes para CodigoIBGE implementados
- [ ] Testes para TipoInterrupcao implementados
- [ ] Testes com marker @pytest.mark.unit
- [ ] Pattern AAA (Arrange, Act, Assert)
- [ ] Cobertura >= 90% para Value Objects
- [ ] Todos os testes passando

## Comandos de Execucao

```bash
# Executar testes de Value Objects
pytest backend/tests/unit/domain/value_objects/ -v

# Com cobertura
pytest backend/tests/unit/domain/value_objects/ --cov=shared.domain.value_objects --cov-report=term-missing
```

## Agentes Recomendados

- `@test-engineer` - Para implementar os testes
- `@ddd-expert` - Para validar regras de dominio
