# RAD-117: Testes Unit - Value Objects

**Fase:** 5 - Testes TDD
**Tipo:** Test
**Prioridade:** Critica
**Status:** Pendente
**Dependencias:** RAD-100, RAD-101

## Objetivo

Criar testes unitarios para Value Objects CodigoIBGE e TipoInterrupcao.

## IMPORTANTE: Padroes do Projeto

- Testes ANTES do codigo (TDD) - **NOTA:** Value Objects ja existem, testes cobrem comportamento atual
- Cobertura >= 80%
- Markers: `@pytest.mark.unit`
- Pattern AAA (Arrange, Act, Assert)
- Nomes em portugues para testes de dominio

## Conformidade ANEEL

> **IMPORTANTE:** O campo `ideMunicipio` deve ser **inteiro** de 7 digitos conforme
> Oficio Circular 14/2025-SFE/ANEEL. O codigo reflete esta especificacao usando
> `valor: int` ao inves de `str`.

## Testes a Implementar

### TestCodigoIBGE

```python
# backend/tests/unit/domain/value_objects/test_codigo_ibge.py
import pytest
from backend.shared.domain.value_objects.codigo_ibge import CodigoIBGE


class TestCodigoIBGE:
    """Testes para Value Object CodigoIBGE."""

    class TestCreate:
        """Testes do factory method create(int)."""

        @pytest.mark.unit
        def test_deve_criar_codigo_ibge_valido_para_boa_vista(self):
            """Codigo 1400100 (Boa Vista) deve ser valido."""
            # Arrange
            codigo_bv = 1400100

            # Act
            result = CodigoIBGE.create(codigo_bv)

            # Assert
            assert result.is_success
            assert result.value.valor == 1400100

        @pytest.mark.unit
        @pytest.mark.parametrize("codigo,nome", [
            (1400050, "Alto Alegre"),
            (1400027, "Amajari"),
            (1400100, "Boa Vista"),
            (1400159, "Bonfim"),
            (1400175, "Canta"),
            (1400209, "Caracarai"),
            (1400233, "Caroebe"),
            (1400282, "Iracema"),
            (1400308, "Mucajai"),
            (1400407, "Normandia"),
            (1400456, "Pacaraima"),
            (1400472, "Rorainopolis"),
            (1400506, "Sao Joao da Baliza"),
            (1400605, "Sao Luiz"),
            (1400704, "Uiramuta"),
        ])
        def test_deve_aceitar_todos_municipios_roraima(self, codigo, nome):
            """Todos os 15 municipios de Roraima devem ser aceitos."""
            result = CodigoIBGE.create(codigo)
            assert result.is_success, f"Falhou para {nome} ({codigo})"

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_com_menos_de_7_digitos(self):
            """Codigo com menos de 7 digitos deve ser rejeitado (< 1000000)."""
            # Arrange
            codigo_invalido = 140010  # 6 digitos

            # Act
            result = CodigoIBGE.create(codigo_invalido)

            # Assert
            assert result.is_failure
            assert "invalido" in result.error.lower()

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_com_mais_de_7_digitos(self):
            """Codigo com mais de 7 digitos deve ser rejeitado (> 9999999)."""
            # Arrange
            codigo_invalido = 14001001  # 8 digitos

            # Act
            result = CodigoIBGE.create(codigo_invalido)

            # Assert
            assert result.is_failure

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_de_outro_estado(self):
            """Codigo de outro estado deve ser rejeitado."""
            # Arrange
            codigo_sp = 3550308  # Sao Paulo

            # Act
            result = CodigoIBGE.create(codigo_sp)

            # Assert
            assert result.is_failure
            assert "Roraima" in result.error

        @pytest.mark.unit
        def test_deve_rejeitar_codigo_amazonas(self):
            """Codigo do Amazonas (13) deve ser rejeitado."""
            # Arrange
            codigo_am = 1300000

            # Act
            result = CodigoIBGE.create(codigo_am)

            # Assert
            assert result.is_failure
            assert "Roraima" in result.error

    class TestCreateUnsafe:
        """Testes do factory method create_unsafe(int)."""

        @pytest.mark.unit
        def test_deve_criar_codigo_sem_validacao(self):
            """create_unsafe() cria sem validar (para dados vindos do banco)."""
            # Act
            ibge = CodigoIBGE.create_unsafe(1400100)

            # Assert
            assert ibge.valor == 1400100

    class TestGetAllRoraimaCodes:
        """Testes do metodo get_all_roraima_codes()."""

        @pytest.mark.unit
        def test_deve_retornar_15_municipios(self):
            """Roraima tem exatamente 15 municipios."""
            codes = CodigoIBGE.get_all_roraima_codes()

            assert len(codes) == 15

        @pytest.mark.unit
        def test_deve_retornar_tupla_de_inteiros(self):
            """Retorna tuple[int, ...] (imutavel e tipado)."""
            codes = CodigoIBGE.get_all_roraima_codes()

            assert isinstance(codes, tuple)
            assert all(isinstance(c, int) for c in codes)

    class TestEquals:
        """Testes de igualdade (Value Object)."""

        @pytest.mark.unit
        def test_deve_ser_igual_quando_valores_iguais(self):
            """Dois CodigoIBGE com mesmo valor devem ser iguais."""
            # Arrange
            ibge1 = CodigoIBGE.create(1400100).value
            ibge2 = CodigoIBGE.create(1400100).value

            # Assert
            assert ibge1 == ibge2

        @pytest.mark.unit
        def test_deve_ser_diferente_quando_valores_diferentes(self):
            """Dois CodigoIBGE com valores diferentes nao devem ser iguais."""
            # Arrange
            ibge1 = CodigoIBGE.create(1400100).value
            ibge2 = CodigoIBGE.create(1400050).value

            # Assert
            assert ibge1 != ibge2

        @pytest.mark.unit
        def test_deve_ter_mesmo_hash_quando_valores_iguais(self):
            """CodigoIBGE iguais devem ter mesmo hash (para uso em sets/dicts)."""
            # Arrange
            ibge1 = CodigoIBGE.create(1400100).value
            ibge2 = CodigoIBGE.create(1400100).value

            # Assert
            assert hash(ibge1) == hash(ibge2)

    class TestImutabilidade:
        """Testes de imutabilidade (frozen dataclass)."""

        @pytest.mark.unit
        def test_nao_deve_permitir_alteracao_de_valor(self):
            """Value Object deve ser imutavel."""
            # Arrange
            ibge = CodigoIBGE.create(1400100).value

            # Act & Assert
            with pytest.raises(AttributeError):
                ibge.valor = 1400050

    class TestStringRepresentation:
        """Testes de representacao string/int."""

        @pytest.mark.unit
        def test_str_retorna_valor_como_string(self):
            """__str__ retorna o valor como string."""
            ibge = CodigoIBGE.create(1400100).value

            assert str(ibge) == "1400100"

        @pytest.mark.unit
        def test_int_retorna_valor_como_inteiro(self):
            """__int__ retorna o valor como int."""
            ibge = CodigoIBGE.create(1400100).value

            assert int(ibge) == 1400100
```

### TestTipoInterrupcao

```python
# backend/tests/unit/domain/value_objects/test_tipo_interrupcao.py
import pytest
from backend.shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestTipoInterrupcao:
    """Testes para Value Object TipoInterrupcao."""

    class TestFromPlanId:
        """Testes do factory method from_plan_id()."""

        @pytest.mark.unit
        def test_deve_retornar_programada_quando_plan_id_existe(self):
            """Se PLAN_ID != None, interrupcao e programada."""
            # Arrange
            plan_id = 12345

            # Act
            tipo = TipoInterrupcao.from_plan_id(plan_id)

            # Assert
            assert tipo == TipoInterrupcao.PROGRAMADA

        @pytest.mark.unit
        def test_deve_retornar_nao_programada_quando_plan_id_none(self):
            """Se PLAN_ID == None, interrupcao e nao programada."""
            # Arrange
            plan_id = None

            # Act
            tipo = TipoInterrupcao.from_plan_id(plan_id)

            # Assert
            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

        @pytest.mark.unit
        def test_deve_retornar_programada_quando_plan_id_zero(self):
            """PLAN_ID = 0 ainda e um valor valido (programada)."""
            # Arrange
            plan_id = 0

            # Act
            tipo = TipoInterrupcao.from_plan_id(plan_id)

            # Assert
            assert tipo == TipoInterrupcao.PROGRAMADA

    class TestFromCodigo:
        """Testes do factory method from_codigo()."""

        @pytest.mark.unit
        def test_codigo_1_retorna_programada(self):
            """Codigo 1 = PROGRAMADA (padrao ANEEL)."""
            tipo = TipoInterrupcao.from_codigo(1)

            assert tipo == TipoInterrupcao.PROGRAMADA

        @pytest.mark.unit
        def test_codigo_2_retorna_nao_programada(self):
            """Codigo 2 = NAO_PROGRAMADA (padrao ANEEL)."""
            tipo = TipoInterrupcao.from_codigo(2)

            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

        @pytest.mark.unit
        def test_codigo_invalido_lanca_value_error(self):
            """Codigos diferentes de 1 ou 2 lancam erro."""
            with pytest.raises(ValueError) as exc_info:
                TipoInterrupcao.from_codigo(3)

            assert "invalido" in str(exc_info.value).lower()

    class TestCodigo:
        """Testes da property codigo."""

        @pytest.mark.unit
        def test_programada_retorna_1(self):
            """PROGRAMADA.codigo == 1."""
            assert TipoInterrupcao.PROGRAMADA.codigo == 1

        @pytest.mark.unit
        def test_nao_programada_retorna_2(self):
            """NAO_PROGRAMADA.codigo == 2."""
            assert TipoInterrupcao.NAO_PROGRAMADA.codigo == 2

    class TestIsProgramada:
        """Testes do metodo is_programada()."""

        @pytest.mark.unit
        def test_programada_deve_retornar_true(self):
            """TipoInterrupcao.PROGRAMADA.is_programada() == True."""
            assert TipoInterrupcao.PROGRAMADA.is_programada() is True

        @pytest.mark.unit
        def test_nao_programada_deve_retornar_false(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_programada() == False."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_programada() is False

    class TestIsNaoProgramada:
        """Testes do metodo is_nao_programada()."""

        @pytest.mark.unit
        def test_nao_programada_deve_retornar_true(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_nao_programada() == True."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_nao_programada() is True

        @pytest.mark.unit
        def test_programada_deve_retornar_false(self):
            """TipoInterrupcao.PROGRAMADA.is_nao_programada() == False."""
            assert TipoInterrupcao.PROGRAMADA.is_nao_programada() is False

    class TestEnumValues:
        """Testes dos valores do Enum."""

        @pytest.mark.unit
        def test_deve_ter_valor_programada(self):
            """Enum deve ter valor PROGRAMADA."""
            assert TipoInterrupcao.PROGRAMADA.value == "PROGRAMADA"

        @pytest.mark.unit
        def test_deve_ter_valor_nao_programada(self):
            """Enum deve ter valor NAO_PROGRAMADA."""
            assert TipoInterrupcao.NAO_PROGRAMADA.value == "NAO_PROGRAMADA"

        @pytest.mark.unit
        def test_deve_ter_apenas_dois_valores(self):
            """Enum deve ter exatamente 2 valores."""
            assert len(TipoInterrupcao) == 2

    class TestStrEnum:
        """Testes de heranca de str (para serializacao JSON)."""

        @pytest.mark.unit
        def test_enum_herda_de_str(self):
            """TipoInterrupcao deve ser instancia de str."""
            assert isinstance(TipoInterrupcao.PROGRAMADA, str)

        @pytest.mark.unit
        def test_pode_comparar_com_string(self):
            """Enum pode ser comparado diretamente com string."""
            assert TipoInterrupcao.PROGRAMADA == "PROGRAMADA"
            assert TipoInterrupcao.NAO_PROGRAMADA == "NAO_PROGRAMADA"
```

## Arquivo de Saida

- `backend/tests/unit/domain/value_objects/test_codigo_ibge.py`
- `backend/tests/unit/domain/value_objects/test_tipo_interrupcao.py`

## Criterios de Aceite

- [ ] Testes para CodigoIBGE implementados:
  - [ ] `create(int)` com codigos validos e invalidos
  - [ ] `create_unsafe(int)` sem validacao
  - [ ] `get_all_roraima_codes()` retorna 15 municipios
  - [ ] Igualdade e hash para uso em sets/dicts
  - [ ] Imutabilidade (frozen dataclass)
  - [ ] Representacao `__str__` e `__int__`
- [ ] Testes para TipoInterrupcao implementados:
  - [ ] `from_plan_id(int | None)` determina tipo
  - [ ] `from_codigo(int)` com 1, 2 e invalidos
  - [ ] Property `codigo` retorna 1 ou 2
  - [ ] Metodos `is_programada()` e `is_nao_programada()`
  - [ ] Heranca de `str` para serializacao JSON
- [ ] Testes com marker @pytest.mark.unit
- [ ] Pattern AAA (Arrange, Act, Assert)
- [ ] Cobertura >= 90% para Value Objects
- [ ] Todos os testes passando

## Comandos de Execucao

```bash
# Executar testes de Value Objects
pytest backend/tests/unit/domain/value_objects/ -v

# Com cobertura
pytest backend/tests/unit/domain/value_objects/ --cov=shared.domain.value_objects --cov-report=term-missing
```

## Agentes Recomendados

- `@test-engineer` - Para implementar os testes
- `@ddd-expert` - Para validar regras de dominio
