# RAD-118: Testes Unit - Entity

**Fase:** 5 - Testes
**Tipo:** Test
**Prioridade:** Critica
**Status:** Pendente
**Dependencias:** RAD-102

## Objetivo

Implementar testes unitarios para a entidade Interrupcao seguindo TDD.

## Localizacao

`backend/tests/unit/domain/entities/test_interrupcao.py`

## Especificacao

### Cenarios de Teste

1. **Criacao com dados validos**
2. **Validacao de UCs negativas**
3. **Validacao de data_fim < data_inicio**
4. **Metodo is_ativa()**
5. **Metodo is_programada()**
6. **Metodo is_nao_programada()**
7. **Metodo get_duracao_minutos()**
8. **Igualdade por ID**
9. **Hash por ID**

## Implementacao

```python
# tests/unit/domain/entities/test_interrupcao.py
import pytest
from datetime import datetime, timedelta

from shared.domain.entities.interrupcao import Interrupcao
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestInterrupcao:
    """Testes para entidade Interrupcao."""

    @pytest.fixture
    def municipio_boa_vista(self) -> CodigoIBGE:
        """Fixture para codigo IBGE de Boa Vista."""
        return CodigoIBGE.create("1400100").value

    @pytest.fixture
    def data_inicio(self) -> datetime:
        """Fixture para data de inicio."""
        return datetime(2025, 1, 15, 10, 0, 0)

    @pytest.fixture
    def props_validas(self, municipio_boa_vista, data_inicio) -> dict:
        """Fixture com propriedades validas para criar interrupcao."""
        return {
            "id": 12345,
            "tipo": TipoInterrupcao.PROGRAMADA,
            "municipio": municipio_boa_vista,
            "conjunto": 1,
            "ucs_afetadas": 150,
            "data_inicio": data_inicio,
            "data_fim": None,
        }

    class TestCreate:
        """Testes para factory method create()."""

        def test_deve_criar_interrupcao_com_dados_validos(
            self, props_validas
        ):
            """Criacao com dados validos retorna sucesso."""
            result = Interrupcao.create(props_validas)

            assert result.is_success
            assert result.value.id == 12345
            assert result.value.tipo == TipoInterrupcao.PROGRAMADA
            assert result.value.municipio.valor == "1400100"
            assert result.value.conjunto == 1
            assert result.value.ucs_afetadas == 150

        def test_deve_rejeitar_ucs_afetadas_negativas(
            self, props_validas
        ):
            """UCs afetadas negativas retorna erro."""
            props_validas["ucs_afetadas"] = -10

            result = Interrupcao.create(props_validas)

            assert result.is_failure
            assert "negativo" in result.error.lower()

        def test_deve_rejeitar_data_fim_anterior_a_data_inicio(
            self, props_validas, data_inicio
        ):
            """Data fim anterior a data inicio retorna erro."""
            props_validas["data_fim"] = data_inicio - timedelta(hours=1)

            result = Interrupcao.create(props_validas)

            assert result.is_failure
            assert "data" in result.error.lower()

        def test_deve_aceitar_data_fim_igual_a_data_inicio(
            self, props_validas, data_inicio
        ):
            """Data fim igual a data inicio e valido."""
            props_validas["data_fim"] = data_inicio

            result = Interrupcao.create(props_validas)

            assert result.is_success

        def test_deve_criar_interrupcao_sem_data_fim(
            self, props_validas
        ):
            """Interrupcao ativa pode nao ter data_fim."""
            props_validas["data_fim"] = None

            result = Interrupcao.create(props_validas)

            assert result.is_success
            assert result.value.data_fim is None

    class TestIsAtiva:
        """Testes para metodo is_ativa()."""

        def test_deve_retornar_true_quando_data_fim_e_none(
            self, props_validas
        ):
            """Interrupcao sem data_fim e ativa."""
            props_validas["data_fim"] = None
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_ativa() is True

        def test_deve_retornar_false_quando_data_fim_existe(
            self, props_validas, data_inicio
        ):
            """Interrupcao com data_fim nao e ativa."""
            props_validas["data_fim"] = data_inicio + timedelta(hours=2)
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_ativa() is False

    class TestIsProgramada:
        """Testes para metodo is_programada()."""

        def test_deve_retornar_true_para_tipo_programada(
            self, props_validas
        ):
            """Interrupcao PROGRAMADA retorna True."""
            props_validas["tipo"] = TipoInterrupcao.PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_programada() is True

        def test_deve_retornar_false_para_tipo_nao_programada(
            self, props_validas
        ):
            """Interrupcao NAO_PROGRAMADA retorna False."""
            props_validas["tipo"] = TipoInterrupcao.NAO_PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_programada() is False

    class TestIsNaoProgramada:
        """Testes para metodo is_nao_programada()."""

        def test_deve_retornar_true_para_tipo_nao_programada(
            self, props_validas
        ):
            """Interrupcao NAO_PROGRAMADA retorna True."""
            props_validas["tipo"] = TipoInterrupcao.NAO_PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_nao_programada() is True

        def test_deve_retornar_false_para_tipo_programada(
            self, props_validas
        ):
            """Interrupcao PROGRAMADA retorna False."""
            props_validas["tipo"] = TipoInterrupcao.PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_nao_programada() is False

    class TestGetDuracaoMinutos:
        """Testes para metodo get_duracao_minutos()."""

        def test_deve_retornar_none_para_interrupcao_ativa(
            self, props_validas
        ):
            """Interrupcao sem data_fim retorna None."""
            props_validas["data_fim"] = None
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.get_duracao_minutos() is None

        def test_deve_calcular_duracao_em_minutos(
            self, props_validas, data_inicio
        ):
            """Calcula corretamente duracao em minutos."""
            props_validas["data_fim"] = data_inicio + timedelta(hours=2, minutes=30)
            interrupcao = Interrupcao.create(props_validas).value

            duracao = interrupcao.get_duracao_minutos()

            assert duracao == 150  # 2h30 = 150 minutos

        def test_deve_retornar_zero_para_mesma_data(
            self, props_validas, data_inicio
        ):
            """Data inicio igual a data fim retorna 0."""
            props_validas["data_fim"] = data_inicio
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.get_duracao_minutos() == 0

    class TestEquality:
        """Testes para igualdade e hash."""

        def test_interrupcoes_com_mesmo_id_sao_iguais(
            self, props_validas
        ):
            """Igualdade baseada em ID."""
            int1 = Interrupcao.create(props_validas).value

            props_validas["ucs_afetadas"] = 999  # Valor diferente
            int2 = Interrupcao.create(props_validas).value

            assert int1 == int2

        def test_interrupcoes_com_ids_diferentes_sao_diferentes(
            self, props_validas
        ):
            """Interrupcoes com IDs diferentes nao sao iguais."""
            int1 = Interrupcao.create(props_validas).value

            props_validas["id"] = 99999
            int2 = Interrupcao.create(props_validas).value

            assert int1 != int2

        def test_hash_baseado_em_id(
            self, props_validas
        ):
            """Hash permite uso em sets e dicts."""
            int1 = Interrupcao.create(props_validas).value
            int2 = Interrupcao.create(props_validas).value

            # Mesmo ID = mesmo hash
            assert hash(int1) == hash(int2)

            # Pode ser usado em set
            s = {int1, int2}
            assert len(s) == 1

        def test_comparacao_com_outro_tipo_retorna_false(
            self, props_validas
        ):
            """Comparacao com tipo diferente retorna False."""
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao != "not an interrupcao"
            assert interrupcao != 12345
            assert interrupcao != None
```

## Comando de Execucao

```bash
# Executar testes da entidade
pytest tests/unit/domain/entities/test_interrupcao.py -v

# Com cobertura
pytest tests/unit/domain/entities/test_interrupcao.py --cov=shared/domain/entities

# Watch mode
pytest-watch tests/unit/domain/entities/
```

## Criterios de Aceite

- [ ] Teste de criacao com dados validos
- [ ] Teste de validacao de UCs negativas
- [ ] Teste de validacao de datas
- [ ] Testes de is_ativa()
- [ ] Testes de is_programada()
- [ ] Testes de is_nao_programada()
- [ ] Testes de get_duracao_minutos()
- [ ] Testes de igualdade e hash
- [ ] Cobertura >= 80%

## Agentes Recomendados

- `@test-engineer` - Para criar e validar testes
- `@ddd-expert` - Para validar comportamentos de dominio
