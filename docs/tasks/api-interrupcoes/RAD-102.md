# RAD-102: Entity Interrupcao

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** Existente
**Dependencias:** RAD-100, RAD-101

## Objetivo

Criar entidade Interrupcao com comportamentos de negocio.

## Localizacao

`backend/shared/domain/entities/interrupcao.py`

## Especificacao

### Atributos

| Atributo | Tipo | Descricao |
|----------|------|-----------|
| id | int | Identificador unico (num_1 do AGENCY_EVENT) |
| tipo | TipoInterrupcao | Tipo da interrupcao |
| municipio | CodigoIBGE | Codigo IBGE do municipio |
| conjunto | int | ID do conjunto eletrico |
| ucs_afetadas | int | Quantidade de UCs afetadas |
| data_inicio | datetime | Data/hora de inicio |
| data_fim | datetime | None | Data/hora de restabelecimento |

### Comportamentos

1. **is_ativa():** Retorna True se data_fim e None
2. **is_programada():** Retorna True se tipo e PROGRAMADA
3. **is_nao_programada():** Retorna True se tipo e NAO_PROGRAMADA
4. **get_duracao_minutos():** Calcula duracao da interrupcao

### Invariantes

1. ucs_afetadas >= 0
2. data_fim >= data_inicio (se data_fim existir)
3. municipio deve ser de Roraima (validado pelo VO)

## Implementacao

```python
# shared/domain/entities/interrupcao.py
from dataclasses import dataclass
from datetime import datetime
from ..value_objects.codigo_ibge import CodigoIBGE
from ..value_objects.tipo_interrupcao import TipoInterrupcao
from ..result import Result


@dataclass(frozen=True, slots=True)
class Interrupcao:
    """Entidade que representa uma interrupcao de fornecimento."""

    id: int
    tipo: TipoInterrupcao
    municipio: CodigoIBGE
    conjunto: int
    ucs_afetadas: int
    data_inicio: datetime
    data_fim: datetime | None = None

    @classmethod
    def create(cls, props: dict) -> "Result[Interrupcao]":
        """
        Factory method com validacao de invariantes.

        Args:
            props: Dicionario com propriedades da interrupcao

        Returns:
            Result com Interrupcao ou erro
        """
        # Validar UCs afetadas
        if props.get("ucs_afetadas", 0) < 0:
            return Result.fail("UCs afetadas nao pode ser negativo")

        # Validar datas
        data_inicio = props.get("data_inicio")
        data_fim = props.get("data_fim")

        if data_fim and data_inicio and data_fim < data_inicio:
            return Result.fail("Data fim nao pode ser anterior a data inicio")

        return Result.ok(cls(
            id=props["id"],
            tipo=props["tipo"],
            municipio=props["municipio"],
            conjunto=props["conjunto"],
            ucs_afetadas=props["ucs_afetadas"],
            data_inicio=props["data_inicio"],
            data_fim=props.get("data_fim"),
        ))

    def is_ativa(self) -> bool:
        """
        Interrupcao ativa quando nao tem data de fim.

        Returns:
            True se interrupcao esta ativa
        """
        return self.data_fim is None

    def is_programada(self) -> bool:
        """
        Interrupcao programada quando tem PLAN_ID associado.

        Returns:
            True se interrupcao e programada
        """
        return self.tipo == TipoInterrupcao.PROGRAMADA

    def is_nao_programada(self) -> bool:
        """
        Interrupcao nao programada quando nao tem PLAN_ID.

        Returns:
            True se interrupcao e nao programada
        """
        return self.tipo == TipoInterrupcao.NAO_PROGRAMADA

    def get_duracao_minutos(self) -> int | None:
        """
        Calcula duracao da interrupcao em minutos.

        Returns:
            Duracao em minutos ou None se ainda ativa
        """
        if self.data_fim is None:
            return None

        delta = self.data_fim - self.data_inicio
        return int(delta.total_seconds() / 60)

    def __eq__(self, other: object) -> bool:
        """Igualdade baseada em identidade (ID)."""
        if not isinstance(other, Interrupcao):
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        return hash(self.id)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/entities/test_interrupcao.py
import pytest
from datetime import datetime, timedelta

from shared.domain.entities.interrupcao import Interrupcao
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestInterrupcao:
    """Testes para entidade Interrupcao."""

    @pytest.fixture
    def municipio_boa_vista(self) -> CodigoIBGE:
        """Fixture para codigo IBGE de Boa Vista."""
        return CodigoIBGE.create("1400100").value

    @pytest.fixture
    def data_inicio(self) -> datetime:
        """Fixture para data de inicio."""
        return datetime(2025, 1, 15, 10, 0, 0)

    @pytest.fixture
    def props_validas(self, municipio_boa_vista, data_inicio) -> dict:
        """Fixture com propriedades validas."""
        return {
            "id": 12345,
            "tipo": TipoInterrupcao.PROGRAMADA,
            "municipio": municipio_boa_vista,
            "conjunto": 1,
            "ucs_afetadas": 150,
            "data_inicio": data_inicio,
            "data_fim": None,
        }

    class TestCreate:
        """Testes para factory method create()."""

        def test_deve_criar_interrupcao_com_dados_validos(self, props_validas):
            """Criacao com dados validos retorna sucesso."""
            result = Interrupcao.create(props_validas)

            assert result.is_success
            assert result.value.id == 12345
            assert result.value.tipo == TipoInterrupcao.PROGRAMADA
            assert result.value.ucs_afetadas == 150

        def test_deve_rejeitar_ucs_afetadas_negativas(self, props_validas):
            """UCs afetadas negativas retorna erro."""
            props_validas["ucs_afetadas"] = -10

            result = Interrupcao.create(props_validas)

            assert result.is_failure
            assert "negativo" in result.error.lower()

        def test_deve_aceitar_ucs_afetadas_zero(self, props_validas):
            """UCs afetadas pode ser zero."""
            props_validas["ucs_afetadas"] = 0

            result = Interrupcao.create(props_validas)

            assert result.is_success

        def test_deve_rejeitar_data_fim_anterior_a_data_inicio(
            self, props_validas, data_inicio
        ):
            """Data fim anterior a data inicio retorna erro."""
            props_validas["data_fim"] = data_inicio - timedelta(hours=1)

            result = Interrupcao.create(props_validas)

            assert result.is_failure
            assert "data" in result.error.lower()

        def test_deve_aceitar_data_fim_igual_a_data_inicio(
            self, props_validas, data_inicio
        ):
            """Data fim igual a data inicio e valido."""
            props_validas["data_fim"] = data_inicio

            result = Interrupcao.create(props_validas)

            assert result.is_success

        def test_deve_aceitar_interrupcao_sem_data_fim(self, props_validas):
            """Interrupcao ativa pode nao ter data_fim."""
            props_validas["data_fim"] = None

            result = Interrupcao.create(props_validas)

            assert result.is_success
            assert result.value.data_fim is None

    class TestIsAtiva:
        """Testes para metodo is_ativa()."""

        def test_deve_retornar_true_quando_data_fim_e_none(self, props_validas):
            """Interrupcao sem data_fim e ativa."""
            props_validas["data_fim"] = None
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_ativa() is True

        def test_deve_retornar_false_quando_data_fim_existe(
            self, props_validas, data_inicio
        ):
            """Interrupcao com data_fim nao e ativa."""
            props_validas["data_fim"] = data_inicio + timedelta(hours=2)
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_ativa() is False

    class TestIsProgramada:
        """Testes para metodo is_programada()."""

        def test_deve_retornar_true_para_tipo_programada(self, props_validas):
            """Interrupcao PROGRAMADA retorna True."""
            props_validas["tipo"] = TipoInterrupcao.PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_programada() is True

        def test_deve_retornar_false_para_tipo_nao_programada(self, props_validas):
            """Interrupcao NAO_PROGRAMADA retorna False."""
            props_validas["tipo"] = TipoInterrupcao.NAO_PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_programada() is False

    class TestIsNaoProgramada:
        """Testes para metodo is_nao_programada()."""

        def test_deve_retornar_true_para_tipo_nao_programada(self, props_validas):
            """Interrupcao NAO_PROGRAMADA retorna True."""
            props_validas["tipo"] = TipoInterrupcao.NAO_PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_nao_programada() is True

        def test_deve_retornar_false_para_tipo_programada(self, props_validas):
            """Interrupcao PROGRAMADA retorna False."""
            props_validas["tipo"] = TipoInterrupcao.PROGRAMADA
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.is_nao_programada() is False

    class TestGetDuracaoMinutos:
        """Testes para metodo get_duracao_minutos()."""

        def test_deve_retornar_none_para_interrupcao_ativa(self, props_validas):
            """Interrupcao sem data_fim retorna None."""
            props_validas["data_fim"] = None
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.get_duracao_minutos() is None

        def test_deve_calcular_duracao_em_minutos(self, props_validas, data_inicio):
            """Calcula corretamente duracao em minutos."""
            props_validas["data_fim"] = data_inicio + timedelta(hours=2, minutes=30)
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.get_duracao_minutos() == 150

        def test_deve_retornar_zero_para_mesma_data(self, props_validas, data_inicio):
            """Data inicio igual a data fim retorna 0."""
            props_validas["data_fim"] = data_inicio
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao.get_duracao_minutos() == 0

    class TestEquality:
        """Testes para igualdade e hash (baseados em ID)."""

        def test_interrupcoes_com_mesmo_id_sao_iguais(self, props_validas):
            """Igualdade baseada em ID."""
            int1 = Interrupcao.create(props_validas).value

            props_validas["ucs_afetadas"] = 999
            int2 = Interrupcao.create(props_validas).value

            assert int1 == int2

        def test_interrupcoes_com_ids_diferentes_sao_diferentes(self, props_validas):
            """Interrupcoes com IDs diferentes nao sao iguais."""
            int1 = Interrupcao.create(props_validas).value

            props_validas["id"] = 99999
            int2 = Interrupcao.create(props_validas).value

            assert int1 != int2

        def test_hash_baseado_em_id(self, props_validas):
            """Hash permite uso em sets e dicts."""
            int1 = Interrupcao.create(props_validas).value
            int2 = Interrupcao.create(props_validas).value

            s = {int1, int2}
            assert len(s) == 1

        def test_comparacao_com_outro_tipo_retorna_false(self, props_validas):
            """Comparacao com tipo diferente retorna False."""
            interrupcao = Interrupcao.create(props_validas).value

            assert interrupcao != "string"
            assert interrupcao != 12345
            assert interrupcao != None
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Dataclass frozen (imutavel)
- [ ] Usa Value Objects (CodigoIBGE, TipoInterrupcao)
- [ ] Factory method create() com validacao
- [ ] Metodos de comportamento (is_ativa, is_programada)
- [ ] Igualdade por ID
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/entities/test_interrupcao.py -v

# Com cobertura
pytest tests/unit/domain/entities/test_interrupcao.py --cov=shared/domain/entities/interrupcao --cov-report=term-missing
```
