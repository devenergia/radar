# RAD-102: Entity Interrupcao

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** Existente
**Dependencias:** RAD-100, RAD-101

## Objetivo

Criar entidade Interrupcao com comportamentos de negocio.

## Localizacao

`backend/shared/domain/entities/interrupcao.py`

## Especificacao

### Atributos

| Atributo | Tipo | Descricao |
|----------|------|-----------|
| id | int | Identificador unico (num_1 do AGENCY_EVENT) |
| tipo | TipoInterrupcao | Tipo da interrupcao |
| municipio | CodigoIBGE | Codigo IBGE do municipio (int) |
| conjunto | int | ID do conjunto eletrico |
| ucs_afetadas | int | Quantidade de UCs afetadas |
| data_inicio | datetime | Data/hora de inicio |
| data_fim | datetime \| None | Data/hora de restabelecimento |

### Comportamentos

1. **is_ativa():** Retorna True se data_fim e None
2. **is_programada():** Delega para tipo.is_programada()
3. **is_nao_programada():** Delega para tipo.is_nao_programada()
4. **get_duracao_minutos():** Calcula duracao da interrupcao
5. **to_dict():** Converte para dicionario (serializacao)

### Invariantes

1. ucs_afetadas >= 0
2. conjunto >= 0
3. data_fim >= data_inicio (se data_fim existir)
4. municipio deve ser de Roraima (validado pelo VO)

## Implementacao

```python
# shared/domain/entities/interrupcao.py
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime

from backend.shared.domain.result import Result
from backend.shared.domain.value_objects.codigo_ibge import CodigoIBGE
from backend.shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


@dataclass(frozen=True, slots=True)
class Interrupcao:
    """
    Entidade Interrupcao.

    Representa um evento de interrupcao no fornecimento de energia.
    Possui identidade unica (id) e encapsula regras de negocio.
    """

    id: int
    tipo: TipoInterrupcao
    municipio: CodigoIBGE
    conjunto: int
    ucs_afetadas: int
    data_inicio: datetime
    data_fim: datetime | None = None

    @classmethod
    def create(
        cls,
        id: int,
        tipo: TipoInterrupcao,
        municipio: CodigoIBGE,
        conjunto: int,
        ucs_afetadas: int,
        data_inicio: datetime,
        data_fim: datetime | None = None,
    ) -> Result[Interrupcao]:
        """
        Factory method com validacoes.

        Args:
            id: Identificador unico da interrupcao
            tipo: Tipo da interrupcao (PROGRAMADA ou NAO_PROGRAMADA)
            municipio: Codigo IBGE do municipio
            conjunto: Codigo do conjunto eletrico
            ucs_afetadas: Quantidade de unidades consumidoras afetadas
            data_inicio: Data/hora de inicio da interrupcao
            data_fim: Data/hora de fim da interrupcao (None se ainda ativa)

        Returns:
            Result com Interrupcao valida ou mensagem de erro
        """
        # Validar UCs afetadas
        if ucs_afetadas < 0:
            return Result.fail("Quantidade de UCs afetadas nao pode ser negativa")

        # Validar conjunto
        if conjunto < 0:
            return Result.fail("Codigo do conjunto nao pode ser negativo")

        # Validar datas
        if data_fim is not None and data_fim < data_inicio:
            return Result.fail("Data fim nao pode ser anterior a data inicio")

        return Result.ok(
            cls(
                id=id,
                tipo=tipo,
                municipio=municipio,
                conjunto=conjunto,
                ucs_afetadas=ucs_afetadas,
                data_inicio=data_inicio,
                data_fim=data_fim,
            )
        )

    def is_ativa(self) -> bool:
        """
        Uma interrupcao e ativa quando nao possui data de fim.

        Corresponde a is_open = 'T' na tabela AGENCY_EVENT.
        """
        return self.data_fim is None

    def is_programada(self) -> bool:
        """Verifica se a interrupcao e programada."""
        return self.tipo.is_programada()

    def is_nao_programada(self) -> bool:
        """Verifica se a interrupcao e nao programada."""
        return self.tipo.is_nao_programada()

    def get_duracao_minutos(self) -> int | None:
        """
        Calcula a duracao da interrupcao em minutos.

        Returns:
            Duracao em minutos ou None se ainda estiver ativa
        """
        if self.data_fim is None:
            return None

        diff = self.data_fim - self.data_inicio
        return int(diff.total_seconds() / 60)

    def to_dict(self) -> dict:
        """Converte para dicionario."""
        return {
            "id": self.id,
            "tipo": self.tipo.value,
            "municipio": self.municipio.valor,
            "conjunto": self.conjunto,
            "ucs_afetadas": self.ucs_afetadas,
            "data_inicio": self.data_inicio.isoformat(),
            "data_fim": self.data_fim.isoformat() if self.data_fim else None,
            "is_ativa": self.is_ativa(),
        }
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/entities/test_interrupcao.py
import pytest
from datetime import datetime, timedelta

from backend.shared.domain.entities.interrupcao import Interrupcao
from backend.shared.domain.value_objects.codigo_ibge import CodigoIBGE
from backend.shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestInterrupcao:
    """Testes para entidade Interrupcao."""

    @pytest.fixture
    def municipio_boa_vista(self) -> CodigoIBGE:
        """Fixture para codigo IBGE de Boa Vista."""
        return CodigoIBGE.create(1400100).value

    @pytest.fixture
    def data_inicio(self) -> datetime:
        """Fixture para data de inicio."""
        return datetime(2025, 1, 15, 10, 0, 0)

    class TestCreate:
        """Testes para factory method create()."""

        def test_deve_criar_interrupcao_com_dados_validos(
            self, municipio_boa_vista, data_inicio
        ):
            """Criacao com dados validos retorna sucesso."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            )

            assert result.is_success
            assert result.value.id == 12345
            assert result.value.tipo == TipoInterrupcao.PROGRAMADA
            assert result.value.ucs_afetadas == 150

        def test_deve_rejeitar_ucs_afetadas_negativas(
            self, municipio_boa_vista, data_inicio
        ):
            """UCs afetadas negativas retorna erro."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=-10,
                data_inicio=data_inicio,
            )

            assert result.is_failure
            assert "negativ" in result.error.lower()

        def test_deve_rejeitar_conjunto_negativo(
            self, municipio_boa_vista, data_inicio
        ):
            """Conjunto negativo retorna erro."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=-1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            )

            assert result.is_failure
            assert "conjunto" in result.error.lower()

        def test_deve_aceitar_ucs_afetadas_zero(
            self, municipio_boa_vista, data_inicio
        ):
            """UCs afetadas pode ser zero."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=0,
                data_inicio=data_inicio,
            )

            assert result.is_success

        def test_deve_rejeitar_data_fim_anterior_a_data_inicio(
            self, municipio_boa_vista, data_inicio
        ):
            """Data fim anterior a data inicio retorna erro."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
                data_fim=data_inicio - timedelta(hours=1),
            )

            assert result.is_failure
            assert "data" in result.error.lower()

        def test_deve_aceitar_data_fim_igual_a_data_inicio(
            self, municipio_boa_vista, data_inicio
        ):
            """Data fim igual a data inicio e valido."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
                data_fim=data_inicio,
            )

            assert result.is_success

        def test_deve_aceitar_interrupcao_sem_data_fim(
            self, municipio_boa_vista, data_inicio
        ):
            """Interrupcao ativa pode nao ter data_fim."""
            result = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            )

            assert result.is_success
            assert result.value.data_fim is None

    class TestIsAtiva:
        """Testes para metodo is_ativa()."""

        def test_deve_retornar_true_quando_data_fim_e_none(
            self, municipio_boa_vista, data_inicio
        ):
            """Interrupcao sem data_fim e ativa."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            ).value

            assert interrupcao.is_ativa() is True

        def test_deve_retornar_false_quando_data_fim_existe(
            self, municipio_boa_vista, data_inicio
        ):
            """Interrupcao com data_fim nao e ativa."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
                data_fim=data_inicio + timedelta(hours=2),
            ).value

            assert interrupcao.is_ativa() is False

    class TestIsProgramada:
        """Testes para metodo is_programada()."""

        def test_deve_retornar_true_para_tipo_programada(
            self, municipio_boa_vista, data_inicio
        ):
            """Interrupcao PROGRAMADA retorna True."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            ).value

            assert interrupcao.is_programada() is True

        def test_deve_retornar_false_para_tipo_nao_programada(
            self, municipio_boa_vista, data_inicio
        ):
            """Interrupcao NAO_PROGRAMADA retorna False."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.NAO_PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            ).value

            assert interrupcao.is_programada() is False

    class TestGetDuracaoMinutos:
        """Testes para metodo get_duracao_minutos()."""

        def test_deve_retornar_none_para_interrupcao_ativa(
            self, municipio_boa_vista, data_inicio
        ):
            """Interrupcao sem data_fim retorna None."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            ).value

            assert interrupcao.get_duracao_minutos() is None

        def test_deve_calcular_duracao_em_minutos(
            self, municipio_boa_vista, data_inicio
        ):
            """Calcula corretamente duracao em minutos."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
                data_fim=data_inicio + timedelta(hours=2, minutes=30),
            ).value

            assert interrupcao.get_duracao_minutos() == 150

    class TestToDict:
        """Testes para metodo to_dict()."""

        def test_deve_converter_para_dicionario(
            self, municipio_boa_vista, data_inicio
        ):
            """to_dict() retorna dicionario com todos os campos."""
            interrupcao = Interrupcao.create(
                id=12345,
                tipo=TipoInterrupcao.PROGRAMADA,
                municipio=municipio_boa_vista,
                conjunto=1,
                ucs_afetadas=150,
                data_inicio=data_inicio,
            ).value

            d = interrupcao.to_dict()

            assert d["id"] == 12345
            assert d["tipo"] == "PROGRAMADA"
            assert d["municipio"] == 1400100
            assert d["conjunto"] == 1
            assert d["ucs_afetadas"] == 150
            assert d["is_ativa"] is True
```

## Criterios de Aceite

- [x] Testes escritos e passando
- [x] Dataclass frozen + slots (imutavel e otimizado)
- [x] Usa Value Objects (CodigoIBGE com int, TipoInterrupcao)
- [x] Factory method `create()` com parametros individuais type-safe
- [x] Validacao de invariantes (ucs >= 0, conjunto >= 0, datas)
- [x] Metodos de comportamento (is_ativa, is_programada, is_nao_programada)
- [x] Metodo `to_dict()` para serializacao
- [x] Igualdade por ID (frozen dataclass)
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/entities/test_interrupcao.py -v

# Com cobertura
pytest tests/unit/domain/entities/test_interrupcao.py --cov=shared/domain/entities/interrupcao --cov-report=term-missing
```
