# RAD-106: Protocol CacheService

**Fase:** 2 - Application Layer
**Tipo:** Protocol (Interface)
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-103

## Objetivo

Definir Protocol para servico de cache, permitindo inversao de dependencia.

## Localizacao

`backend/shared/domain/cache/cache_service.py`

## Especificacao

### Motivacao

O cache e essencial para performance da API ANEEL:
1. Reduz carga no Oracle via DBLinks
2. Melhora tempo de resposta
3. Permite TTL configuravel (padrao: 5 minutos)

### Requisitos

- TTL padrao: 300 segundos (5 minutos)
- Chave padrao: `"interrupcoes:ativas"`
- Invalidacao manual disponivel
- Suporte a tipos genericos

## Implementacao

```python
# shared/domain/cache/cache_service.py
from typing import Protocol, TypeVar, Generic

T = TypeVar("T")


class CacheService(Protocol[T]):
    """
    Protocol para servico de cache.

    Define contrato que permite diferentes implementacoes
    (memoria, Redis, etc.) sem acoplar a camada de dominio.
    """

    async def get(self, key: str) -> T | None:
        """
        Recupera valor do cache.

        Args:
            key: Chave do cache

        Returns:
            Valor armazenado ou None se nao existir/expirado
        """
        ...

    async def set(self, key: str, value: T, ttl_seconds: int = 300) -> None:
        """
        Armazena valor no cache.

        Args:
            key: Chave do cache
            value: Valor a armazenar
            ttl_seconds: Tempo de vida em segundos (padrao: 300)
        """
        ...

    async def delete(self, key: str) -> None:
        """
        Remove valor do cache.

        Args:
            key: Chave a remover
        """
        ...

    async def exists(self, key: str) -> bool:
        """
        Verifica se chave existe no cache.

        Args:
            key: Chave a verificar

        Returns:
            True se existir e nao expirado
        """
        ...

    async def clear(self) -> None:
        """Remove todos os valores do cache."""
        ...


# Constantes de configuracao
class CacheKeys:
    """Chaves padrao do cache."""

    INTERRUPCOES_ATIVAS = "interrupcoes:ativas"
    UNIVERSO_MUNICIPIOS = "universo:municipios"
    UNIVERSO_CONJUNTOS = "universo:conjuntos"


class CacheTTL:
    """TTLs padrao em segundos."""

    INTERRUPCOES = 300  # 5 minutos
    UNIVERSO = 3600     # 1 hora
    CURTA = 60          # 1 minuto
```

## Diagrama de Dependencia

```
┌─────────────────────────────┐
│   GetInterrupcoesUseCase    │
│   (Application Layer)       │
└──────────────┬──────────────┘
               │ depends on
               ▼
┌─────────────────────────────┐
│      CacheService           │
│      <<Protocol>>           │
│   (Domain Layer)            │
└──────────────┬──────────────┘
               │ implements
               ▼
┌─────────────────────────────┐
│   MemoryCacheService        │
│   (Infrastructure Layer)    │
└─────────────────────────────┘
```

## Uso no Use Case

```python
# apps/api_interrupcoes/use_cases/get_interrupcoes_ativas.py
from shared.domain.cache.cache_service import CacheService, CacheKeys, CacheTTL


class GetInterrupcoesAtivasUseCase:
    def __init__(
        self,
        repository: InterrupcaoRepository,
        cache: CacheService,
        aggregator: InterrupcaoAggregatorService,
    ) -> None:
        self._repository = repository
        self._cache = cache
        self._aggregator = aggregator

    async def execute(self) -> Result[list[InterrupcaoAgregada]]:
        # Tentar cache primeiro
        cached = await self._cache.get(CacheKeys.INTERRUPCOES_ATIVAS)
        if cached is not None:
            return Result.ok(cached)

        # Buscar do repositorio
        interrupcoes = await self._repository.buscar_ativas()

        # Agregar
        agregadas = self._aggregator.agregar(interrupcoes)

        # Salvar no cache
        await self._cache.set(
            CacheKeys.INTERRUPCOES_ATIVAS,
            agregadas,
            CacheTTL.INTERRUPCOES,
        )

        return Result.ok(agregadas)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/cache/test_cache_service_protocol.py
import pytest
from typing import Protocol, runtime_checkable

from shared.domain.cache.cache_service import CacheService, CacheKeys, CacheTTL


class TestCacheServiceProtocol:
    """Testes para Protocol CacheService."""

    def test_deve_ser_um_protocol(self):
        """Verifica que CacheService e um Protocol."""
        assert hasattr(CacheService, '__protocol_attrs__') or issubclass(CacheService, Protocol)

    def test_protocol_tem_metodo_get(self):
        """Verifica metodo get."""
        assert hasattr(CacheService, 'get')

    def test_protocol_tem_metodo_set(self):
        """Verifica metodo set."""
        assert hasattr(CacheService, 'set')

    def test_protocol_tem_metodo_delete(self):
        """Verifica metodo delete."""
        assert hasattr(CacheService, 'delete')

    def test_protocol_tem_metodo_exists(self):
        """Verifica metodo exists."""
        assert hasattr(CacheService, 'exists')

    def test_protocol_tem_metodo_clear(self):
        """Verifica metodo clear."""
        assert hasattr(CacheService, 'clear')


class TestCacheKeys:
    """Testes para constantes de chaves de cache."""

    def test_deve_ter_chave_interrupcoes_ativas(self):
        """Chave para interrupcoes ativas definida."""
        assert CacheKeys.INTERRUPCOES_ATIVAS == "interrupcoes:ativas"

    def test_deve_ter_chave_universo_municipios(self):
        """Chave para universo municipios definida."""
        assert CacheKeys.UNIVERSO_MUNICIPIOS == "universo:municipios"

    def test_deve_ter_chave_universo_conjuntos(self):
        """Chave para universo conjuntos definida."""
        assert CacheKeys.UNIVERSO_CONJUNTOS == "universo:conjuntos"


class TestCacheTTL:
    """Testes para constantes de TTL."""

    def test_ttl_interrupcoes_deve_ser_300_segundos(self):
        """TTL de interrupcoes e 5 minutos."""
        assert CacheTTL.INTERRUPCOES == 300

    def test_ttl_universo_deve_ser_3600_segundos(self):
        """TTL de universo e 1 hora."""
        assert CacheTTL.UNIVERSO == 3600

    def test_ttl_curta_deve_ser_60_segundos(self):
        """TTL curta e 1 minuto."""
        assert CacheTTL.CURTA == 60


class TestImplementacaoCacheService:
    """Testes para verificar que implementacao satisfaz Protocol."""

    def test_memory_cache_deve_satisfazer_protocol(self):
        """MemoryCacheService implementa CacheService."""
        from shared.infrastructure.cache.memory_cache import MemoryCacheService

        cache = MemoryCacheService()

        assert hasattr(cache, 'get')
        assert hasattr(cache, 'set')
        assert hasattr(cache, 'delete')
        assert hasattr(cache, 'exists')
        assert hasattr(cache, 'clear')
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Protocol com metodos get, set, delete, exists, clear
- [ ] Suporte a tipos genericos
- [ ] Constantes CacheKeys definidas
- [ ] Constantes CacheTTL definidas
- [ ] Sem dependencia de implementacao concreta
- [ ] Documentacao dos metodos
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/cache/test_cache_service_protocol.py -v

# Com cobertura
pytest tests/unit/domain/cache/test_cache_service_protocol.py --cov=shared/domain/cache --cov-report=term-missing
```

## Testes Relacionados

- RAD-111: Implementacao MemoryCacheService
- RAD-119: Testes Unit - Use Case (com mock de cache)
