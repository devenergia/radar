# RAD-104: Protocol InterrupcaoRepository

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-102

## Objetivo

Criar Protocol (interface) para repositorio de interrupcoes, seguindo Dependency Inversion Principle (DIP).

## IMPORTANTE: Padroes do Projeto

- Use `Protocol` de `typing` (NAO ABC)
- Protocol deve estar no dominio (`shared/domain/repositories/`)
- Implementacao concreta fica na infraestrutura
- Metodos async para operacoes de I/O
- Retorna entidades de dominio (Interrupcao)

## Protocol a Implementar

```python
# shared/domain/repositories/interrupcao_repository.py
from typing import Protocol
from datetime import datetime
from ..entities.interrupcao import Interrupcao
from ..value_objects.codigo_ibge import CodigoIBGE


class InterrupcaoRepository(Protocol):
    """
    Port para repositorio de interrupcoes.

    Define contrato que deve ser implementado pela camada
    de infraestrutura. O dominio depende desta interface,
    nao de implementacoes concretas (DIP).
    """

    async def buscar_ativas(self) -> list[Interrupcao]:
        """
        Busca todas as interrupcoes ativas no momento.

        Uma interrupcao e considerada ativa quando:
        - is_open = 'T' no banco INSERVICE
        - data_fim e None na entidade

        Returns:
            Lista de interrupcoes ativas (pode ser vazia)
        """
        ...

    async def buscar_por_municipio(
        self,
        codigo_ibge: CodigoIBGE,
    ) -> list[Interrupcao]:
        """
        Busca interrupcoes ativas por municipio.

        Args:
            codigo_ibge: Codigo IBGE do municipio (7 digitos)

        Returns:
            Lista de interrupcoes ativas no municipio
        """
        ...

    async def buscar_por_conjunto(
        self,
        id_conjunto: int,
    ) -> list[Interrupcao]:
        """
        Busca interrupcoes ativas por conjunto eletrico.

        Args:
            id_conjunto: ID do conjunto eletrico

        Returns:
            Lista de interrupcoes ativas no conjunto
        """
        ...

    async def buscar_historico(
        self,
        data_inicio: datetime,
        data_fim: datetime,
    ) -> list[Interrupcao]:
        """
        Busca historico de interrupcoes em um periodo.

        Usado para o parametro dthRecuperacao da ANEEL.
        Dados devem estar disponiveis por 7 dias.

        Args:
            data_inicio: Inicio do periodo
            data_fim: Fim do periodo

        Returns:
            Lista de interrupcoes no periodo
        """
        ...
```

## Regras de Negocio

1. Protocol fica no DOMINIO (shared/domain/repositories/)
2. Metodos retornam entidades de dominio (Interrupcao)
3. NAO pode importar SQLAlchemy, oracledb ou outros frameworks
4. Metodos sao async (operacoes de I/O)
5. Docstrings descrevem regras de negocio

## Arquivo de Saida

`backend/shared/domain/repositories/interrupcao_repository.py`

## Testes a Criar (TDD)

### Testes de Tipagem

```python
# tests/unit/domain/repositories/test_interrupcao_repository_protocol.py
import pytest
from typing import runtime_checkable, Protocol
from shared.domain.repositories.interrupcao_repository import InterrupcaoRepository


class TestInterrupcaoRepositoryProtocol:
    def test_deve_ser_um_protocol(self):
        """Verifica que e um Protocol."""
        assert issubclass(InterrupcaoRepository, Protocol)

    def test_protocol_tem_metodo_buscar_ativas(self):
        """Verifica metodo buscar_ativas."""
        assert hasattr(InterrupcaoRepository, 'buscar_ativas')

    def test_protocol_tem_metodo_buscar_por_municipio(self):
        """Verifica metodo buscar_por_municipio."""
        assert hasattr(InterrupcaoRepository, 'buscar_por_municipio')

    def test_protocol_tem_metodo_buscar_historico(self):
        """Verifica metodo buscar_historico."""
        assert hasattr(InterrupcaoRepository, 'buscar_historico')


class TestImplementacaoProtocol:
    def test_implementacao_deve_satisfazer_protocol(self):
        """Verifica que implementacao satisfaz Protocol."""
        from apps.api_interrupcoes.repositories.oracle_interrupcao_repository import (
            OracleInterrupcaoRepository,
        )
        from sqlalchemy.ext.asyncio import AsyncSession
        from unittest.mock import MagicMock

        # Mock session
        mock_session = MagicMock(spec=AsyncSession)
        repo = OracleInterrupcaoRepository(mock_session)

        # Verifica que implementa os metodos
        assert hasattr(repo, 'buscar_ativas')
        assert hasattr(repo, 'buscar_por_municipio')
```

## Validacao de Arquitetura

```python
# Verificar que Protocol nao importa frameworks
import ast
from pathlib import Path

def test_protocol_nao_importa_frameworks():
    """Protocol nao deve importar SQLAlchemy, oracledb, etc."""
    file_path = Path("backend/shared/domain/repositories/interrupcao_repository.py")
    content = file_path.read_text()
    tree = ast.parse(content)

    forbidden = ["sqlalchemy", "oracledb", "fastapi", "pydantic"]

    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                assert alias.name.split(".")[0] not in forbidden
        if isinstance(node, ast.ImportFrom):
            if node.module:
                assert node.module.split(".")[0] not in forbidden
```

## Criterios de Aceite

- [ ] Protocol criado em shared/domain/repositories/
- [ ] Herda de typing.Protocol
- [ ] Metodos async definidos
- [ ] Retorna entidades de dominio
- [ ] Nenhum import de frameworks externos
- [ ] Docstrings com regras de negocio
- [ ] Testes de tipagem passando

## Agentes Recomendados

- `@ddd-expert` - Para modelagem do Protocol
- `@clean-architecture-guardian` - Para validar separacao de camadas
- `@solid-enforcer` - Para validar DIP
