# RAD-108: Oracle Connection Manager

**Fase:** 3 - Infrastructure Layer
**Tipo:** Infrastructure
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** -

## Objetivo

Implementar gerenciador de conexao Oracle seguindo o padrao do projeto de referencia (MJQEE-GFUZ).

## Localizacao

- `backend/shared/infrastructure/database/database.py` - Configuracao principal
- `backend/shared/infrastructure/database/async_oracle_session.py` - Wrapper async (opcional)

## Importante: Oracle e Async

> **PADRAO ADOTADO:** O projeto de referencia usa **endpoints SINCRONOS** com **Session SINCRONA**.
> Oracle NAO suporta async nativo no SQLAlchemy 2.0.
>
> **Recomendacao:** Use endpoints sync (`def`) com Session sync - e mais simples e performatico.
> **Alternativa:** Se async for necessario, use o wrapper `AsyncOracleSession` via threading.

## Especificacao

### Requisitos

1. Conexao **sincrona** com Oracle via SQLAlchemy + oracledb
2. Pool de conexoes configuravel
3. Suporte a multiplos ambientes (DEV, HM, PRD) com prefixo de variaveis
4. Suporte a DBLinks (DBLINK_INSERVICE, DBLINK_INDICADORES)
5. Health check de conexao
6. Wrapper async opcional para casos especificos

### DBLinks Utilizados

| DBLink | Banco Origem | Finalidade |
|--------|--------------|------------|
| `DBLINK_INSERVICE` | INSERVICE | AGENCY_EVENT, SWITCH_PLAN_TASKS, OMS_CONNECTIVITY |
| `DBLINK_INDICADORES` | INDICADORES | IND_UNIVERSOS |

## Implementacao

### 1. Configuracao do Database (database.py)

```python
# backend/shared/infrastructure/database/database.py
"""
Database configuration and connection management for Oracle 19c.

PADRAO: Endpoints SINCRONOS com Session SINCRONA.
Oracle nao suporta async nativo no SQLAlchemy 2.0.
"""
import os
from typing import Generator
from functools import lru_cache
from pathlib import Path

from sqlalchemy import create_engine, text, Engine
from sqlalchemy.orm import sessionmaker, Session, declarative_base
from dotenv import load_dotenv

from ..config import Settings


# Carrega .env baseado no ambiente
env = os.getenv("ENV", "dev").lower()
env_file = Path(__file__).parent.parent.parent.parent / f".env.{env}"
if env_file.exists():
    load_dotenv(env_file)
else:
    load_dotenv()

# Base para models SQLAlchemy
Base = declarative_base()


def get_oracle_config() -> dict[str, str]:
    """
    Obtem configuracao Oracle baseada no ambiente.

    Prioridade: {ENV}_ORACLE_* > ORACLE_*

    Exemplo:
        ENV=dev -> Usa DEV_ORACLE_DSN, DEV_ORACLE_USER, etc.
        ENV=prd -> Usa PRD_ORACLE_DSN, PRD_ORACLE_USER, etc.

    Returns:
        Dict com parametros de conexao Oracle

    Raises:
        ValueError: Se variaveis obrigatorias nao estiverem definidas
    """
    env = os.getenv("ENV", "").strip().upper()
    prefix = f"{env}_" if env else ""

    # Variaveis obrigatorias
    base_vars = ["ORACLE_DSN", "ORACLE_USER", "ORACLE_PASSWORD"]
    config = {}

    for base_var in base_vars:
        # Tenta com prefixo do ambiente primeiro
        env_var = f"{prefix}{base_var}"
        value = os.getenv(env_var)

        # Fallback para variavel sem prefixo
        if not value:
            value = os.getenv(base_var)

        if not value:
            if env:
                raise ValueError(
                    f"Variavel {env_var} ou {base_var} obrigatoria mas nao definida. "
                    f"ENV atual={env}"
                )
            else:
                raise ValueError(f"Variavel {base_var} obrigatoria mas nao definida")

        # Normaliza chave (oracle_dsn -> dsn)
        key = base_var.lower().replace("oracle_", "")
        config[key] = value

    return config


def get_database_url() -> str:
    """
    Constroi URL de conexao Oracle para SQLAlchemy.

    Returns:
        URL no formato oracle+oracledb://user:password@host:port/?service_name=SERVICE
    """
    config = get_oracle_config()
    dsn = config["dsn"]

    # Remove '//' inicial se presente
    if dsn.startswith("//"):
        dsn = dsn[2:]

    # Formato: oracle+oracledb://user:password@host:port/?service_name=SERVICE
    if "/" in dsn:
        host_port, service = dsn.split("/", 1)
        return f"oracle+oracledb://{config['user']}:{config['password']}@{host_port}/?service_name={service}"
    else:
        # Fallback para SID
        return f"oracle+oracledb://{config['user']}:{config['password']}@{dsn}"


def create_oracle_engine(
    pool_size: int = 20,
    max_overflow: int = 10,
    pool_timeout: int = 30,
    pool_recycle: int = 1800,
) -> Engine:
    """
    Cria SQLAlchemy Engine para Oracle.

    Args:
        pool_size: Numero de conexoes no pool
        max_overflow: Conexoes extras permitidas
        pool_timeout: Timeout para obter conexao do pool
        pool_recycle: Tempo para reciclar conexoes (segundos)

    Returns:
        Engine SQLAlchemy configurado
    """
    database_url = get_database_url()
    debug_mode = os.getenv("DEBUG", "false").lower() == "true"

    engine = create_engine(
        database_url,
        pool_size=pool_size,
        max_overflow=max_overflow,
        pool_timeout=pool_timeout,
        pool_recycle=pool_recycle,
        pool_pre_ping=True,  # Valida conexoes antes de usar
        echo=debug_mode,
    )

    return engine


def check_oracle_connection(engine: Engine) -> bool:
    """
    Testa conexao com Oracle.

    Args:
        engine: SQLAlchemy engine

    Returns:
        True se conexao OK

    Raises:
        Exception: Se conexao falhar
    """
    with engine.connect() as conn:
        result = conn.execute(text("SELECT 1 FROM DUAL"))
        return result.scalar() == 1


def check_dblink(engine: Engine, dblink: str) -> bool:
    """
    Testa conectividade com DBLink.

    Args:
        engine: SQLAlchemy engine
        dblink: Nome do DBLink (ex: DBLINK_INSERVICE)

    Returns:
        True se DBLink acessivel
    """
    try:
        with engine.connect() as conn:
            result = conn.execute(text(f"SELECT 1 FROM DUAL@{dblink}"))
            return result.scalar() == 1
    except Exception:
        return False


# ========== Global Instances ==========

# Engine e SessionLocal globais (singleton)
engine = create_oracle_engine()
SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)


def get_sync_session() -> Generator[Session, None, None]:
    """
    Dependency injection para sessao SINCRONA.

    Este e o PADRAO RECOMENDADO para endpoints Oracle.

    Usage:
        @router.get("/items")
        def get_items(session: Session = Depends(get_sync_session)):
            result = session.execute(text("SELECT ..."))
            return result.fetchall()

    Yields:
        Session: SQLAlchemy sync session
    """
    session = SessionLocal()
    try:
        yield session
    finally:
        session.close()


# ========== Async Support (Opcional) ==========
# Use apenas se realmente precisar de endpoints async

from .async_oracle_session import AsyncOracleSession
from typing import AsyncGenerator


async def get_async_session() -> AsyncGenerator[AsyncOracleSession, None]:
    """
    Dependency injection para sessao ASSINCRONA (wrapper).

    IMPORTANTE: Oracle nao suporta async nativo no SQLAlchemy 2.0.
    Esta funcao retorna AsyncOracleSession, um wrapper que executa
    operacoes sync em thread pool via asyncio.run_in_executor.

    RECOMENDACAO: Prefira get_sync_session() - e mais simples.

    Yields:
        AsyncOracleSession: Wrapper assincrono para Session sync
    """
    sync_session = SessionLocal()
    async_session = AsyncOracleSession(sync_session)

    try:
        yield async_session
        await async_session.commit()
    except Exception:
        await async_session.rollback()
        raise
    finally:
        await async_session.close()
```

### 2. Wrapper Async Opcional (async_oracle_session.py)

```python
# backend/shared/infrastructure/database/async_oracle_session.py
"""
Async Oracle Session Wrapper (OPCIONAL).

Use apenas se realmente precisar de endpoints async.
O padrao recomendado e endpoints sync com Session sync.
"""
import asyncio
from typing import Any, Optional
from sqlalchemy.orm import Session
from sqlalchemy import Result


class AsyncOracleSession:
    """
    Wrapper assincrono para SQLAlchemy Session sincrona.

    Executa operacoes sync em thread pool via asyncio.run_in_executor.
    """

    def __init__(self, session: Session) -> None:
        self._session = session

    @property
    def sync_session(self) -> Session:
        """Retorna session sync subjacente."""
        return self._session

    async def execute(
        self,
        statement: Any,
        params: Optional[dict] = None,
    ) -> Result:
        """Executa statement SQL de forma assincrona."""
        loop = asyncio.get_event_loop()

        def _execute():
            if params:
                return self._session.execute(statement, params)
            return self._session.execute(statement)

        return await loop.run_in_executor(None, _execute)

    async def execute_and_fetchall(
        self,
        statement: Any,
        params: Optional[dict] = None,
    ) -> list[Any]:
        """Executa query e retorna todos os resultados."""
        loop = asyncio.get_event_loop()

        def _execute_and_fetch():
            if params:
                result = self._session.execute(statement, params)
            else:
                result = self._session.execute(statement)
            return result.fetchall()

        return await loop.run_in_executor(None, _execute_and_fetch)

    async def commit(self) -> None:
        """Commit de transacao."""
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, self._session.commit)

    async def rollback(self) -> None:
        """Rollback de transacao."""
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, self._session.rollback)

    async def close(self) -> None:
        """Fecha sessao."""
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, self._session.close)

    async def __aenter__(self) -> "AsyncOracleSession":
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:
        if exc_type is not None:
            await self.rollback()
        else:
            await self.commit()
        await self.close()
```

## Configuracao (.env)

```env
# Ambiente
ENV=dev

# Oracle - Desenvolvimento
DEV_ORACLE_USER=radar_dev
DEV_ORACLE_PASSWORD=secret_dev
DEV_ORACLE_DSN=localhost:1521/XEPDB1

# Oracle - Homologacao
HM_ORACLE_USER=radar_hm
HM_ORACLE_PASSWORD=secret_hm
HM_ORACLE_DSN=oracle-hm.empresa.com:1521/RADARDB

# Oracle - Producao
PRD_ORACLE_USER=radar_prd
PRD_ORACLE_PASSWORD=secret_prd
PRD_ORACLE_DSN=oracle-prd.empresa.com:1521/RADARDB

# Fallback (usado se ENV nao definido)
ORACLE_USER=radar
ORACLE_PASSWORD=secret
ORACLE_DSN=localhost:1521/XEPDB1
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/infrastructure/database/test_database.py
import pytest
from unittest.mock import MagicMock, patch

from shared.infrastructure.database.database import (
    get_oracle_config,
    get_database_url,
    create_oracle_engine,
    check_oracle_connection,
    check_dblink,
)


class TestGetOracleConfig:
    """Testes para obtencao de configuracao Oracle."""

    def test_deve_usar_variaveis_com_prefixo_do_ambiente(self):
        """Usa variaveis prefixadas pelo ambiente."""
        with patch.dict("os.environ", {
            "ENV": "PRD",
            "PRD_ORACLE_USER": "prd_user",
            "PRD_ORACLE_PASSWORD": "prd_pass",
            "PRD_ORACLE_DSN": "prd_dsn",
        }):
            config = get_oracle_config()

            assert config["user"] == "prd_user"
            assert config["password"] == "prd_pass"
            assert config["dsn"] == "prd_dsn"

    def test_deve_usar_fallback_quando_sem_prefixo(self):
        """Usa variaveis sem prefixo como fallback."""
        with patch.dict("os.environ", {
            "ENV": "dev",
            "ORACLE_USER": "fallback_user",
            "ORACLE_PASSWORD": "fallback_pass",
            "ORACLE_DSN": "fallback_dsn",
        }, clear=True):
            config = get_oracle_config()

            assert config["user"] == "fallback_user"

    def test_deve_lancar_erro_sem_configuracao(self):
        """Erro quando configuracao incompleta."""
        with patch.dict("os.environ", {"ENV": ""}, clear=True):
            with pytest.raises(ValueError, match="obrigatoria"):
                get_oracle_config()


class TestGetDatabaseUrl:
    """Testes para construcao de URL."""

    def test_deve_construir_url_com_service_name(self):
        """URL com service_name quando DSN tem /."""
        with patch("shared.infrastructure.database.database.get_oracle_config") as mock:
            mock.return_value = {
                "user": "user",
                "password": "pass",
                "dsn": "localhost:1521/XEPDB1",
            }

            url = get_database_url()

            assert url == "oracle+oracledb://user:pass@localhost:1521/?service_name=XEPDB1"


@pytest.mark.integration
class TestOracleConnectionIntegration:
    """Testes de integracao com Oracle real."""

    @pytest.fixture
    def engine(self):
        """Engine de teste."""
        return create_oracle_engine()

    def test_deve_conectar_ao_oracle(self, engine):
        """Conecta com sucesso."""
        result = check_oracle_connection(engine)
        assert result is True

    def test_deve_verificar_dblink_inservice(self, engine):
        """DBLink INSERVICE acessivel."""
        result = check_dblink(engine, "DBLINK_INSERVICE")
        assert result is True

    def test_deve_verificar_dblink_indicadores(self, engine):
        """DBLink INDICADORES acessivel."""
        result = check_dblink(engine, "DBLINK_INDICADORES")
        assert result is True
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Engine **sincrono** com SQLAlchemy + oracledb
- [ ] Pool de conexoes configuravel (pool_size, max_overflow, etc.)
- [ ] Suporte a multiplos ambientes (DEV, HM, PRD) via prefixo
- [ ] `get_sync_session()` para dependency injection (PADRAO)
- [ ] Health check implementado
- [ ] Teste de DBLinks implementado
- [ ] Wrapper `AsyncOracleSession` disponivel (OPCIONAL)
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes unitarios (RED)
pytest tests/unit/infrastructure/database/test_database.py -v -m "not integration"

# Executar testes de integracao
pytest tests/unit/infrastructure/database/test_database.py -v -m integration

# Com cobertura
pytest tests/unit/infrastructure/database/ --cov=shared/infrastructure/database --cov-report=term-missing
```

## Padrao do Projeto de Referencia

O projeto de referencia (MJQEE-GFUZ) usa **endpoints SINCRONOS**:

```python
# PADRAO RECOMENDADO (do projeto de referencia)
from sqlalchemy.orm import Session

@router.get("/items")
def get_items(session: Session = Depends(get_sync_session)):
    """Endpoint SINCRONO com Session SINCRONA."""
    result = session.execute(text("SELECT ..."))
    return result.fetchall()

# ALTERNATIVA (wrapper async - use apenas se necessario)
@router.get("/items-async")
async def get_items_async(session: AsyncOracleSession = Depends(get_async_session)):
    """Endpoint ASSINCRONO com wrapper."""
    result = await session.execute_and_fetchall(text("SELECT ..."))
    return result
```

## Testes Relacionados

- RAD-109: Oracle InterrupcaoRepository
- RAD-120: Testes Integration - Repository
