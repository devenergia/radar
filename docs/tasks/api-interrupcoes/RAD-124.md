# RAD-124: Logging e Auditoria

**Fase:** 6 - Seguranca e Compliance
**Tipo:** Infrastructure
**Prioridade:** Media
**Status:** Pendente
**Dependencias:** RAD-115

## Objetivo

Implementar logging estruturado e auditoria de requisicoes.

## Localizacao

`backend/shared/infrastructure/logging/`

## Especificacao

### Requisitos

1. **Logging estruturado** (JSON em producao)
2. **Correlacao de requests** (request_id)
3. **Auditoria de acessos** (quem, quando, o que)
4. **Metricas de uso** (contadores, latencia)
5. **Niveis de log** (DEBUG, INFO, WARNING, ERROR)

### Campos Obrigatorios no Log

| Campo | Descricao |
|-------|-----------|
| timestamp | Data/hora ISO 8601 |
| level | Nivel do log |
| request_id | ID unico da requisicao |
| client_ip | IP do cliente |
| method | Metodo HTTP |
| path | Path da requisicao |
| status_code | Codigo de resposta |
| duration_ms | Tempo de processamento |
| api_key_prefix | Prefixo da API Key (para auditoria) |

## Implementacao

```python
# shared/infrastructure/logging/logger.py
import logging
import sys
from typing import Any

import structlog
from structlog.types import Processor


def setup_logging(
    level: str = "INFO",
    json_format: bool = True,
    service_name: str = "api-interrupcoes",
) -> None:
    """
    Configura logging estruturado.

    Args:
        level: Nivel minimo de log
        json_format: True para JSON, False para console colorido
        service_name: Nome do servico para identificacao
    """
    # Configurar logging padrao
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=getattr(logging, level.upper()),
    )

    # Processadores comuns
    shared_processors: list[Processor] = [
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
    ]

    # Processadores especificos do formato
    if json_format:
        processors = shared_processors + [
            structlog.processors.format_exc_info,
            structlog.processors.JSONRenderer(),
        ]
    else:
        processors = shared_processors + [
            structlog.dev.ConsoleRenderer(colors=True),
        ]

    structlog.configure(
        processors=processors,
        wrapper_class=structlog.make_filtering_bound_logger(
            getattr(logging, level.upper())
        ),
        context_class=dict,
        logger_factory=structlog.PrintLoggerFactory(),
        cache_logger_on_first_use=True,
    )

    # Adicionar contexto global
    structlog.contextvars.bind_contextvars(
        service=service_name,
    )


def get_logger(name: str | None = None) -> structlog.BoundLogger:
    """Retorna logger configurado."""
    return structlog.get_logger(name)


# shared/infrastructure/logging/audit.py
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any
import structlog


@dataclass
class AuditEvent:
    """Evento de auditoria."""

    timestamp: datetime = field(default_factory=datetime.utcnow)
    event_type: str = ""
    request_id: str = ""
    client_ip: str = ""
    api_key_prefix: str = ""
    method: str = ""
    path: str = ""
    status_code: int = 0
    duration_ms: float = 0
    extra: dict[str, Any] = field(default_factory=dict)


class AuditLogger:
    """Logger especializado para auditoria."""

    def __init__(self) -> None:
        self._logger = structlog.get_logger("audit")

    def log_request(
        self,
        request_id: str,
        client_ip: str,
        api_key: str | None,
        method: str,
        path: str,
    ) -> None:
        """Registra inicio de requisicao."""
        self._logger.info(
            "request_started",
            request_id=request_id,
            client_ip=client_ip,
            api_key_prefix=self._mask_key(api_key),
            method=method,
            path=path,
        )

    def log_response(
        self,
        request_id: str,
        status_code: int,
        duration_ms: float,
        error: str | None = None,
    ) -> None:
        """Registra fim de requisicao."""
        log_method = self._logger.info if status_code < 400 else self._logger.warning

        log_method(
            "request_completed",
            request_id=request_id,
            status_code=status_code,
            duration_ms=round(duration_ms, 2),
            error=error,
        )

    def log_auth_failure(
        self,
        request_id: str,
        client_ip: str,
        reason: str,
    ) -> None:
        """Registra falha de autenticacao."""
        self._logger.warning(
            "auth_failure",
            request_id=request_id,
            client_ip=client_ip,
            reason=reason,
        )

    def log_rate_limit(
        self,
        request_id: str,
        client_ip: str,
        api_key: str | None,
    ) -> None:
        """Registra rate limit atingido."""
        self._logger.warning(
            "rate_limit_exceeded",
            request_id=request_id,
            client_ip=client_ip,
            api_key_prefix=self._mask_key(api_key),
        )

    def log_database_query(
        self,
        request_id: str,
        query_name: str,
        duration_ms: float,
        rows_returned: int,
    ) -> None:
        """Registra execucao de query."""
        self._logger.debug(
            "database_query",
            request_id=request_id,
            query_name=query_name,
            duration_ms=round(duration_ms, 2),
            rows_returned=rows_returned,
        )

    def log_cache_hit(self, request_id: str, key: str) -> None:
        """Registra cache hit."""
        self._logger.debug(
            "cache_hit",
            request_id=request_id,
            cache_key=key,
        )

    def log_cache_miss(self, request_id: str, key: str) -> None:
        """Registra cache miss."""
        self._logger.debug(
            "cache_miss",
            request_id=request_id,
            cache_key=key,
        )

    def _mask_key(self, api_key: str | None) -> str:
        """Mascara API Key para log."""
        if not api_key:
            return "none"
        if len(api_key) <= 8:
            return "***"
        return api_key[:8] + "..."


# Singleton
_audit_logger: AuditLogger | None = None


def get_audit_logger() -> AuditLogger:
    """Retorna singleton do audit logger."""
    global _audit_logger
    if _audit_logger is None:
        _audit_logger = AuditLogger()
    return _audit_logger
```

## Middleware de Logging

```python
# apps/api_interrupcoes/middleware.py (atualizado)
import time
import uuid
from fastapi import Request, Response
from starlette.middleware.base import BaseHTTPMiddleware

from shared.infrastructure.logging.audit import get_audit_logger


class AuditMiddleware(BaseHTTPMiddleware):
    """Middleware para auditoria de requisicoes."""

    async def dispatch(self, request: Request, call_next) -> Response:
        audit = get_audit_logger()

        # Gerar request_id
        request_id = str(uuid.uuid4())[:8]
        request.state.request_id = request_id

        # Extrair informacoes
        client_ip = request.client.host if request.client else "unknown"
        api_key = request.headers.get("x-api-key")
        method = request.method
        path = request.url.path

        # Log inicio
        audit.log_request(
            request_id=request_id,
            client_ip=client_ip,
            api_key=api_key,
            method=method,
            path=path,
        )

        # Processar
        start_time = time.perf_counter()
        try:
            response = await call_next(request)
            duration_ms = (time.perf_counter() - start_time) * 1000

            # Log fim
            audit.log_response(
                request_id=request_id,
                status_code=response.status_code,
                duration_ms=duration_ms,
            )

            # Headers de correlacao
            response.headers["X-Request-ID"] = request_id

            return response

        except Exception as e:
            duration_ms = (time.perf_counter() - start_time) * 1000
            audit.log_response(
                request_id=request_id,
                status_code=500,
                duration_ms=duration_ms,
                error=str(e),
            )
            raise
```

## Exemplo de Output

```json
{
  "timestamp": "2025-01-15T10:30:45.123456Z",
  "level": "info",
  "event": "request_completed",
  "service": "api-interrupcoes",
  "request_id": "a1b2c3d4",
  "client_ip": "192.168.1.100",
  "api_key_prefix": "abcd1234...",
  "method": "GET",
  "path": "/api/v1/interrupcoes/quantitativointerrupcoesativas",
  "status_code": 200,
  "duration_ms": 45.23
}
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/logging/test_logger.py
import pytest
from unittest.mock import patch, MagicMock
import structlog

from shared.infrastructure.logging.logger import setup_logging, get_logger
from shared.infrastructure.logging.audit import AuditLogger, get_audit_logger


class TestSetupLogging:
    """Testes para configuracao de logging."""

    def test_deve_configurar_logging_json_em_producao(self):
        """JSON format em producao."""
        setup_logging(level="INFO", json_format=True)

        logger = get_logger("test")
        assert logger is not None

    def test_deve_configurar_logging_console_em_desenvolvimento(self):
        """Console format em desenvolvimento."""
        setup_logging(level="DEBUG", json_format=False)

        logger = get_logger("test")
        assert logger is not None

    def test_deve_aceitar_diferentes_niveis(self):
        """Aceita diferentes niveis de log."""
        for level in ["DEBUG", "INFO", "WARNING", "ERROR"]:
            setup_logging(level=level)
            logger = get_logger("test")
            assert logger is not None


class TestAuditLogger:
    """Testes para AuditLogger."""

    @pytest.fixture
    def audit(self):
        """AuditLogger de teste."""
        return AuditLogger()

    def test_deve_mascarar_api_key_curta(self, audit):
        """API Key curta e mascarada completamente."""
        masked = audit._mask_key("abc")

        assert masked == "***"

    def test_deve_mascarar_api_key_longa(self, audit):
        """API Key longa mostra apenas prefixo."""
        masked = audit._mask_key("abcdef123456789")

        assert masked == "abcdef12..."
        assert "123456789" not in masked

    def test_deve_retornar_none_para_api_key_vazia(self, audit):
        """API Key None retorna 'none'."""
        masked = audit._mask_key(None)

        assert masked == "none"

    def test_log_request_deve_incluir_campos_obrigatorios(self, audit):
        """Log de request inclui campos necessarios."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_request(
                request_id="abc123",
                client_ip="192.168.1.1",
                api_key="my-api-key-12345",
                method="GET",
                path="/api/v1/interrupcoes/quantitativointerrupcoesativas",
            )

            mock_logger.info.assert_called_once()
            call_kwargs = mock_logger.info.call_args[1]
            assert call_kwargs["request_id"] == "abc123"
            assert call_kwargs["client_ip"] == "192.168.1.1"
            assert call_kwargs["method"] == "GET"

    def test_log_response_deve_incluir_status_e_duracao(self, audit):
        """Log de response inclui status e duracao."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_response(
                request_id="abc123",
                status_code=200,
                duration_ms=45.5,
            )

            mock_logger.info.assert_called_once()
            call_kwargs = mock_logger.info.call_args[1]
            assert call_kwargs["status_code"] == 200
            assert call_kwargs["duration_ms"] == 45.5

    def test_log_response_deve_usar_warning_para_erros(self, audit):
        """Log de erro usa nivel warning."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_response(
                request_id="abc123",
                status_code=500,
                duration_ms=100.0,
                error="Internal error",
            )

            mock_logger.warning.assert_called_once()

    def test_log_auth_failure_deve_registrar_falha(self, audit):
        """Log de falha de autenticacao."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_auth_failure(
                request_id="abc123",
                client_ip="192.168.1.1",
                reason="API Key invalida",
            )

            mock_logger.warning.assert_called_once()
            call_kwargs = mock_logger.warning.call_args[1]
            assert "auth_failure" in mock_logger.warning.call_args[0]

    def test_log_rate_limit_deve_registrar_limite(self, audit):
        """Log de rate limit excedido."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_rate_limit(
                request_id="abc123",
                client_ip="192.168.1.1",
                api_key="my-key",
            )

            mock_logger.warning.assert_called_once()

    def test_log_cache_hit_deve_registrar_hit(self, audit):
        """Log de cache hit."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_cache_hit(
                request_id="abc123",
                key="interrupcoes:ativas",
            )

            mock_logger.debug.assert_called_once()

    def test_log_cache_miss_deve_registrar_miss(self, audit):
        """Log de cache miss."""
        with patch.object(audit, '_logger') as mock_logger:
            audit.log_cache_miss(
                request_id="abc123",
                key="interrupcoes:ativas",
            )

            mock_logger.debug.assert_called_once()


class TestGetAuditLogger:
    """Testes para singleton do AuditLogger."""

    def test_deve_retornar_mesma_instancia(self):
        """Retorna singleton."""
        audit1 = get_audit_logger()
        audit2 = get_audit_logger()

        assert audit1 is audit2
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Logging estruturado configurado
- [ ] JSON em producao, console em desenvolvimento
- [ ] Request ID em todas as requisicoes
- [ ] AuditLogger implementado
- [ ] Logs de autenticacao
- [ ] Logs de rate limit
- [ ] Logs de queries (debug)
- [ ] Logs de cache (debug)
- [ ] API Key mascarada nos logs
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/logging/test_logger.py -v

# Com cobertura
pytest tests/unit/logging/test_logger.py --cov=shared/infrastructure/logging --cov-report=term-missing
```

## Agentes Recomendados

- `@backend-architect` - Para arquitetura de logging
- `@security-checker` - Para validar nao-exposicao de dados sensiveis
