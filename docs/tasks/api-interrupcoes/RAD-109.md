# RAD-109: Oracle InterrupcaoRepository

**Fase:** 3 - Infrastructure Layer
**Tipo:** Repository Implementation
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-104, RAD-108

## Objetivo

Implementar repositorio Oracle que implementa o Protocol InterrupcaoRepository usando Session SINCRONA (padrao do projeto de referencia).

## Localizacao

`backend/apps/api_interrupcoes/repositories/oracle_interrupcao_repository.py`

## Importante: Padrao Sync

> **PADRAO ADOTADO:** O projeto de referencia (MJQEE-GFUZ) usa **endpoints SINCRONOS**
> com **Session SINCRONA**. Este e o padrao mais simples e recomendado para Oracle.
>
> O repositorio usa `Session` sincrona do SQLAlchemy.
> Endpoints devem ser `def` (nao `async def`).

## Especificacao

### Query Principal

```sql
SELECT
    ae.num_1 AS id,
    ae.NUM_CUST AS ucs_afetadas,
    spt.PLAN_ID AS plan_id,
    oc.conj AS conjunto,
    iu.CD_UNIVERSO AS codigo_ibge,
    ae.DT_ON AS data_inicio,
    ae.DT_OFF AS data_fim
FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
    ON spt.OUTAGE_NUM = ae.num_1
INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
    ON oc.mslink = ae.dev_id
    AND oc.dist = 370
INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
    ON iu.ID_DISPOSITIVO = ae.dev_id
    AND iu.CD_TIPO_UNIVERSO = 2
WHERE ae.is_open = 'T'
    AND ae.ag_id = 370
```

### Tabelas e Colunas

| Tabela | DBLink | Colunas Usadas |
|--------|--------|----------------|
| AGENCY_EVENT | INSERVICE | num_1, NUM_CUST, dev_id, is_open, ag_id, DT_ON, DT_OFF |
| SWITCH_PLAN_TASKS | INSERVICE | OUTAGE_NUM, PLAN_ID |
| OMS_CONNECTIVITY | INSERVICE | mslink, conj, dist |
| IND_UNIVERSOS | INDICADORES | ID_DISPOSITIVO, CD_UNIVERSO, CD_TIPO_UNIVERSO |

## Implementacao

```python
# apps/api_interrupcoes/repositories/oracle_interrupcao_repository.py
"""
Oracle Repository Implementation for Interrupcoes.

PADRAO: Usa Session SINCRONA do SQLAlchemy (endpoints sync).
"""
from datetime import datetime
from sqlalchemy import text
from sqlalchemy.orm import Session

from shared.domain.entities.interrupcao import Interrupcao
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao
from shared.domain.result import Result
from shared.infrastructure.logger import get_logger

logger = get_logger(__name__)


class OracleInterrupcaoRepository:
    """
    Implementacao Oracle do InterrupcaoRepository.

    Busca dados de interrupcoes ativas via DBLinks usando
    Session SINCRONA do SQLAlchemy (padrao do projeto de referencia).

    Attributes:
        _session: Session SQLAlchemy (sincrona)
    """

    # Constantes da agencia Roraima Energia
    AG_ID_RORAIMA = 370
    DIST_RORAIMA = 370

    # Query base para interrupcoes
    _BASE_QUERY = """
        SELECT
            ae.num_1 AS id,
            ae.NUM_CUST AS ucs_afetadas,
            spt.PLAN_ID AS plan_id,
            oc.conj AS conjunto,
            iu.CD_UNIVERSO AS codigo_ibge,
            ae.DT_ON AS data_inicio,
            ae.DT_OFF AS data_fim
        FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
        LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
            ON spt.OUTAGE_NUM = ae.num_1
        INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
            ON oc.mslink = ae.dev_id
            AND oc.dist = :dist
        INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
            ON iu.ID_DISPOSITIVO = ae.dev_id
            AND iu.CD_TIPO_UNIVERSO = 2
    """

    def __init__(self, session: Session) -> None:
        """
        Inicializa repositorio com sessao sincrona.

        Args:
            session: Session SQLAlchemy (sincrona)
        """
        self._session = session

    def buscar_ativas(self) -> list[Interrupcao]:
        """
        Busca todas as interrupcoes ativas (is_open = 'T').

        Returns:
            Lista de entidades Interrupcao
        """
        query = text(f"""
            {self._BASE_QUERY}
            WHERE ae.is_open = 'T'
                AND ae.ag_id = :ag_id
        """)

        logger.info("buscando_interrupcoes_ativas", ag_id=self.AG_ID_RORAIMA)

        result = self._session.execute(
            query,
            {"ag_id": self.AG_ID_RORAIMA, "dist": self.DIST_RORAIMA},
        )
        rows = result.fetchall()

        interrupcoes = self._map_to_entities(rows)
        logger.info("interrupcoes_encontradas", quantidade=len(interrupcoes))

        return interrupcoes

    def buscar_por_municipio(self, ibge: CodigoIBGE) -> list[Interrupcao]:
        """
        Busca interrupcoes ativas de um municipio especifico.

        Args:
            ibge: Codigo IBGE do municipio

        Returns:
            Lista de interrupcoes do municipio
        """
        query = text(f"""
            {self._BASE_QUERY}
            WHERE ae.is_open = 'T'
                AND ae.ag_id = :ag_id
                AND iu.CD_UNIVERSO = :ibge
        """)

        logger.info(
            "buscando_interrupcoes_por_municipio",
            municipio=ibge.valor,
        )

        result = self._session.execute(
            query,
            {
                "ag_id": self.AG_ID_RORAIMA,
                "dist": self.DIST_RORAIMA,
                "ibge": ibge.valor,
            },
        )
        rows = result.fetchall()

        return self._map_to_entities(rows)

    def buscar_historico(
        self,
        data_inicio: datetime,
        data_fim: datetime,
    ) -> list[Interrupcao]:
        """
        Busca historico de interrupcoes em um periodo.

        Args:
            data_inicio: Data inicial do periodo
            data_fim: Data final do periodo

        Returns:
            Lista de interrupcoes no periodo
        """
        query = text(f"""
            {self._BASE_QUERY}
            WHERE ae.ag_id = :ag_id
                AND ae.DT_ON BETWEEN :dt_inicio AND :dt_fim
        """)

        logger.info(
            "buscando_historico_interrupcoes",
            data_inicio=data_inicio.isoformat(),
            data_fim=data_fim.isoformat(),
        )

        result = self._session.execute(
            query,
            {
                "ag_id": self.AG_ID_RORAIMA,
                "dist": self.DIST_RORAIMA,
                "dt_inicio": data_inicio,
                "dt_fim": data_fim,
            },
        )
        rows = result.fetchall()

        return self._map_to_entities(rows)

    def _map_to_entities(self, rows: list) -> list[Interrupcao]:
        """
        Mapeia rows do banco para entidades de dominio.

        Args:
            rows: Rows do resultado da query

        Returns:
            Lista de entidades Interrupcao

        Note:
            Registros com IBGE invalido sao ignorados (logged).
        """
        entities = []

        for row in rows:
            # Criar Value Objects
            ibge_result = CodigoIBGE.create(str(row.codigo_ibge))
            if ibge_result.is_failure:
                logger.warning(
                    "ibge_invalido_ignorado",
                    codigo_ibge=row.codigo_ibge,
                    interrupcao_id=row.id,
                    error=ibge_result.error,
                )
                continue

            tipo = TipoInterrupcao.from_plan_id(row.plan_id)

            # Criar entidade
            interrupcao_result = Interrupcao.create({
                "id": row.id,
                "tipo": tipo,
                "municipio": ibge_result.value,
                "conjunto": row.conjunto,
                "ucs_afetadas": row.ucs_afetadas or 0,
                "data_inicio": row.data_inicio,
                "data_fim": row.data_fim,
            })

            if interrupcao_result.is_success:
                entities.append(interrupcao_result.value)
            else:
                logger.warning(
                    "interrupcao_invalida_ignorada",
                    interrupcao_id=row.id,
                    error=interrupcao_result.error,
                )

        return entities


# ========== Query Agregada (Alternativa Otimizada) ==========

class OracleInterrupcaoAggregatedRepository:
    """
    Repositorio com agregacao feita no banco (melhor performance).

    Para cenarios onde a lista de interrupcoes individuais nao e necessaria.
    """

    AG_ID_RORAIMA = 370
    DIST_RORAIMA = 370

    _AGGREGATED_QUERY = """
        SELECT
            oc.conj AS conjunto,
            iu.CD_UNIVERSO AS codigo_ibge,
            SUM(CASE
                WHEN spt.PLAN_ID IS NOT NULL
                THEN NVL(ae.NUM_CUST, 0)
                ELSE 0
            END) AS qtd_programada,
            SUM(CASE
                WHEN spt.PLAN_ID IS NULL
                THEN NVL(ae.NUM_CUST, 0)
                ELSE 0
            END) AS qtd_nao_programada
        FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
        LEFT JOIN INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
            ON spt.OUTAGE_NUM = ae.num_1
        INNER JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc
            ON oc.mslink = ae.dev_id
            AND oc.dist = :dist
        INNER JOIN INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES iu
            ON iu.ID_DISPOSITIVO = ae.dev_id
            AND iu.CD_TIPO_UNIVERSO = 2
        WHERE ae.is_open = 'T'
            AND ae.ag_id = :ag_id
        GROUP BY oc.conj, iu.CD_UNIVERSO
    """

    def __init__(self, session: Session) -> None:
        self._session = session

    def buscar_ativas_agregadas(self) -> list[dict]:
        """
        Busca interrupcoes ativas ja agregadas por conjunto/municipio.

        Returns:
            Lista de dicts com dados agregados
        """
        query = text(self._AGGREGATED_QUERY)

        result = self._session.execute(
            query,
            {"ag_id": self.AG_ID_RORAIMA, "dist": self.DIST_RORAIMA},
        )
        rows = result.fetchall()

        return [
            {
                "conjunto": row.conjunto,
                "codigo_ibge": str(row.codigo_ibge),
                "qtd_programada": row.qtd_programada,
                "qtd_nao_programada": row.qtd_nao_programada,
            }
            for row in rows
        ]
```

## Dependency Injection

```python
# apps/api_interrupcoes/dependencies.py
from fastapi import Depends
from sqlalchemy.orm import Session

from shared.infrastructure.database.database import get_sync_session
from .repositories.oracle_interrupcao_repository import OracleInterrupcaoRepository


def get_interrupcao_repository(
    session: Session = Depends(get_sync_session),
) -> OracleInterrupcaoRepository:
    """
    Factory do repositorio de interrupcoes.

    Args:
        session: Session SQLAlchemy injetada pelo FastAPI

    Returns:
        OracleInterrupcaoRepository configurado
    """
    return OracleInterrupcaoRepository(session)
```

## Uso nos Endpoints (SINCRONO)

```python
# apps/api_interrupcoes/routes.py
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from shared.infrastructure.database.database import get_sync_session
from .repositories.oracle_interrupcao_repository import OracleInterrupcaoRepository
from .dependencies import get_interrupcao_repository

router = APIRouter()


@router.get("/quantitativointerrupcoesativas")
def get_interrupcoes_ativas(
    repository: OracleInterrupcaoRepository = Depends(get_interrupcao_repository),
):
    """
    Endpoint SINCRONO (padrao do projeto de referencia).

    Note: `def` ao inves de `async def` pois usa Session sync.
    """
    interrupcoes = repository.buscar_ativas()
    # ... processar e retornar
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/repositories/test_oracle_interrupcao_repository.py
import pytest
from unittest.mock import MagicMock
from datetime import datetime

from apps.api_interrupcoes.repositories.oracle_interrupcao_repository import (
    OracleInterrupcaoRepository,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE


class TestOracleInterrupcaoRepository:
    """Testes para repositorio Oracle de interrupcoes."""

    @pytest.fixture
    def mock_session(self):
        """Mock da Session sync."""
        return MagicMock()

    @pytest.fixture
    def repository(self, mock_session):
        """Repository com session mockada."""
        return OracleInterrupcaoRepository(mock_session)

    class TestBuscarAtivas:
        """Testes para metodo buscar_ativas()."""

        def test_deve_retornar_lista_vazia_sem_dados(
            self, repository, mock_session
        ):
            """Retorna lista vazia quando nao ha interrupcoes."""
            mock_result = MagicMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            interrupcoes = repository.buscar_ativas()

            assert interrupcoes == []

        def test_deve_usar_ag_id_370(self, repository, mock_session):
            """Query usa ag_id 370 (Roraima Energia)."""
            mock_result = MagicMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            repository.buscar_ativas()

            # Verifica que ag_id foi passado como parametro
            call_args = mock_session.execute.call_args
            params = call_args[0][1] if len(call_args[0]) > 1 else call_args[1]
            assert params.get("ag_id") == 370

        def test_deve_mapear_row_para_entidade(self, repository, mock_session):
            """Row do banco e mapeada para entidade Interrupcao."""
            mock_row = MagicMock()
            mock_row.id = 12345
            mock_row.ucs_afetadas = 100
            mock_row.plan_id = None  # Nao programada
            mock_row.conjunto = 1
            mock_row.codigo_ibge = "1400100"  # Boa Vista
            mock_row.data_inicio = datetime.now()
            mock_row.data_fim = None

            mock_result = MagicMock()
            mock_result.fetchall.return_value = [mock_row]
            mock_session.execute.return_value = mock_result

            interrupcoes = repository.buscar_ativas()

            assert len(interrupcoes) == 1
            assert interrupcoes[0].id == 12345
            assert interrupcoes[0].ucs_afetadas == 100

        def test_deve_ignorar_ibge_invalido(self, repository, mock_session):
            """Registros com IBGE invalido sao ignorados."""
            mock_row = MagicMock()
            mock_row.id = 12345
            mock_row.ucs_afetadas = 100
            mock_row.plan_id = None
            mock_row.conjunto = 1
            mock_row.codigo_ibge = "9999999"  # IBGE invalido (nao Roraima)
            mock_row.data_inicio = datetime.now()
            mock_row.data_fim = None

            mock_result = MagicMock()
            mock_result.fetchall.return_value = [mock_row]
            mock_session.execute.return_value = mock_result

            interrupcoes = repository.buscar_ativas()

            assert interrupcoes == []

        def test_deve_classificar_programada_com_plan_id(
            self, repository, mock_session
        ):
            """Interrupcao com PLAN_ID e classificada como programada."""
            mock_row = MagicMock()
            mock_row.id = 12345
            mock_row.ucs_afetadas = 100
            mock_row.plan_id = 999  # Tem PLAN_ID
            mock_row.conjunto = 1
            mock_row.codigo_ibge = "1400100"
            mock_row.data_inicio = datetime.now()
            mock_row.data_fim = None

            mock_result = MagicMock()
            mock_result.fetchall.return_value = [mock_row]
            mock_session.execute.return_value = mock_result

            interrupcoes = repository.buscar_ativas()

            assert interrupcoes[0].is_programada() is True

        def test_deve_tratar_ucs_afetadas_null(self, repository, mock_session):
            """UCs afetadas NULL e tratado como 0."""
            mock_row = MagicMock()
            mock_row.id = 12345
            mock_row.ucs_afetadas = None  # NULL no banco
            mock_row.plan_id = None
            mock_row.conjunto = 1
            mock_row.codigo_ibge = "1400100"
            mock_row.data_inicio = datetime.now()
            mock_row.data_fim = None

            mock_result = MagicMock()
            mock_result.fetchall.return_value = [mock_row]
            mock_session.execute.return_value = mock_result

            interrupcoes = repository.buscar_ativas()

            assert interrupcoes[0].ucs_afetadas == 0

    class TestBuscarPorMunicipio:
        """Testes para metodo buscar_por_municipio()."""

        def test_deve_filtrar_por_codigo_ibge(
            self, repository, mock_session
        ):
            """Filtra por codigo IBGE especificado."""
            mock_result = MagicMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            ibge = CodigoIBGE.create("1400100").value
            repository.buscar_por_municipio(ibge)

            call_args = mock_session.execute.call_args
            params = call_args[0][1]
            assert params.get("ibge") == "1400100"

    class TestBuscarHistorico:
        """Testes para metodo buscar_historico()."""

        def test_deve_filtrar_por_periodo(self, repository, mock_session):
            """Filtra por periodo especificado."""
            mock_result = MagicMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            data_inicio = datetime(2025, 1, 1)
            data_fim = datetime(2025, 1, 7)

            repository.buscar_historico(data_inicio, data_fim)

            call_args = mock_session.execute.call_args
            params = call_args[0][1]
            assert params.get("dt_inicio") == data_inicio
            assert params.get("dt_fim") == data_fim


@pytest.mark.integration
class TestOracleInterrupcaoRepositoryIntegration:
    """Testes de integracao com Oracle real."""

    @pytest.fixture
    def repository(self, sync_oracle_session):
        """Repository com sessao real."""
        return OracleInterrupcaoRepository(sync_oracle_session)

    def test_deve_buscar_interrupcoes_ativas(self, repository):
        """Busca interrupcoes ativas do banco."""
        interrupcoes = repository.buscar_ativas()

        # Verifica que retorna lista (pode estar vazia)
        assert isinstance(interrupcoes, list)

        # Se tiver dados, valida estrutura
        if interrupcoes:
            interrupcao = interrupcoes[0]
            assert hasattr(interrupcao, "id")
            assert hasattr(interrupcao, "is_programada")
            assert hasattr(interrupcao, "municipio")

    def test_deve_retornar_apenas_interrupcoes_ativas(self, repository):
        """Todas as interrupcoes retornadas devem estar ativas."""
        interrupcoes = repository.buscar_ativas()

        for interrupcao in interrupcoes:
            assert interrupcao.is_ativa() is True
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Usa `Session` SINCRONA (NAO AsyncSession ou AsyncOracleSession)
- [ ] Implementa Protocol InterrupcaoRepository
- [ ] Busca interrupcoes ativas (is_open = 'T')
- [ ] Filtra por ag_id e dist corretos (370)
- [ ] Mapeia para entidades de dominio
- [ ] Trata IBGE invalido graciosamente (log + skip)
- [ ] Busca por municipio implementada
- [ ] Busca historico implementada
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes unitarios (RED)
pytest tests/unit/repositories/test_oracle_interrupcao_repository.py -v

# Executar testes de integracao
pytest tests/unit/repositories/test_oracle_interrupcao_repository.py -v -m integration

# Com cobertura
pytest tests/unit/repositories/test_oracle_interrupcao_repository.py --cov=apps/api_interrupcoes/repositories --cov-report=term-missing
```

## Padrao do Projeto de Referencia

O projeto de referencia (MJQEE-GFUZ) usa **metodos SINCRONOS**:

```python
# PADRAO DO PROJETO DE REFERENCIA
from sqlalchemy.orm import Session

class SomeRepository:
    def __init__(self, session: Session) -> None:
        self._session = session

    def buscar_algo(self) -> list[Entity]:
        """Metodo SINCRONO (nao async)."""
        result = self._session.execute(text("SELECT ..."))
        return result.fetchall()


# Dependency injection
def get_repository(
    session: Session = Depends(get_sync_session),
) -> SomeRepository:
    return SomeRepository(session)


# Endpoint SINCRONO
@router.get("/items")
def get_items(repo: SomeRepository = Depends(get_repository)):
    """Endpoint `def` (nao `async def`)."""
    return repo.buscar_algo()
```

## Testes Relacionados

- RAD-108: Oracle Connection Manager
- RAD-120: Testes Integration - Repository
