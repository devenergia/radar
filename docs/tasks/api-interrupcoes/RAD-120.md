# RAD-120: Testes Integration - Repository

**Fase:** 5 - Testes
**Tipo:** Test
**Prioridade:** Critica
**Status:** Pendente
**Dependencias:** RAD-109, RAD-110

## Objetivo

Implementar testes de integracao para repositorios Oracle.

## Localizacao

`backend/tests/integration/repositories/`

## Especificacao

### Cenarios de Teste

1. **OracleInterrupcaoRepository**
   - Buscar interrupcoes ativas
   - Buscar por municipio
   - Buscar historico
   - Mapeamento correto para entidades

2. **OracleUniversoRepository**
   - Buscar UCs por conjunto/municipio
   - Buscar municipio por dispositivo
   - Buscar conjunto por dispositivo

### Requisitos

- Banco Oracle de teste (ou mock)
- Fixtures com dados conhecidos
- Cleanup apos cada teste
- Isolamento entre testes

## Implementacao

```python
# tests/integration/repositories/test_oracle_interrupcao_repository.py
import pytest
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession

from apps.api_interrupcoes.repositories.oracle_interrupcao_repository import (
    OracleInterrupcaoRepository,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


@pytest.mark.integration
class TestOracleInterrupcaoRepository:
    """Testes de integracao para OracleInterrupcaoRepository."""

    @pytest.fixture
    async def repository(
        self,
        db_session: AsyncSession,
    ) -> OracleInterrupcaoRepository:
        """Fixture do repositorio com sessao de teste."""
        return OracleInterrupcaoRepository(db_session)

    class TestBuscarAtivas:
        """Testes para buscar_ativas()."""

        async def test_deve_retornar_lista_de_interrupcoes(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Busca retorna lista (pode ser vazia)."""
            interrupcoes = await repository.buscar_ativas()

            assert isinstance(interrupcoes, list)

        async def test_todas_interrupcoes_retornadas_sao_ativas(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Todas as interrupcoes retornadas devem estar ativas."""
            interrupcoes = await repository.buscar_ativas()

            for interrupcao in interrupcoes:
                assert interrupcao.is_ativa(), f"Interrupcao {interrupcao.id} nao esta ativa"

        async def test_interrupcoes_tem_municipio_de_roraima(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Todos os municipios devem ser de Roraima."""
            interrupcoes = await repository.buscar_ativas()

            for interrupcao in interrupcoes:
                assert interrupcao.municipio.valor.startswith("14"), \
                    f"Municipio {interrupcao.municipio.valor} nao e de Roraima"

        async def test_interrupcoes_tem_tipo_valido(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Tipo deve ser PROGRAMADA ou NAO_PROGRAMADA."""
            interrupcoes = await repository.buscar_ativas()

            for interrupcao in interrupcoes:
                assert interrupcao.tipo in [
                    TipoInterrupcao.PROGRAMADA,
                    TipoInterrupcao.NAO_PROGRAMADA,
                ]

        async def test_ucs_afetadas_nao_e_negativo(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """UCs afetadas deve ser >= 0."""
            interrupcoes = await repository.buscar_ativas()

            for interrupcao in interrupcoes:
                assert interrupcao.ucs_afetadas >= 0

    class TestBuscarPorMunicipio:
        """Testes para buscar_por_municipio()."""

        async def test_deve_filtrar_por_codigo_ibge(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Busca filtra corretamente por municipio."""
            ibge_boa_vista = CodigoIBGE.create("1400100").value

            interrupcoes = await repository.buscar_por_municipio(ibge_boa_vista)

            for interrupcao in interrupcoes:
                assert interrupcao.municipio.valor == "1400100"

        async def test_deve_retornar_lista_vazia_para_municipio_sem_interrupcoes(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Municipio sem interrupcoes retorna lista vazia."""
            # Uiramuta tem poucas UCs, provavelmente sem interrupcoes
            ibge_uiramuta = CodigoIBGE.create("1400704").value

            interrupcoes = await repository.buscar_por_municipio(ibge_uiramuta)

            assert isinstance(interrupcoes, list)

    class TestBuscarHistorico:
        """Testes para buscar_historico()."""

        async def test_deve_retornar_interrupcoes_no_periodo(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Busca historico dentro do periodo especificado."""
            data_fim = datetime.now()
            data_inicio = data_fim - timedelta(days=30)

            interrupcoes = await repository.buscar_historico(
                data_inicio, data_fim
            )

            for interrupcao in interrupcoes:
                assert interrupcao.data_inicio >= data_inicio
                assert interrupcao.data_inicio <= data_fim

        async def test_deve_retornar_lista_vazia_para_periodo_futuro(
            self,
            repository: OracleInterrupcaoRepository,
        ):
            """Periodo no futuro retorna lista vazia."""
            data_inicio = datetime.now() + timedelta(days=30)
            data_fim = data_inicio + timedelta(days=1)

            interrupcoes = await repository.buscar_historico(
                data_inicio, data_fim
            )

            assert interrupcoes == []


@pytest.mark.integration
class TestOracleUniversoRepository:
    """Testes de integracao para OracleUniversoRepository."""

    @pytest.fixture
    async def repository(
        self,
        db_session: AsyncSession,
    ):
        from apps.api_interrupcoes.repositories.oracle_universo_repository import (
            OracleUniversoRepository,
        )
        return OracleUniversoRepository(db_session)

    class TestBuscarUcsPorConjuntoMunicipio:
        """Testes para buscar_ucs_por_conjunto_municipio()."""

        async def test_deve_retornar_quantidade_de_ucs(
            self,
            repository,
        ):
            """Retorna quantidade de UCs para conjunto/municipio valido."""
            # Boa Vista, conjunto 1 deve ter UCs
            qtd = await repository.buscar_ucs_por_conjunto_municipio(
                conjunto=1,
                ibge="1400100",
            )

            # Pode ser None se nao existir, ou int >= 0
            assert qtd is None or qtd >= 0

        async def test_deve_retornar_none_para_combinacao_inexistente(
            self,
            repository,
        ):
            """Combinacao inexistente retorna None."""
            qtd = await repository.buscar_ucs_por_conjunto_municipio(
                conjunto=99999,
                ibge="1400100",
            )

            assert qtd is None or qtd == 0

    class TestBuscarUniversoCompleto:
        """Testes para buscar_universo_completo()."""

        async def test_deve_retornar_dicionario(
            self,
            repository,
        ):
            """Retorna dicionario com todas as combinacoes."""
            universo = await repository.buscar_universo_completo()

            assert isinstance(universo, dict)

        async def test_chaves_sao_tuplas_conjunto_ibge(
            self,
            repository,
        ):
            """Chaves sao tuplas (conjunto, ibge)."""
            universo = await repository.buscar_universo_completo()

            for chave in universo.keys():
                assert isinstance(chave, tuple)
                assert len(chave) == 2
                conjunto, ibge = chave
                assert isinstance(conjunto, int)
                assert isinstance(ibge, str)


# tests/integration/conftest.py
@pytest.fixture
async def db_session() -> AsyncSession:
    """
    Fixture para sessao de banco de dados de teste.

    Opcoes:
    1. Usar banco Oracle de teste real
    2. Usar SQLite em memoria (limitado)
    3. Usar mock da sessao
    """
    from shared.infrastructure.database.oracle_connection import (
        OracleConnectionManager,
        DatabaseConfig,
    )
    from shared.infrastructure.config import get_settings

    settings = get_settings()

    # Usar banco de teste
    config = DatabaseConfig(
        user=settings.oracle_test_user or settings.oracle_user,
        password=settings.oracle_test_password or settings.oracle_password,
        dsn=settings.oracle_test_dsn or settings.oracle_dsn,
    )

    manager = OracleConnectionManager(config)
    await manager.initialize()

    async with manager.get_session() as session:
        yield session

    await manager.close()
```

## Configuracao

```python
# pyproject.toml
[tool.pytest.ini_options]
markers = [
    "unit: Testes unitarios (rapidos, sem IO)",
    "integration: Testes de integracao (requerem Oracle)",
    "e2e: Testes end-to-end (API completa)",
]

# Variaveis de ambiente para teste
# .env.test
RADAR_ORACLE_TEST_USER=radar_test
RADAR_ORACLE_TEST_PASSWORD=test_password
RADAR_ORACLE_TEST_DSN=localhost:1521/XEPDB1_TEST
```

## Comando de Execucao

```bash
# Executar testes de integracao
pytest -m integration -v

# Com banco de teste especifico
RADAR_ORACLE_TEST_DSN=test-server:1521/TEST pytest -m integration

# Com cobertura
pytest -m integration --cov=apps/api_interrupcoes/repositories
```

## Criterios de Aceite

- [ ] Testes de buscar_ativas()
- [ ] Testes de buscar_por_municipio()
- [ ] Testes de buscar_historico()
- [ ] Testes de OracleUniversoRepository
- [ ] Fixtures de banco configuradas
- [ ] Marker @pytest.mark.integration
- [ ] Documentacao de setup do ambiente de teste

## Agentes Recomendados

- `@test-engineer` - Para criar testes robustos
- `@database-optimizer` - Para otimizar queries de teste
