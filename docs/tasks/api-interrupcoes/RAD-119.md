# RAD-119: Testes Unit - Use Case

**Fase:** 5 - Testes TDD
**Tipo:** Test
**Prioridade:** Critica
**Status:** Pendente
**Dependencias:** RAD-107

## Objetivo

Criar testes unitarios para o Use Case GetInterrupcoesAtivasUseCase.

## IMPORTANTE: Padroes do Projeto

- Testes ANTES do codigo (TDD)
- Cobertura >= 80%
- Markers: `@pytest.mark.unit`
- Mocks para repository e cache
- Pattern AAA (Arrange, Act, Assert)
- Testes async com `@pytest.mark.asyncio`

## Testes a Implementar

```python
# backend/tests/unit/use_cases/test_get_interrupcoes_ativas.py
import pytest
from unittest.mock import AsyncMock, Mock, patch
from datetime import datetime

from apps.api_interrupcoes.use_cases.get_interrupcoes_ativas import (
    GetInterrupcoesAtivasUseCase,
)
from shared.domain.entities.interrupcao import Interrupcao
from shared.domain.value_objects.codigo_ibge import CodigoIBGE
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestGetInterrupcoesAtivasUseCase:
    """Testes para Use Case GetInterrupcoesAtivasUseCase."""

    @pytest.fixture
    def mock_repository(self):
        """Mock do repositorio de interrupcoes."""
        repo = AsyncMock()
        repo.buscar_ativas = AsyncMock(return_value=[])
        return repo

    @pytest.fixture
    def mock_cache(self):
        """Mock do servico de cache."""
        cache = AsyncMock()
        cache.get = AsyncMock(return_value=None)
        cache.set = AsyncMock()
        return cache

    @pytest.fixture
    def use_case(self, mock_repository, mock_cache):
        """Instancia do use case com mocks."""
        return GetInterrupcoesAtivasUseCase(
            repository=mock_repository,
            cache=mock_cache,
        )

    @pytest.fixture
    def interrupcao_factory(self):
        """Factory para criar interrupcoes de teste."""
        def _create(**kwargs):
            defaults = {
                "id": 1,
                "tipo": TipoInterrupcao.NAO_PROGRAMADA,
                "municipio": CodigoIBGE.create("1400100").value,
                "conjunto": 1,
                "ucs_afetadas": 100,
                "data_inicio": datetime.now(),
                "data_fim": None,
            }
            return Interrupcao.create({**defaults, **kwargs}).value
        return _create

    class TestCacheHit:
        """Testes quando dados estao em cache."""

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_retornar_dados_do_cache_quando_disponivel(
            self, use_case, mock_cache, mock_repository
        ):
            """Se cache tem dados, retorna do cache sem ir ao banco."""
            # Arrange
            cached_data = [{"id": 1, "qtd_programada": 100}]
            mock_cache.get.return_value = cached_data

            # Act
            result = await use_case.execute()

            # Assert
            assert result.is_success
            assert result.value == cached_data
            mock_repository.buscar_ativas.assert_not_called()

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_nao_deve_atualizar_cache_quando_cache_hit(
            self, use_case, mock_cache
        ):
            """Cache hit nao deve chamar cache.set()."""
            # Arrange
            mock_cache.get.return_value = [{"id": 1}]

            # Act
            await use_case.execute()

            # Assert
            mock_cache.set.assert_not_called()

    class TestCacheMiss:
        """Testes quando cache esta vazio."""

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_buscar_do_repositorio_quando_cache_vazio(
            self, use_case, mock_cache, mock_repository, interrupcao_factory
        ):
            """Cache miss deve buscar do repositorio."""
            # Arrange
            mock_cache.get.return_value = None
            interrupcoes = [
                interrupcao_factory(id=1, ucs_afetadas=50),
                interrupcao_factory(id=2, ucs_afetadas=30),
            ]
            mock_repository.buscar_ativas.return_value = interrupcoes

            # Act
            result = await use_case.execute()

            # Assert
            assert result.is_success
            mock_repository.buscar_ativas.assert_called_once()

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_atualizar_cache_apos_buscar_do_repositorio(
            self, use_case, mock_cache, mock_repository, interrupcao_factory
        ):
            """Apos buscar do banco, deve atualizar cache."""
            # Arrange
            mock_cache.get.return_value = None
            mock_repository.buscar_ativas.return_value = [
                interrupcao_factory()
            ]

            # Act
            await use_case.execute()

            # Assert
            mock_cache.set.assert_called_once()

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_cache_deve_ter_ttl_de_5_minutos(
            self, use_case, mock_cache, mock_repository, interrupcao_factory
        ):
            """Cache deve ser setado com TTL de 300 segundos."""
            # Arrange
            mock_cache.get.return_value = None
            mock_repository.buscar_ativas.return_value = [
                interrupcao_factory()
            ]

            # Act
            await use_case.execute()

            # Assert
            call_args = mock_cache.set.call_args
            assert call_args[1].get('ttl', call_args[0][2] if len(call_args[0]) > 2 else None) == 300

    class TestAgregacao:
        """Testes da logica de agregacao."""

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_agregar_por_municipio_e_conjunto(
            self, use_case, mock_cache, mock_repository, interrupcao_factory
        ):
            """Interrupcoes do mesmo municipio/conjunto devem ser agregadas."""
            # Arrange
            mock_cache.get.return_value = None
            municipio = CodigoIBGE.create("1400100").value
            interrupcoes = [
                interrupcao_factory(
                    id=1,
                    municipio=municipio,
                    conjunto=1,
                    tipo=TipoInterrupcao.PROGRAMADA,
                    ucs_afetadas=50
                ),
                interrupcao_factory(
                    id=2,
                    municipio=municipio,
                    conjunto=1,
                    tipo=TipoInterrupcao.PROGRAMADA,
                    ucs_afetadas=30
                ),
            ]
            mock_repository.buscar_ativas.return_value = interrupcoes

            # Act
            result = await use_case.execute()

            # Assert
            assert result.is_success
            # Deve ter apenas 1 item agregado
            assert len(result.value) == 1
            # Total programada = 50 + 30 = 80
            assert result.value[0].qtd_programada == 80

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_separar_programada_e_nao_programada(
            self, use_case, mock_cache, mock_repository, interrupcao_factory
        ):
            """Agregacao deve separar por tipo de interrupcao."""
            # Arrange
            mock_cache.get.return_value = None
            municipio = CodigoIBGE.create("1400100").value
            interrupcoes = [
                interrupcao_factory(
                    id=1,
                    municipio=municipio,
                    conjunto=1,
                    tipo=TipoInterrupcao.PROGRAMADA,
                    ucs_afetadas=50
                ),
                interrupcao_factory(
                    id=2,
                    municipio=municipio,
                    conjunto=1,
                    tipo=TipoInterrupcao.NAO_PROGRAMADA,
                    ucs_afetadas=30
                ),
            ]
            mock_repository.buscar_ativas.return_value = interrupcoes

            # Act
            result = await use_case.execute()

            # Assert
            assert result.is_success
            assert result.value[0].qtd_programada == 50
            assert result.value[0].qtd_nao_programada == 30

    class TestErros:
        """Testes de tratamento de erros."""

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_retornar_failure_quando_repositorio_falha(
            self, use_case, mock_cache, mock_repository
        ):
            """Erro no repositorio deve retornar Result.fail()."""
            # Arrange
            mock_cache.get.return_value = None
            mock_repository.buscar_ativas.side_effect = Exception("DB Error")

            # Act
            result = await use_case.execute()

            # Assert
            assert result.is_failure
            assert "DB Error" in result.error or "erro" in result.error.lower()

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_usar_cache_stale_quando_repositorio_falha(
            self, use_case, mock_cache, mock_repository
        ):
            """Se banco falha e tem cache stale, usa cache."""
            # Arrange
            stale_data = [{"id": 1, "stale": True}]
            mock_cache.get.return_value = None
            mock_cache.get_stale = AsyncMock(return_value=stale_data)
            mock_repository.buscar_ativas.side_effect = Exception("DB Error")

            # Act
            # Depende da implementacao - pode retornar stale ou erro
            result = await use_case.execute()

            # Assert
            # Se implementado fallback para stale
            if hasattr(mock_cache, 'get_stale'):
                # Verifica que tentou buscar stale
                pass

    class TestSemDados:
        """Testes quando nao ha interrupcoes ativas."""

        @pytest.mark.unit
        @pytest.mark.asyncio
        async def test_deve_retornar_lista_vazia_quando_sem_interrupcoes(
            self, use_case, mock_cache, mock_repository
        ):
            """Sem interrupcoes ativas, retorna lista vazia."""
            # Arrange
            mock_cache.get.return_value = None
            mock_repository.buscar_ativas.return_value = []

            # Act
            result = await use_case.execute()

            # Assert
            assert result.is_success
            assert result.value == []
```

## Arquivo de Saida

`backend/tests/unit/use_cases/test_get_interrupcoes_ativas.py`

## Criterios de Aceite

- [ ] Testes de cache hit implementados
- [ ] Testes de cache miss implementados
- [ ] Testes de agregacao implementados
- [ ] Testes de erros implementados
- [ ] Mocks para repository e cache
- [ ] Pattern AAA (Arrange, Act, Assert)
- [ ] Markers @pytest.mark.unit e @pytest.mark.asyncio
- [ ] Cobertura >= 85% para use case
- [ ] Todos os testes passando

## Comandos de Execucao

```bash
# Executar testes do use case
pytest backend/tests/unit/use_cases/ -v

# Com cobertura
pytest backend/tests/unit/use_cases/ --cov=apps.api_interrupcoes.use_cases --cov-report=term-missing
```

## Agentes Recomendados

- `@test-engineer` - Para implementar os testes
- `@solid-enforcer` - Para validar SRP do use case
