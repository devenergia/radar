# RAD-111: Memory Cache Implementation

**Fase:** 3 - Infrastructure Layer
**Tipo:** Infrastructure
**Prioridade:** Alta
**Status:** Existente (necessita validacao)
**Dependencias:** RAD-106

## Objetivo

Implementar servico de cache em memoria que implementa o Protocol CacheService.

## Localizacao

`backend/shared/infrastructure/cache/memory_cache.py`

## Especificacao

### Requisitos

1. Implementar Protocol CacheService
2. TTL (Time To Live) para entradas
3. Thread-safe para uso com asyncio
4. Limpeza automatica de entradas expiradas
5. Metricas de hit/miss (opcional)

### Diagrama

```
┌─────────────────────────────────────────┐
│           MemoryCacheService            │
├─────────────────────────────────────────┤
│ _cache: dict[str, CacheEntry]           │
│ _lock: asyncio.Lock                     │
├─────────────────────────────────────────┤
│ + get(key) -> T | None                  │
│ + set(key, value, ttl) -> None          │
│ + delete(key) -> None                   │
│ + exists(key) -> bool                   │
│ + clear() -> None                       │
│ - _cleanup_expired() -> None            │
└─────────────────────────────────────────┘
```

## Implementacao

```python
# shared/infrastructure/cache/memory_cache.py
import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import TypeVar, Generic, Any

T = TypeVar("T")


@dataclass
class CacheEntry(Generic[T]):
    """Entrada do cache com valor e expiracao."""

    value: T
    expires_at: datetime

    def is_expired(self) -> bool:
        """Verifica se a entrada expirou."""
        return datetime.now() > self.expires_at


@dataclass
class CacheStats:
    """Estatisticas do cache."""

    hits: int = 0
    misses: int = 0
    sets: int = 0
    deletes: int = 0

    @property
    def hit_rate(self) -> float:
        """Taxa de acerto do cache."""
        total = self.hits + self.misses
        return self.hits / total if total > 0 else 0.0


class MemoryCacheService:
    """
    Implementacao de cache em memoria.

    Thread-safe para uso com asyncio, com suporte a TTL
    e limpeza automatica de entradas expiradas.
    """

    def __init__(
        self,
        cleanup_interval_seconds: int = 60,
        enable_stats: bool = True,
    ) -> None:
        self._cache: dict[str, CacheEntry] = {}
        self._lock = asyncio.Lock()
        self._cleanup_interval = cleanup_interval_seconds
        self._cleanup_task: asyncio.Task | None = None
        self._stats = CacheStats() if enable_stats else None

    async def start(self) -> None:
        """Inicia tarefa de limpeza periodica."""
        if self._cleanup_task is None:
            self._cleanup_task = asyncio.create_task(self._cleanup_loop())

    async def stop(self) -> None:
        """Para tarefa de limpeza."""
        if self._cleanup_task:
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
            self._cleanup_task = None

    async def get(self, key: str) -> Any | None:
        """
        Recupera valor do cache.

        Args:
            key: Chave do cache

        Returns:
            Valor armazenado ou None se nao existir/expirado
        """
        async with self._lock:
            entry = self._cache.get(key)

            if entry is None:
                if self._stats:
                    self._stats.misses += 1
                return None

            if entry.is_expired():
                del self._cache[key]
                if self._stats:
                    self._stats.misses += 1
                return None

            if self._stats:
                self._stats.hits += 1

            return entry.value

    async def set(
        self,
        key: str,
        value: Any,
        ttl_seconds: int = 300,
    ) -> None:
        """
        Armazena valor no cache.

        Args:
            key: Chave do cache
            value: Valor a armazenar
            ttl_seconds: Tempo de vida em segundos (padrao: 300)
        """
        async with self._lock:
            expires_at = datetime.now() + timedelta(seconds=ttl_seconds)
            self._cache[key] = CacheEntry(value=value, expires_at=expires_at)

            if self._stats:
                self._stats.sets += 1

    async def delete(self, key: str) -> None:
        """
        Remove valor do cache.

        Args:
            key: Chave a remover
        """
        async with self._lock:
            if key in self._cache:
                del self._cache[key]
                if self._stats:
                    self._stats.deletes += 1

    async def exists(self, key: str) -> bool:
        """
        Verifica se chave existe no cache.

        Args:
            key: Chave a verificar

        Returns:
            True se existir e nao expirado
        """
        async with self._lock:
            entry = self._cache.get(key)

            if entry is None:
                return False

            if entry.is_expired():
                del self._cache[key]
                return False

            return True

    async def clear(self) -> None:
        """Remove todos os valores do cache."""
        async with self._lock:
            self._cache.clear()

    async def get_stats(self) -> CacheStats | None:
        """Retorna estatisticas do cache."""
        return self._stats

    async def _cleanup_loop(self) -> None:
        """Loop de limpeza de entradas expiradas."""
        while True:
            await asyncio.sleep(self._cleanup_interval)
            await self._cleanup_expired()

    async def _cleanup_expired(self) -> None:
        """Remove todas as entradas expiradas."""
        async with self._lock:
            now = datetime.now()
            expired_keys = [
                key for key, entry in self._cache.items()
                if entry.expires_at < now
            ]
            for key in expired_keys:
                del self._cache[key]


# Singleton para uso global
_cache_instance: MemoryCacheService | None = None


def get_cache_service() -> MemoryCacheService:
    """Retorna singleton do cache service."""
    global _cache_instance

    if _cache_instance is None:
        _cache_instance = MemoryCacheService()

    return _cache_instance
```

## Uso

```python
# No use case
from shared.infrastructure.cache.memory_cache import get_cache_service
from shared.domain.cache.cache_service import CacheKeys, CacheTTL

cache = get_cache_service()

# Verificar cache
cached = await cache.get(CacheKeys.INTERRUPCOES_ATIVAS)
if cached is not None:
    return Result.ok(cached)

# Salvar no cache
await cache.set(
    CacheKeys.INTERRUPCOES_ATIVAS,
    agregadas,
    CacheTTL.INTERRUPCOES,
)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/infrastructure/cache/test_memory_cache.py
import pytest
import asyncio
from shared.infrastructure.cache.memory_cache import MemoryCacheService, CacheStats


@pytest.mark.asyncio
class TestMemoryCacheService:
    """Testes para servico de cache em memoria."""

    @pytest.fixture
    def cache(self):
        """Cache com stats habilitadas."""
        return MemoryCacheService(enable_stats=True)

    class TestGet:
        """Testes para metodo get()."""

        async def test_deve_retornar_none_para_chave_inexistente(self, cache):
            """Chave inexistente retorna None."""
            result = await cache.get("inexistente")

            assert result is None

        async def test_deve_retornar_valor_armazenado(self, cache):
            """Chave existente retorna valor."""
            await cache.set("key", "value")

            result = await cache.get("key")

            assert result == "value"

        async def test_deve_retornar_none_para_chave_expirada(self, cache):
            """Chave expirada retorna None."""
            await cache.set("key", "value", ttl_seconds=1)
            await asyncio.sleep(1.1)

            result = await cache.get("key")

            assert result is None

    class TestSet:
        """Testes para metodo set()."""

        async def test_deve_armazenar_valor(self, cache):
            """Valor e armazenado corretamente."""
            await cache.set("key", "value")

            assert await cache.get("key") == "value"

        async def test_deve_sobrescrever_valor_existente(self, cache):
            """Valor existente e sobrescrito."""
            await cache.set("key", "value1")
            await cache.set("key", "value2")

            assert await cache.get("key") == "value2"

        async def test_deve_usar_ttl_padrao_300(self, cache):
            """TTL padrao e 300 segundos."""
            await cache.set("key", "value")  # Sem TTL especificado

            # Valor deve existir imediatamente
            assert await cache.exists("key") is True

        async def test_deve_armazenar_diferentes_tipos(self, cache):
            """Cache armazena strings, ints, listas, dicts."""
            await cache.set("string", "valor")
            await cache.set("int", 42)
            await cache.set("list", [1, 2, 3])
            await cache.set("dict", {"a": 1})

            assert await cache.get("string") == "valor"
            assert await cache.get("int") == 42
            assert await cache.get("list") == [1, 2, 3]
            assert await cache.get("dict") == {"a": 1}

    class TestDelete:
        """Testes para metodo delete()."""

        async def test_deve_remover_chave_existente(self, cache):
            """Chave existente e removida."""
            await cache.set("key", "value")
            await cache.delete("key")

            assert await cache.get("key") is None

        async def test_deve_ignorar_chave_inexistente(self, cache):
            """Deletar chave inexistente nao lanca erro."""
            # Nao deve lancar exception
            await cache.delete("inexistente")

    class TestExists:
        """Testes para metodo exists()."""

        async def test_deve_retornar_true_para_chave_existente(self, cache):
            """Chave existente retorna True."""
            await cache.set("key", "value")

            assert await cache.exists("key") is True

        async def test_deve_retornar_false_para_chave_inexistente(self, cache):
            """Chave inexistente retorna False."""
            assert await cache.exists("inexistente") is False

        async def test_deve_retornar_false_para_chave_expirada(self, cache):
            """Chave expirada retorna False."""
            await cache.set("key", "value", ttl_seconds=1)
            await asyncio.sleep(1.1)

            assert await cache.exists("key") is False

    class TestClear:
        """Testes para metodo clear()."""

        async def test_deve_remover_todas_as_chaves(self, cache):
            """Clear remove todas as chaves."""
            await cache.set("key1", "value1")
            await cache.set("key2", "value2")
            await cache.set("key3", "value3")

            await cache.clear()

            assert await cache.exists("key1") is False
            assert await cache.exists("key2") is False
            assert await cache.exists("key3") is False

    class TestStats:
        """Testes para estatisticas de cache."""

        async def test_deve_contar_hits(self, cache):
            """Hit incrementa contador."""
            await cache.set("key", "value")
            await cache.get("key")
            await cache.get("key")

            stats = await cache.get_stats()

            assert stats.hits == 2

        async def test_deve_contar_misses(self, cache):
            """Miss incrementa contador."""
            await cache.get("inexistente1")
            await cache.get("inexistente2")

            stats = await cache.get_stats()

            assert stats.misses == 2

        async def test_deve_calcular_hit_rate(self, cache):
            """Hit rate calculado corretamente."""
            await cache.set("key", "value")
            await cache.get("key")  # hit
            await cache.get("key")  # hit
            await cache.get("miss")  # miss

            stats = await cache.get_stats()

            assert stats.hit_rate == pytest.approx(2/3, rel=0.01)

    class TestConcurrency:
        """Testes de concorrencia."""

        async def test_deve_ser_thread_safe(self, cache):
            """Operacoes concorrentes nao causam race conditions."""
            async def write(i):
                await cache.set(f"key{i}", f"value{i}")

            async def read(i):
                return await cache.get(f"key{i}")

            # Executar 100 operacoes concorrentes
            write_tasks = [write(i) for i in range(100)]
            await asyncio.gather(*write_tasks)

            read_tasks = [read(i) for i in range(100)]
            results = await asyncio.gather(*read_tasks)

            # Todos os valores devem estar corretos
            for i, result in enumerate(results):
                assert result == f"value{i}"
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Implementa Protocol CacheService
- [ ] TTL funcionando corretamente
- [ ] Thread-safe com asyncio.Lock
- [ ] Limpeza automatica de expirados
- [ ] Metodos get, set, delete, exists, clear
- [ ] Singleton pattern
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/infrastructure/cache/test_memory_cache.py -v

# Com cobertura
pytest tests/unit/infrastructure/cache/test_memory_cache.py --cov=shared/infrastructure/cache/memory_cache --cov-report=term-missing
```
