# RAD-110: Oracle UniversoRepository

**Fase:** 3 - Infrastructure Layer
**Tipo:** Repository Implementation
**Prioridade:** Media
**Status:** Pendente
**Dependencias:** RAD-108

## Objetivo

Implementar repositorio para buscar dados de universo (UCs atendidas por conjunto/municipio).

## Localizacao

`backend/apps/api_interrupcoes/repositories/oracle_universo_repository.py`

## Especificacao

### Protocol a Implementar

```python
# shared/domain/repositories/universo_repository.py
from typing import Protocol
from ..value_objects.codigo_ibge import CodigoIBGE


class UniversoRepository(Protocol):
    """Protocol para repositorio de dados de universo."""

    async def buscar_ucs_por_conjunto_municipio(
        self,
        conjunto: int,
        ibge: str,
    ) -> int | None:
        """Retorna quantidade de UCs atendidas."""
        ...

    async def buscar_municipio_por_dispositivo(
        self,
        dev_id: int,
    ) -> CodigoIBGE | None:
        """Retorna municipio do dispositivo."""
        ...

    async def buscar_conjunto_por_dispositivo(
        self,
        dev_id: int,
    ) -> int | None:
        """Retorna conjunto do dispositivo."""
        ...
```

### Query Principal

```sql
SELECT
    SUM(QTD_UC) AS qtd_ucs_atendidas
FROM INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES
WHERE CD_TIPO_UNIVERSO = 2
    AND CD_CONJUNTO = :conjunto
    AND CD_UNIVERSO = :ibge
```

## Implementacao

```python
# apps/api_interrupcoes/repositories/oracle_universo_repository.py
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from shared.domain.value_objects.codigo_ibge import CodigoIBGE


class OracleUniversoRepository:
    """
    Implementacao Oracle do UniversoRepository.

    Busca dados de universo (UCs atendidas) via DBLink.
    """

    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def buscar_ucs_por_conjunto_municipio(
        self,
        conjunto: int,
        ibge: str,
    ) -> int | None:
        """
        Busca quantidade de UCs atendidas em um conjunto/municipio.

        Args:
            conjunto: ID do conjunto eletrico
            ibge: Codigo IBGE do municipio

        Returns:
            Quantidade de UCs ou None se nao encontrado
        """
        query = text("""
            SELECT SUM(QTD_UC) AS qtd_ucs
            FROM INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES
            WHERE CD_TIPO_UNIVERSO = 2
                AND CD_CONJUNTO = :conjunto
                AND CD_UNIVERSO = :ibge
        """)

        result = await self._session.execute(
            query,
            {"conjunto": conjunto, "ibge": ibge},
        )

        row = result.fetchone()
        return row.qtd_ucs if row and row.qtd_ucs else None

    async def buscar_todos_conjuntos_municipios(self) -> list[dict]:
        """
        Busca todos os conjuntos e municipios com suas UCs.

        Returns:
            Lista de dicts com conjunto, ibge e qtd_ucs
        """
        query = text("""
            SELECT
                CD_CONJUNTO AS conjunto,
                CD_UNIVERSO AS ibge,
                SUM(QTD_UC) AS qtd_ucs
            FROM INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES
            WHERE CD_TIPO_UNIVERSO = 2
            GROUP BY CD_CONJUNTO, CD_UNIVERSO
        """)

        result = await self._session.execute(query)
        rows = result.fetchall()

        return [
            {
                "conjunto": row.conjunto,
                "ibge": row.ibge,
                "qtd_ucs": row.qtd_ucs or 0,
            }
            for row in rows
        ]

    async def buscar_municipio_por_dispositivo(
        self,
        dev_id: int,
    ) -> CodigoIBGE | None:
        """
        Busca municipio associado a um dispositivo.

        Args:
            dev_id: ID do dispositivo (dev_id do AGENCY_EVENT)

        Returns:
            CodigoIBGE do municipio ou None
        """
        query = text("""
            SELECT CD_UNIVERSO AS ibge
            FROM INDICADORES.IND_UNIVERSOS@DBLINK_INDICADORES
            WHERE ID_DISPOSITIVO = :dev_id
                AND CD_TIPO_UNIVERSO = 2
        """)

        result = await self._session.execute(
            query,
            {"dev_id": dev_id},
        )

        row = result.fetchone()
        if not row:
            return None

        ibge_result = CodigoIBGE.create(str(row.ibge))
        return ibge_result.value if ibge_result.is_success else None

    async def buscar_conjunto_por_dispositivo(
        self,
        dev_id: int,
    ) -> int | None:
        """
        Busca conjunto eletrico associado a um dispositivo.

        Args:
            dev_id: ID do dispositivo

        Returns:
            ID do conjunto ou None
        """
        query = text("""
            SELECT conj AS conjunto
            FROM INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE
            WHERE mslink = :dev_id
                AND dist = 370
        """)

        result = await self._session.execute(
            query,
            {"dev_id": dev_id},
        )

        row = result.fetchone()
        return row.conjunto if row else None

    async def buscar_universo_completo(self) -> dict[tuple[int, str], int]:
        """
        Busca todo o universo para cache.

        Returns:
            Dict (conjunto, ibge) -> qtd_ucs
        """
        dados = await self.buscar_todos_conjuntos_municipios()

        return {
            (item["conjunto"], item["ibge"]): item["qtd_ucs"]
            for item in dados
        }
```

## Uso

```python
# No use case
universo = await self._universo_repository.buscar_universo_completo()
agregadas = self._aggregator.agregar(interrupcoes, universo)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/repositories/test_oracle_universo_repository.py
import pytest
from unittest.mock import AsyncMock, MagicMock

from apps.api_interrupcoes.repositories.oracle_universo_repository import (
    OracleUniversoRepository,
)
from shared.domain.value_objects.codigo_ibge import CodigoIBGE


class TestOracleUniversoRepository:
    """Testes para repositorio Oracle de universo."""

    @pytest.fixture
    def mock_session(self):
        """Mock do AsyncSession."""
        return AsyncMock()

    @pytest.fixture
    def repository(self, mock_session):
        """Repository com session mockada."""
        return OracleUniversoRepository(mock_session)

    class TestBuscarUcsPorConjuntoMunicipio:
        """Testes para buscar_ucs_por_conjunto_municipio()."""

        async def test_deve_retornar_quantidade_de_ucs(
            self, repository, mock_session
        ):
            """Retorna quantidade de UCs atendidas."""
            mock_row = MagicMock()
            mock_row.qtd_ucs = 85432

            mock_result = MagicMock()
            mock_result.fetchone.return_value = mock_row
            mock_session.execute.return_value = mock_result

            qtd = await repository.buscar_ucs_por_conjunto_municipio(
                conjunto=1, ibge="1400100"
            )

            assert qtd == 85432

        async def test_deve_retornar_none_quando_nao_encontrado(
            self, repository, mock_session
        ):
            """Retorna None quando combinacao nao existe."""
            mock_result = MagicMock()
            mock_result.fetchone.return_value = None
            mock_session.execute.return_value = mock_result

            qtd = await repository.buscar_ucs_por_conjunto_municipio(
                conjunto=999, ibge="1400100"
            )

            assert qtd is None

        async def test_deve_passar_parametros_corretos(
            self, repository, mock_session
        ):
            """Passa conjunto e ibge como parametros."""
            mock_result = MagicMock()
            mock_result.fetchone.return_value = None
            mock_session.execute.return_value = mock_result

            await repository.buscar_ucs_por_conjunto_municipio(
                conjunto=5, ibge="1400209"
            )

            call_args = mock_session.execute.call_args
            params = call_args[0][1] if len(call_args[0]) > 1 else call_args[1]
            assert params.get("conjunto") == 5
            assert params.get("ibge") == "1400209"

    class TestBuscarMunicipioPorDispositivo:
        """Testes para buscar_municipio_por_dispositivo()."""

        async def test_deve_retornar_codigo_ibge(self, repository, mock_session):
            """Retorna CodigoIBGE do municipio."""
            mock_row = MagicMock()
            mock_row.ibge = "1400100"

            mock_result = MagicMock()
            mock_result.fetchone.return_value = mock_row
            mock_session.execute.return_value = mock_result

            ibge = await repository.buscar_municipio_por_dispositivo(dev_id=12345)

            assert ibge is not None
            assert ibge.valor == "1400100"

        async def test_deve_retornar_none_quando_nao_encontrado(
            self, repository, mock_session
        ):
            """Retorna None quando dispositivo nao existe."""
            mock_result = MagicMock()
            mock_result.fetchone.return_value = None
            mock_session.execute.return_value = mock_result

            ibge = await repository.buscar_municipio_por_dispositivo(dev_id=99999)

            assert ibge is None

    class TestBuscarConjuntoPorDispositivo:
        """Testes para buscar_conjunto_por_dispositivo()."""

        async def test_deve_retornar_id_conjunto(self, repository, mock_session):
            """Retorna ID do conjunto eletrico."""
            mock_row = MagicMock()
            mock_row.conjunto = 3

            mock_result = MagicMock()
            mock_result.fetchone.return_value = mock_row
            mock_session.execute.return_value = mock_result

            conjunto = await repository.buscar_conjunto_por_dispositivo(dev_id=12345)

            assert conjunto == 3

        async def test_deve_retornar_none_quando_nao_encontrado(
            self, repository, mock_session
        ):
            """Retorna None quando dispositivo nao existe."""
            mock_result = MagicMock()
            mock_result.fetchone.return_value = None
            mock_session.execute.return_value = mock_result

            conjunto = await repository.buscar_conjunto_por_dispositivo(dev_id=99999)

            assert conjunto is None

    class TestBuscarUniversoCompleto:
        """Testes para buscar_universo_completo()."""

        async def test_deve_retornar_dicionario_de_universo(
            self, repository, mock_session
        ):
            """Retorna dict (conjunto, ibge) -> qtd_ucs."""
            mock_rows = [
                MagicMock(conjunto=1, ibge="1400100", qtd_ucs=85432),
                MagicMock(conjunto=1, ibge="1400209", qtd_ucs=12345),
                MagicMock(conjunto=2, ibge="1400100", qtd_ucs=5000),
            ]

            mock_result = MagicMock()
            mock_result.fetchall.return_value = mock_rows
            mock_session.execute.return_value = mock_result

            universo = await repository.buscar_universo_completo()

            assert universo[(1, "1400100")] == 85432
            assert universo[(1, "1400209")] == 12345
            assert universo[(2, "1400100")] == 5000

        async def test_deve_retornar_dicionario_vazio_sem_dados(
            self, repository, mock_session
        ):
            """Retorna dict vazio quando nao ha dados."""
            mock_result = MagicMock()
            mock_result.fetchall.return_value = []
            mock_session.execute.return_value = mock_result

            universo = await repository.buscar_universo_completo()

            assert universo == {}
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Implementa Protocol UniversoRepository
- [ ] Busca UCs por conjunto/municipio
- [ ] Busca municipio por dispositivo
- [ ] Busca conjunto por dispositivo
- [ ] Metodo para cache completo do universo
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/repositories/test_oracle_universo_repository.py -v

# Com cobertura
pytest tests/unit/repositories/test_oracle_universo_repository.py --cov=apps/api_interrupcoes/repositories --cov-report=term-missing
```

## Testes Relacionados

- RAD-120: Testes Integration - Repository
