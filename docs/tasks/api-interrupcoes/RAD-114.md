# RAD-114: Routes/Endpoints

**Fase:** 4 - Interfaces Layer
**Tipo:** Interface/HTTP
**Prioridade:** Alta
**Status:** Existente (necessita refatoracao)
**Dependencias:** RAD-107, RAD-113, RAD-116

## Objetivo

Implementar endpoints HTTP conforme especificacao ANEEL.

## Localizacao

`backend/apps/api_interrupcoes/routes.py`

## Especificacao

### Endpoints

| Metodo | Path | Descricao |
|--------|------|-----------|
| GET | /quantitativointerrupcoesativas | Consulta interrupcoes ativas |
| GET | /health | Health check |

### Parametros do Endpoint Principal

| Header | Tipo | Obrigatorio | Descricao |
|--------|------|-------------|-----------|
| x-api-key | str | Sim | Chave de autenticacao |

### Respostas HTTP

| Status | Descricao |
|--------|-----------|
| 200 | Sucesso |
| 401 | API Key invalida ou ausente |
| 429 | Rate limit excedido |
| 500 | Erro interno |
| 503 | Servico indisponivel (Oracle offline) |

## Implementacao

```python
# apps/api_interrupcoes/routes.py
from fastapi import APIRouter, Depends, Header, Request, HTTPException, status
from typing import Annotated

from .schemas import (
    InterrupcoesAtivasResponse,
    HealthResponse,
    ErrorResponse,
)
from .dependencies import (
    get_use_case,
    verify_api_key,
    get_connection_manager,
    get_cache_service,
)
from .use_cases.get_interrupcoes_ativas import GetInterrupcoesAtivasUseCase
from shared.infrastructure.database.oracle_connection import OracleConnectionManager
from shared.infrastructure.cache.memory_cache import MemoryCacheService

router = APIRouter()


@router.get(
    "/quantitativointerrupcoesativas",
    response_model=InterrupcoesAtivasResponse,
    responses={
        200: {
            "description": "Sucesso",
            "model": InterrupcoesAtivasResponse,
        },
        401: {
            "description": "API Key invalida ou ausente",
            "model": ErrorResponse,
        },
        429: {
            "description": "Rate limit excedido",
            "model": ErrorResponse,
        },
        500: {
            "description": "Erro interno",
            "model": ErrorResponse,
        },
        503: {
            "description": "Servico indisponivel",
            "model": ErrorResponse,
        },
    },
    summary="Consulta interrupcoes ativas",
    description="""
    Retorna o quantitativo de interrupcoes ativas agregadas
    por municipio e conjunto eletrico.

    **Formato:** Conforme especificacao ANEEL para API de
    Quantitativo de Interrupcoes Ativas.

    **Rate Limit:** 12 requisicoes por minuto.
    """,
)
async def get_interrupcoes_ativas(
    request: Request,
    api_key: Annotated[str, Depends(verify_api_key)],
    use_case: Annotated[
        GetInterrupcoesAtivasUseCase,
        Depends(get_use_case),
    ],
) -> InterrupcoesAtivasResponse:
    """
    Endpoint principal para consulta de interrupcoes ativas.

    Retorna dados agregados por municipio/conjunto conforme ANEEL.
    """
    result = await use_case.execute()

    if result.is_failure:
        # Log do erro
        request.app.state.logger.error(
            "Erro ao buscar interrupcoes",
            error=result.error,
        )
        return InterrupcoesAtivasResponse.erro(
            result.error,
            descricao="Erro ao processar requisicao",
        )

    return InterrupcoesAtivasResponse.sucesso(result.value)


@router.get(
    "/health",
    response_model=HealthResponse,
    summary="Health check",
    description="Verifica status dos componentes da aplicacao.",
    tags=["Health"],
)
async def health_check(
    db: Annotated[OracleConnectionManager, Depends(get_connection_manager)],
    cache: Annotated[MemoryCacheService, Depends(get_cache_service)],
) -> HealthResponse:
    """
    Health check da aplicacao.

    Verifica:
    - Conexao com Oracle
    - DBLinks (DBLINK_INSERVICE, DBLINK_INDICADORES)
    - Cache em memoria
    """
    # Verificar Oracle
    db_ok = await db.health_check()

    # Verificar DBLinks
    dblinks = {
        "DBLINK_INSERVICE": await db.test_dblink("DBLINK_INSERVICE"),
        "DBLINK_INDICADORES": await db.test_dblink("DBLINK_INDICADORES"),
    }

    # Verificar cache
    cache_ok = True  # In-memory sempre disponivel

    # Status geral
    all_ok = db_ok and all(dblinks.values()) and cache_ok

    return HealthResponse(
        status="healthy" if all_ok else "unhealthy",
        database=db_ok,
        cache=cache_ok,
        dblinks=dblinks,
        version="1.0.0",
    )


@router.get(
    "/ready",
    summary="Readiness check",
    description="Verifica se a aplicacao esta pronta para receber requisicoes.",
    tags=["Health"],
)
async def readiness_check(
    db: Annotated[OracleConnectionManager, Depends(get_connection_manager)],
) -> dict:
    """
    Readiness probe para Kubernetes.

    Retorna 200 se pronto, 503 se nao.
    """
    if not await db.health_check():
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Database not ready",
        )

    return {"status": "ready"}


@router.get(
    "/live",
    summary="Liveness check",
    description="Verifica se a aplicacao esta viva.",
    tags=["Health"],
)
async def liveness_check() -> dict:
    """
    Liveness probe para Kubernetes.

    Sempre retorna 200 se o processo esta rodando.
    """
    return {"status": "alive"}
```

## Exemplos de Requisicao

```bash
# Requisicao com API Key
curl -X GET "http://localhost:8001/api/v1/interrupcoes/quantitativointerrupcoesativas" \
  -H "x-api-key: sua-api-key"

# Health check
curl -X GET "http://localhost:8001/api/v1/interrupcoes/health"

# Swagger UI (se debug=true)
open http://localhost:8001/docs
```

## Exemplo de Resposta

```json
{
  "idcStatusRequisicao": 1,
  "desStatusRequisicao": "Sucesso",
  "emailIndisponibilidade": "radar@roraimaenergia.com.br",
  "mensagem": "",
  "interrupcaoFornecimento": [
    {
      "ideConjuntoUnidadeConsumidora": 1,
      "ideMunicipio": "1400100",
      "qtdUCsAtendidas": 85432,
      "qtdOcorrenciaProgramada": 234,
      "qtdOcorrenciaNaoProgramada": 89
    },
    {
      "ideConjuntoUnidadeConsumidora": 2,
      "ideMunicipio": "1400209",
      "qtdUCsAtendidas": 12345,
      "qtdOcorrenciaProgramada": 0,
      "qtdOcorrenciaNaoProgramada": 156
    }
  ]
}
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/e2e/api/test_interrupcoes.py
import pytest
from httpx import AsyncClient
from fastapi import status


@pytest.mark.e2e
class TestQuantitativoInterrupcoesAtivas:
    """Testes E2E para endpoint de interrupcoes ativas."""

    class TestAutenticacao:
        """Testes de autenticacao."""

        async def test_deve_retornar_401_sem_api_key(self, client: AsyncClient):
            """Requisicao sem API Key retorna 401."""
            response = await client.get("/api/v1/interrupcoes/quantitativointerrupcoesativas")

            assert response.status_code == status.HTTP_401_UNAUTHORIZED

        async def test_deve_retornar_401_com_api_key_invalida(
            self, client: AsyncClient
        ):
            """API Key invalida retorna 401."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
                headers={"x-api-key": "chave-invalida"},
            )

            assert response.status_code == status.HTTP_401_UNAUTHORIZED

        async def test_deve_retornar_200_com_api_key_valida(
            self, client: AsyncClient, api_key: str
        ):
            """API Key valida retorna 200."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key},
            )

            assert response.status_code == status.HTTP_200_OK

    class TestFormatoResposta:
        """Testes de formato de resposta ANEEL."""

        async def test_deve_ter_formato_aneel(
            self, client: AsyncClient, api_key: str
        ):
            """Resposta segue formato ANEEL."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key},
            )

            body = response.json()

            assert "idcStatusRequisicao" in body
            assert "desStatusRequisicao" in body
            assert "emailIndisponibilidade" in body
            assert "mensagem" in body
            assert "interrupcaoFornecimento" in body

        async def test_deve_ter_status_1_em_sucesso(
            self, client: AsyncClient, api_key: str
        ):
            """Status 1 indica sucesso."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key},
            )

            body = response.json()

            assert body["idcStatusRequisicao"] == 1
            assert body["desStatusRequisicao"] == "Sucesso"

        async def test_erro_401_deve_ter_formato_aneel(
            self, client: AsyncClient
        ):
            """Erro 401 tambem segue formato ANEEL."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
            )

            body = response.json()

            assert body["idcStatusRequisicao"] == 2
            assert "emailIndisponibilidade" in body

    class TestInterrupcoes:
        """Testes de dados de interrupcoes."""

        async def test_lista_pode_estar_vazia(
            self, client: AsyncClient, api_key: str
        ):
            """Lista de interrupcoes pode ser vazia."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key},
            )

            body = response.json()

            assert isinstance(body["interrupcaoFornecimento"], list)

        async def test_item_tem_campos_obrigatorios(
            self, client: AsyncClient, api_key: str
        ):
            """Cada item tem campos obrigatorios."""
            response = await client.get(
                "/api/v1/interrupcoes/quantitativointerrupcoesativas",
                headers={"x-api-key": api_key},
            )

            body = response.json()

            if body["interrupcaoFornecimento"]:
                item = body["interrupcaoFornecimento"][0]
                assert "ideConjuntoUnidadeConsumidora" in item
                assert "ideMunicipio" in item
                assert "qtdUCsAtendidas" in item
                assert "qtdOcorrenciaProgramada" in item
                assert "qtdOcorrenciaNaoProgramada" in item


@pytest.mark.e2e
class TestHealthCheck:
    """Testes E2E para health check."""

    async def test_health_retorna_200(self, client: AsyncClient):
        """Health check retorna 200."""
        response = await client.get("/api/v1/interrupcoes/health")

        assert response.status_code == status.HTTP_200_OK

    async def test_health_nao_requer_autenticacao(self, client: AsyncClient):
        """Health check nao precisa de API Key."""
        response = await client.get("/api/v1/interrupcoes/health")

        assert response.status_code == status.HTTP_200_OK

    async def test_health_tem_campos_obrigatorios(self, client: AsyncClient):
        """Health response tem campos esperados."""
        response = await client.get("/api/v1/interrupcoes/health")

        body = response.json()

        assert "status" in body
        assert "database" in body
        assert "cache" in body
        assert "version" in body


# tests/e2e/conftest.py
import pytest
from httpx import AsyncClient
from apps.api_interrupcoes.main import create_app


@pytest.fixture
async def client():
    """Client de teste E2E."""
    app = create_app()
    async with AsyncClient(app=app, base_url="http://test") as client:
        yield client


@pytest.fixture
def api_key():
    """API Key valida para testes."""
    return "test-api-key"  # Configurar via env
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Endpoint GET /quantitativointerrupcoesativas implementado
- [ ] Validacao de API Key via Depends
- [ ] Retorno no formato ANEEL
- [ ] Health check implementado
- [ ] Readiness/Liveness probes
- [ ] Documentacao OpenAPI completa
- [ ] Tratamento de erros com formato ANEEL
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes E2E (RED)
pytest tests/e2e/api/test_interrupcoes.py -v -m e2e

# Com cobertura
pytest tests/e2e/api/test_interrupcoes.py --cov=apps/api_interrupcoes/routes --cov-report=term-missing
```
