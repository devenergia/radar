# RAD-113: Pydantic Schemas

**Fase:** 4 - Interfaces Layer
**Tipo:** Schema/DTO
**Prioridade:** Alta
**Status:** Existente (necessita validacao)
**Dependencias:** RAD-102, RAD-105

## Objetivo

Criar schemas Pydantic para validacao de entrada e formatacao de saida conforme especificacao ANEEL.

## Localizacao

`backend/apps/api_interrupcoes/schemas.py`

## Especificacao

### Formato de Resposta ANEEL

```json
{
  "idcStatusRequisicao": 1,
  "desStatusRequisicao": "Sucesso",
  "emailIndisponibilidade": "radar@roraimaenergia.com.br",
  "mensagem": "",
  "interrupcaoFornecimento": [
    {
      "ideConjuntoUnidadeConsumidora": 1,
      "ideMunicipio": "1400100",
      "qtdUCsAtendidas": 50000,
      "qtdOcorrenciaProgramada": 150,
      "qtdOcorrenciaNaoProgramada": 45
    }
  ]
}
```

### Campos Obrigatorios

| Campo | Tipo | Descricao |
|-------|------|-----------|
| idcStatusRequisicao | int | 1=Sucesso, 2=Erro |
| desStatusRequisicao | str | "Sucesso" ou descricao do erro |
| emailIndisponibilidade | str | Email de contato |
| mensagem | str | Mensagem adicional |
| interrupcaoFornecimento | list | Lista de interrupcoes |

### Campos de Interrupcao

| Campo | Tipo | Descricao |
|-------|------|-----------|
| ideConjuntoUnidadeConsumidora | int | ID do conjunto |
| ideMunicipio | str | Codigo IBGE (7 digitos) |
| qtdUCsAtendidas | int | Total de UCs no conjunto/municipio |
| qtdOcorrenciaProgramada | int | UCs com interrupcao programada |
| qtdOcorrenciaNaoProgramada | int | UCs com interrupcao nao programada |

## Implementacao

```python
# apps/api_interrupcoes/schemas.py
from pydantic import BaseModel, Field, field_validator
from typing import Literal

from shared.domain.services.interrupcao_aggregator import InterrupcaoAgregada


class InterrupcaoFornecimentoSchema(BaseModel):
    """Schema para item de interrupcao no formato ANEEL."""

    ideConjuntoUnidadeConsumidora: int = Field(
        ...,
        description="Identificador do conjunto de unidades consumidoras",
        examples=[1],
    )
    ideMunicipio: str = Field(
        ...,
        description="Codigo IBGE do municipio (7 digitos)",
        examples=["1400100"],
        min_length=7,
        max_length=7,
    )
    qtdUCsAtendidas: int = Field(
        ...,
        ge=0,
        description="Quantidade de UCs atendidas no conjunto/municipio",
        examples=[50000],
    )
    qtdOcorrenciaProgramada: int = Field(
        ...,
        ge=0,
        description="Quantidade de UCs com interrupcao programada",
        examples=[150],
    )
    qtdOcorrenciaNaoProgramada: int = Field(
        ...,
        ge=0,
        description="Quantidade de UCs com interrupcao nao programada",
        examples=[45],
    )

    @field_validator("ideMunicipio")
    @classmethod
    def validate_ibge(cls, v: str) -> str:
        """Valida formato do codigo IBGE."""
        if not v.isdigit():
            raise ValueError("Codigo IBGE deve conter apenas digitos")
        if not v.startswith("14"):
            raise ValueError("Codigo IBGE deve pertencer a Roraima (prefixo 14)")
        return v

    @classmethod
    def from_agregada(cls, agregada: InterrupcaoAgregada) -> "InterrupcaoFornecimentoSchema":
        """Cria schema a partir de InterrupcaoAgregada."""
        return cls(
            ideConjuntoUnidadeConsumidora=agregada.id_conjunto,
            ideMunicipio=agregada.municipio.valor,
            qtdUCsAtendidas=agregada.qtd_ucs_atendidas,
            qtdOcorrenciaProgramada=agregada.qtd_programada,
            qtdOcorrenciaNaoProgramada=agregada.qtd_nao_programada,
        )


class InterrupcoesAtivasResponse(BaseModel):
    """Schema de resposta para endpoint de interrupcoes ativas."""

    idcStatusRequisicao: Literal[1, 2] = Field(
        ...,
        description="Codigo de status: 1=Sucesso, 2=Erro",
        examples=[1],
    )
    desStatusRequisicao: str = Field(
        ...,
        description="Descricao do status",
        examples=["Sucesso"],
    )
    emailIndisponibilidade: str = Field(
        default="radar@roraimaenergia.com.br",
        description="Email para contato em caso de indisponibilidade",
    )
    mensagem: str = Field(
        default="",
        description="Mensagem adicional",
    )
    interrupcaoFornecimento: list[InterrupcaoFornecimentoSchema] = Field(
        default_factory=list,
        description="Lista de interrupcoes agregadas",
    )

    @classmethod
    def sucesso(
        cls,
        interrupcoes: list[InterrupcaoAgregada],
        mensagem: str = "",
    ) -> "InterrupcoesAtivasResponse":
        """Cria resposta de sucesso."""
        return cls(
            idcStatusRequisicao=1,
            desStatusRequisicao="Sucesso",
            mensagem=mensagem,
            interrupcaoFornecimento=[
                InterrupcaoFornecimentoSchema.from_agregada(i)
                for i in interrupcoes
            ],
        )

    @classmethod
    def erro(
        cls,
        mensagem: str,
        descricao: str = "Erro",
    ) -> "InterrupcoesAtivasResponse":
        """Cria resposta de erro."""
        return cls(
            idcStatusRequisicao=2,
            desStatusRequisicao=descricao,
            mensagem=mensagem,
            interrupcaoFornecimento=[],
        )

    class Config:
        json_schema_extra = {
            "example": {
                "idcStatusRequisicao": 1,
                "desStatusRequisicao": "Sucesso",
                "emailIndisponibilidade": "radar@roraimaenergia.com.br",
                "mensagem": "",
                "interrupcaoFornecimento": [
                    {
                        "ideConjuntoUnidadeConsumidora": 1,
                        "ideMunicipio": "1400100",
                        "qtdUCsAtendidas": 50000,
                        "qtdOcorrenciaProgramada": 150,
                        "qtdOcorrenciaNaoProgramada": 45,
                    }
                ],
            }
        }


class ErrorResponse(BaseModel):
    """Schema para resposta de erro HTTP."""

    idcStatusRequisicao: Literal[2] = 2
    desStatusRequisicao: str
    emailIndisponibilidade: str = "radar@roraimaenergia.com.br"
    mensagem: str
    interrupcaoFornecimento: list = Field(default_factory=list)

    @classmethod
    def from_exception(cls, e: Exception) -> "ErrorResponse":
        """Cria resposta de erro a partir de exception."""
        return cls(
            desStatusRequisicao="Erro interno",
            mensagem=str(e),
        )


class HealthResponse(BaseModel):
    """Schema para resposta de health check."""

    status: Literal["healthy", "unhealthy"]
    database: bool
    cache: bool
    dblinks: dict[str, bool]
    version: str
```

## Uso

```python
# Na rota
@router.get("/quantitativointerrupcoesativas")
async def get_interrupcoes(
    use_case: GetInterrupcoesAtivasUseCase = Depends(get_use_case),
) -> InterrupcoesAtivasResponse:
    result = await use_case.execute()

    if result.is_failure:
        return InterrupcoesAtivasResponse.erro(result.error)

    return InterrupcoesAtivasResponse.sucesso(result.value)
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/schemas/test_schemas.py
import pytest
from pydantic import ValidationError

from apps.api_interrupcoes.schemas import (
    InterrupcaoFornecimentoSchema,
    InterrupcoesAtivasResponse,
    ErrorResponse,
    HealthResponse,
)
from shared.domain.services.interrupcao_aggregator import InterrupcaoAgregada
from shared.domain.value_objects.codigo_ibge import CodigoIBGE


class TestInterrupcaoFornecimentoSchema:
    """Testes para schema de item de interrupcao."""

    class TestValidation:
        """Testes de validacao."""

        def test_deve_aceitar_dados_validos(self):
            """Dados validos criam schema."""
            schema = InterrupcaoFornecimentoSchema(
                ideConjuntoUnidadeConsumidora=1,
                ideMunicipio="1400100",
                qtdUCsAtendidas=50000,
                qtdOcorrenciaProgramada=150,
                qtdOcorrenciaNaoProgramada=45,
            )

            assert schema.ideConjuntoUnidadeConsumidora == 1
            assert schema.ideMunicipio == "1400100"

        def test_deve_rejeitar_ibge_com_menos_de_7_digitos(self):
            """IBGE invalido lanca erro."""
            with pytest.raises(ValidationError):
                InterrupcaoFornecimentoSchema(
                    ideConjuntoUnidadeConsumidora=1,
                    ideMunicipio="140010",  # 6 digitos
                    qtdUCsAtendidas=50000,
                    qtdOcorrenciaProgramada=150,
                    qtdOcorrenciaNaoProgramada=45,
                )

        def test_deve_rejeitar_ibge_de_outro_estado(self):
            """IBGE de outro estado lanca erro."""
            with pytest.raises(ValidationError):
                InterrupcaoFornecimentoSchema(
                    ideConjuntoUnidadeConsumidora=1,
                    ideMunicipio="3550308",  # Sao Paulo
                    qtdUCsAtendidas=50000,
                    qtdOcorrenciaProgramada=150,
                    qtdOcorrenciaNaoProgramada=45,
                )

        def test_deve_rejeitar_ucs_negativas(self):
            """Valores negativos lancam erro."""
            with pytest.raises(ValidationError):
                InterrupcaoFornecimentoSchema(
                    ideConjuntoUnidadeConsumidora=1,
                    ideMunicipio="1400100",
                    qtdUCsAtendidas=-1,  # Negativo
                    qtdOcorrenciaProgramada=150,
                    qtdOcorrenciaNaoProgramada=45,
                )

    class TestFromAgregada:
        """Testes para factory from_agregada()."""

        def test_deve_criar_schema_de_agregada(self):
            """Cria schema a partir de InterrupcaoAgregada."""
            agregada = InterrupcaoAgregada(
                id_conjunto=1,
                municipio=CodigoIBGE.create("1400100").value,
                qtd_ucs_atendidas=50000,
                qtd_programada=150,
                qtd_nao_programada=45,
            )

            schema = InterrupcaoFornecimentoSchema.from_agregada(agregada)

            assert schema.ideConjuntoUnidadeConsumidora == 1
            assert schema.ideMunicipio == "1400100"
            assert schema.qtdUCsAtendidas == 50000
            assert schema.qtdOcorrenciaProgramada == 150
            assert schema.qtdOcorrenciaNaoProgramada == 45


class TestInterrupcoesAtivasResponse:
    """Testes para schema de resposta."""

    class TestSucesso:
        """Testes para factory sucesso()."""

        def test_deve_criar_resposta_de_sucesso(self):
            """Cria resposta de sucesso."""
            agregadas = [
                InterrupcaoAgregada(
                    id_conjunto=1,
                    municipio=CodigoIBGE.create("1400100").value,
                    qtd_ucs_atendidas=50000,
                    qtd_programada=150,
                    qtd_nao_programada=45,
                )
            ]

            response = InterrupcoesAtivasResponse.sucesso(agregadas)

            assert response.idcStatusRequisicao == 1
            assert response.desStatusRequisicao == "Sucesso"
            assert len(response.interrupcaoFornecimento) == 1

        def test_deve_incluir_email_indisponibilidade(self):
            """Email padrao incluido."""
            response = InterrupcoesAtivasResponse.sucesso([])

            assert response.emailIndisponibilidade == "radar@roraimaenergia.com.br"

        def test_deve_incluir_mensagem_quando_fornecida(self):
            """Mensagem personalizada incluida."""
            response = InterrupcoesAtivasResponse.sucesso(
                [], mensagem="Dados em cache"
            )

            assert response.mensagem == "Dados em cache"

    class TestErro:
        """Testes para factory erro()."""

        def test_deve_criar_resposta_de_erro(self):
            """Cria resposta de erro."""
            response = InterrupcoesAtivasResponse.erro(
                "Erro de conexao", descricao="Falha no banco"
            )

            assert response.idcStatusRequisicao == 2
            assert response.desStatusRequisicao == "Falha no banco"
            assert response.mensagem == "Erro de conexao"
            assert response.interrupcaoFornecimento == []

    class TestSerialization:
        """Testes de serializacao JSON."""

        def test_deve_serializar_para_json(self):
            """Resposta serializa corretamente."""
            response = InterrupcoesAtivasResponse.sucesso([])

            json_data = response.model_dump()

            assert "idcStatusRequisicao" in json_data
            assert "interrupcaoFornecimento" in json_data


class TestHealthResponse:
    """Testes para schema de health check."""

    def test_deve_criar_resposta_healthy(self):
        """Cria resposta healthy."""
        response = HealthResponse(
            status="healthy",
            database=True,
            cache=True,
            dblinks={"DBLINK_INSERVICE": True},
            version="1.0.0",
        )

        assert response.status == "healthy"

    def test_deve_criar_resposta_unhealthy(self):
        """Cria resposta unhealthy."""
        response = HealthResponse(
            status="unhealthy",
            database=False,
            cache=True,
            dblinks={"DBLINK_INSERVICE": False},
            version="1.0.0",
        )

        assert response.status == "unhealthy"
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Schema InterrupcaoFornecimentoSchema com todos os campos ANEEL
- [ ] Schema InterrupcoesAtivasResponse com factory methods
- [ ] Validacao de codigo IBGE
- [ ] Validacao de valores nao negativos
- [ ] Factory method from_agregada()
- [ ] Factory methods sucesso() e erro()
- [ ] Schema ErrorResponse para erros HTTP
- [ ] Schema HealthResponse para health check
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/schemas/test_schemas.py -v

# Com cobertura
pytest tests/unit/schemas/test_schemas.py --cov=apps/api_interrupcoes/schemas --cov-report=term-missing
```
