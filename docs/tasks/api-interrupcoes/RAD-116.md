# RAD-116: Dependency Injection

**Fase:** 4 - Interfaces Layer
**Tipo:** Infrastructure
**Prioridade:** Alta
**Status:** Existente (necessita refatoracao)
**Dependencias:** RAD-107, RAD-108, RAD-109, RAD-110, RAD-111

## Objetivo

Configurar injecao de dependencias usando FastAPI Depends para desacoplamento.

## Localizacao

`backend/apps/api_interrupcoes/dependencies.py`

## Especificacao

### Diagrama de Dependencias

```
┌─────────────────────────────────────────────────────────────┐
│                        Routes                                │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    Dependencies                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │ verify_api   │  │ get_use_case │  │ get_session  │       │
│  │    _key      │  │              │  │              │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 Use Cases / Services                         │
│  ┌─────────────────────────────────────────────────────┐    │
│  │          GetInterrupcoesAtivasUseCase               │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│              Repositories / Infrastructure                   │
│  ┌────────────────┐  ┌────────────────┐  ┌──────────────┐   │
│  │ OracleInter    │  │ OracleUniverso │  │ MemoryCache  │   │
│  │ rupcaoRepo     │  │ Repository     │  │ Service      │   │
│  └────────────────┘  └────────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

## Implementacao

```python
# apps/api_interrupcoes/dependencies.py
from functools import lru_cache
from typing import Annotated, AsyncGenerator

from fastapi import Depends, Header, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession

from shared.infrastructure.config import Settings
from shared.infrastructure.database.oracle_connection import (
    OracleConnectionManager,
    get_session as get_db_session,
)
from shared.infrastructure.cache.memory_cache import (
    MemoryCacheService,
    get_cache_service as get_memory_cache,
)
from shared.domain.services.interrupcao_aggregator import InterrupcaoAggregatorService

from .repositories.oracle_interrupcao_repository import OracleInterrupcaoRepository
from .repositories.oracle_universo_repository import OracleUniversoRepository
from .use_cases.get_interrupcoes_ativas import GetInterrupcoesAtivasUseCase


# ============================================
# Configuracoes
# ============================================

@lru_cache
def get_settings() -> Settings:
    """
    Singleton das configuracoes.

    Carrega do .env e cacheia para performance.
    """
    return Settings()


# ============================================
# Autenticacao
# ============================================

async def verify_api_key(
    x_api_key: Annotated[str | None, Header()] = None,
    settings: Settings = Depends(get_settings),
) -> str:
    """
    Valida API Key do header.

    Args:
        x_api_key: API Key do header x-api-key

    Returns:
        API Key validada

    Raises:
        HTTPException 401: Se API Key ausente ou invalida
    """
    if x_api_key is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail={
                "idcStatusRequisicao": 2,
                "desStatusRequisicao": "API Key ausente",
                "emailIndisponibilidade": "radar@roraimaenergia.com.br",
                "mensagem": "Header x-api-key e obrigatorio",
                "interrupcaoFornecimento": [],
            },
        )

    if x_api_key != settings.api_key:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail={
                "idcStatusRequisicao": 2,
                "desStatusRequisicao": "API Key invalida",
                "emailIndisponibilidade": "radar@roraimaenergia.com.br",
                "mensagem": "API Key fornecida nao e valida",
                "interrupcaoFornecimento": [],
            },
        )

    return x_api_key


# ============================================
# Database
# ============================================

async def get_session(
    request: Request,
) -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency para obter sessao do Oracle.

    Usa o connection manager do app state.
    """
    db: OracleConnectionManager = request.app.state.db
    async with db.get_session() as session:
        yield session


async def get_connection_manager(
    request: Request,
) -> OracleConnectionManager:
    """Retorna o connection manager do app state."""
    return request.app.state.db


# ============================================
# Cache
# ============================================

async def get_cache_service(
    request: Request,
) -> MemoryCacheService:
    """Retorna o cache service do app state."""
    return request.app.state.cache


# ============================================
# Repositories
# ============================================

async def get_interrupcao_repository(
    session: Annotated[AsyncSession, Depends(get_session)],
) -> OracleInterrupcaoRepository:
    """Factory do repositorio de interrupcoes."""
    return OracleInterrupcaoRepository(session)


async def get_universo_repository(
    session: Annotated[AsyncSession, Depends(get_session)],
) -> OracleUniversoRepository:
    """Factory do repositorio de universo."""
    return OracleUniversoRepository(session)


# ============================================
# Services
# ============================================

def get_aggregator_service() -> InterrupcaoAggregatorService:
    """Factory do servico de agregacao."""
    return InterrupcaoAggregatorService()


# ============================================
# Use Cases
# ============================================

async def get_use_case(
    interrupcao_repo: Annotated[
        OracleInterrupcaoRepository,
        Depends(get_interrupcao_repository),
    ],
    universo_repo: Annotated[
        OracleUniversoRepository,
        Depends(get_universo_repository),
    ],
    cache: Annotated[MemoryCacheService, Depends(get_cache_service)],
    aggregator: Annotated[
        InterrupcaoAggregatorService,
        Depends(get_aggregator_service),
    ],
) -> GetInterrupcoesAtivasUseCase:
    """
    Factory do caso de uso principal.

    Monta todas as dependencias necessarias.
    """
    return GetInterrupcoesAtivasUseCase(
        _repository=interrupcao_repo,
        _universo_repository=universo_repo,
        _cache=cache,
        _aggregator=aggregator,
    )
```

## Uso nas Rotas

```python
# apps/api_interrupcoes/routes.py
from fastapi import APIRouter, Depends
from typing import Annotated

from .dependencies import get_use_case, verify_api_key
from .use_cases.get_interrupcoes_ativas import GetInterrupcoesAtivasUseCase
from .schemas import InterrupcoesAtivasResponse

router = APIRouter()


@router.get("/quantitativointerrupcoesativas")
async def get_interrupcoes(
    api_key: Annotated[str, Depends(verify_api_key)],
    use_case: Annotated[GetInterrupcoesAtivasUseCase, Depends(get_use_case)],
) -> InterrupcoesAtivasResponse:
    result = await use_case.execute()
    # ...
```

## Testes com Override

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient

from apps.api_interrupcoes.main import create_app
from apps.api_interrupcoes.dependencies import get_use_case, verify_api_key


@pytest.fixture
def mock_use_case():
    """Mock do use case para testes."""
    from unittest.mock import AsyncMock
    mock = AsyncMock()
    mock.execute.return_value = Result.ok([])
    return mock


@pytest.fixture
def client(mock_use_case):
    """Client de teste com dependencias mockadas."""
    app = create_app()

    # Override das dependencias
    app.dependency_overrides[verify_api_key] = lambda: "test-key"
    app.dependency_overrides[get_use_case] = lambda: mock_use_case

    with TestClient(app) as client:
        yield client

    app.dependency_overrides.clear()
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/dependencies/test_dependencies.py
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from fastapi import HTTPException

from apps.api_interrupcoes.dependencies import (
    get_settings,
    verify_api_key,
    get_session,
    get_use_case,
    get_interrupcao_repository,
    get_universo_repository,
    get_cache_service,
)
from shared.infrastructure.config import Settings


class TestGetSettings:
    """Testes para dependency de settings."""

    def test_deve_retornar_instancia_settings(self):
        """Retorna instancia de Settings."""
        # Limpa cache se existir
        get_settings.cache_clear()

        with patch.dict('os.environ', {
            'RADAR_API_KEY': 'test-key',
            'RADAR_ORACLE_PASSWORD': 'test-pass',
        }):
            settings = get_settings()

            assert isinstance(settings, Settings)

    def test_deve_ser_singleton(self):
        """Retorna mesma instancia (cached)."""
        get_settings.cache_clear()

        with patch.dict('os.environ', {
            'RADAR_API_KEY': 'test-key',
            'RADAR_ORACLE_PASSWORD': 'test-pass',
        }):
            settings1 = get_settings()
            settings2 = get_settings()

            assert settings1 is settings2


class TestVerifyApiKey:
    """Testes para dependency de autenticacao."""

    @pytest.fixture
    def settings(self):
        """Settings de teste."""
        return MagicMock(api_key="valid-api-key")

    async def test_deve_retornar_api_key_quando_valida(self, settings):
        """API Key valida retorna a chave."""
        result = await verify_api_key(
            x_api_key="valid-api-key",
            settings=settings,
        )

        assert result == "valid-api-key"

    async def test_deve_lancar_401_quando_api_key_ausente(self, settings):
        """API Key ausente lanca 401."""
        with pytest.raises(HTTPException) as exc_info:
            await verify_api_key(x_api_key=None, settings=settings)

        assert exc_info.value.status_code == 401

    async def test_deve_lancar_401_quando_api_key_invalida(self, settings):
        """API Key invalida lanca 401."""
        with pytest.raises(HTTPException) as exc_info:
            await verify_api_key(x_api_key="wrong-key", settings=settings)

        assert exc_info.value.status_code == 401

    async def test_erro_deve_ter_formato_aneel(self, settings):
        """Erro 401 segue formato ANEEL."""
        with pytest.raises(HTTPException) as exc_info:
            await verify_api_key(x_api_key=None, settings=settings)

        detail = exc_info.value.detail
        assert "idcStatusRequisicao" in detail
        assert detail["idcStatusRequisicao"] == 2
        assert "emailIndisponibilidade" in detail

    async def test_erro_api_key_invalida_deve_ter_formato_aneel(self, settings):
        """Erro de chave invalida segue formato ANEEL."""
        with pytest.raises(HTTPException) as exc_info:
            await verify_api_key(x_api_key="invalid", settings=settings)

        detail = exc_info.value.detail
        assert detail["idcStatusRequisicao"] == 2
        assert "invalida" in detail["desStatusRequisicao"].lower() or \
               "invalida" in detail["mensagem"].lower()


class TestGetSession:
    """Testes para dependency de sessao do banco."""

    async def test_deve_obter_sessao_do_app_state(self):
        """Obtem sessao do connection manager no app state."""
        mock_request = MagicMock()
        mock_session = AsyncMock()
        mock_db = MagicMock()
        mock_db.get_session.return_value.__aenter__.return_value = mock_session
        mock_db.get_session.return_value.__aexit__.return_value = None
        mock_request.app.state.db = mock_db

        async for session in get_session(mock_request):
            assert session == mock_session


class TestGetCacheService:
    """Testes para dependency de cache."""

    async def test_deve_obter_cache_do_app_state(self):
        """Obtem cache do app state."""
        mock_request = MagicMock()
        mock_cache = MagicMock()
        mock_request.app.state.cache = mock_cache

        cache = await get_cache_service(mock_request)

        assert cache == mock_cache


class TestGetInterrupcaoRepository:
    """Testes para dependency de repositorio."""

    async def test_deve_criar_repository_com_session(self):
        """Cria repository com session injetada."""
        mock_session = AsyncMock()

        repository = await get_interrupcao_repository(mock_session)

        assert repository._session == mock_session


class TestGetUseCase:
    """Testes para dependency de use case."""

    async def test_deve_criar_use_case_com_dependencias(self):
        """Cria use case com todas as dependencias."""
        mock_interrupcao_repo = MagicMock()
        mock_universo_repo = MagicMock()
        mock_cache = MagicMock()
        mock_aggregator = MagicMock()

        use_case = await get_use_case(
            interrupcao_repo=mock_interrupcao_repo,
            universo_repo=mock_universo_repo,
            cache=mock_cache,
            aggregator=mock_aggregator,
        )

        assert use_case._repository == mock_interrupcao_repo
        assert use_case._cache == mock_cache


class TestDependencyOverride:
    """Testes para override de dependencias."""

    def test_deve_permitir_override_para_testes(self):
        """Dependencias podem ser sobrescritas em testes."""
        from fastapi import FastAPI
        from fastapi.testclient import TestClient
        from apps.api_interrupcoes.main import create_app
        from apps.api_interrupcoes.dependencies import verify_api_key

        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            # Override da dependency
            app.dependency_overrides[verify_api_key] = lambda: "test-key"

            # Limpa depois
            app.dependency_overrides.clear()
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Dependency verify_api_key implementada
- [ ] Dependency get_session implementada
- [ ] Dependency get_use_case implementada
- [ ] Todas as dependencias injetaveis
- [ ] Suporte a override para testes
- [ ] Settings como singleton (@lru_cache)
- [ ] Erros de auth no formato ANEEL
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/dependencies/test_dependencies.py -v

# Com cobertura
pytest tests/unit/dependencies/test_dependencies.py --cov=apps/api_interrupcoes/dependencies --cov-report=term-missing
```

## Testes Relacionados

- RAD-119: Testes Unit - Use Case
- RAD-121: Testes E2E - API
