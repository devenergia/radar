# RAD-101: Value Object TipoInterrupcao

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** Existente
**Dependencias:** -

## Objetivo

Criar Enum Value Object para tipo de interrupcao (PROGRAMADA/NAO_PROGRAMADA).

## Localizacao

`backend/shared/domain/value_objects/tipo_interrupcao.py`

## Especificacao

### Regras de Negocio

1. **PROGRAMADA:** Interrupcao com PLAN_ID no banco (manutencao preventiva, obras)
2. **NAO_PROGRAMADA:** Interrupcao sem PLAN_ID (falhas, acidentes, eventos climaticos)

### Determinacao do Tipo

A determinacao e feita baseada na existencia de PLAN_ID na tabela `SWITCH_PLAN_TASKS`:
- Se `PLAN_ID IS NOT NULL` -> PROGRAMADA
- Se `PLAN_ID IS NULL` -> NAO_PROGRAMADA

## Implementacao

```python
# shared/domain/value_objects/tipo_interrupcao.py
from enum import Enum


class TipoInterrupcao(Enum):
    """Value Object para tipo de interrupcao."""

    PROGRAMADA = "PROGRAMADA"
    NAO_PROGRAMADA = "NAO_PROGRAMADA"

    @classmethod
    def from_plan_id(cls, plan_id: int | None) -> "TipoInterrupcao":
        """
        Determina tipo baseado na existencia de PLAN_ID.

        Regra ANEEL: Se existe PLAN_ID, e programada.

        Args:
            plan_id: ID do plano de manobra (pode ser None)

        Returns:
            PROGRAMADA se plan_id existe, NAO_PROGRAMADA caso contrario
        """
        return cls.PROGRAMADA if plan_id is not None else cls.NAO_PROGRAMADA

    @classmethod
    def from_codigo(cls, codigo: int) -> "TipoInterrupcao":
        """
        Cria tipo a partir de codigo numerico.

        Args:
            codigo: 1 = PROGRAMADA, 2 = NAO_PROGRAMADA

        Returns:
            Tipo correspondente

        Raises:
            ValueError: Se codigo invalido
        """
        if codigo == 1:
            return cls.PROGRAMADA
        elif codigo == 2:
            return cls.NAO_PROGRAMADA
        else:
            raise ValueError(f"Codigo de tipo invalido: {codigo}")

    def is_programada(self) -> bool:
        """Retorna True se interrupcao e programada."""
        return self == TipoInterrupcao.PROGRAMADA

    def is_nao_programada(self) -> bool:
        """Retorna True se interrupcao e nao programada."""
        return self == TipoInterrupcao.NAO_PROGRAMADA

    def to_codigo(self) -> int:
        """Retorna codigo numerico para resposta ANEEL."""
        return 1 if self == TipoInterrupcao.PROGRAMADA else 2
```

## Mapeamento ANEEL

| Tipo | Codigo | Descricao |
|------|--------|-----------|
| PROGRAMADA | 1 | Manutencao preventiva, obras, expansao |
| NAO_PROGRAMADA | 2 | Falhas, acidentes, eventos climaticos |

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/value_objects/test_tipo_interrupcao.py
import pytest
from shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestTipoInterrupcao:
    """Testes para Value Object TipoInterrupcao."""

    class TestFromPlanId:
        """Testes para factory from_plan_id()."""

        def test_deve_retornar_programada_quando_plan_id_existe(self):
            """PLAN_ID presente indica interrupcao programada."""
            tipo = TipoInterrupcao.from_plan_id(12345)

            assert tipo == TipoInterrupcao.PROGRAMADA

        def test_deve_retornar_programada_para_qualquer_plan_id_valido(self):
            """Qualquer PLAN_ID nao-nulo indica programada."""
            for plan_id in [1, 100, 99999, 1000000]:
                tipo = TipoInterrupcao.from_plan_id(plan_id)
                assert tipo == TipoInterrupcao.PROGRAMADA

        def test_deve_retornar_nao_programada_quando_plan_id_e_none(self):
            """PLAN_ID None indica interrupcao nao programada."""
            tipo = TipoInterrupcao.from_plan_id(None)

            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

    class TestFromCodigo:
        """Testes para factory from_codigo()."""

        def test_codigo_1_retorna_programada(self):
            """Codigo 1 = PROGRAMADA (padrao ANEEL)."""
            tipo = TipoInterrupcao.from_codigo(1)

            assert tipo == TipoInterrupcao.PROGRAMADA

        def test_codigo_2_retorna_nao_programada(self):
            """Codigo 2 = NAO_PROGRAMADA (padrao ANEEL)."""
            tipo = TipoInterrupcao.from_codigo(2)

            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

        def test_codigo_invalido_lanca_value_error(self):
            """Codigos diferentes de 1 ou 2 lancam erro."""
            with pytest.raises(ValueError) as exc_info:
                TipoInterrupcao.from_codigo(3)

            assert "invalido" in str(exc_info.value).lower()

        def test_codigo_zero_lanca_value_error(self):
            """Codigo 0 e invalido."""
            with pytest.raises(ValueError):
                TipoInterrupcao.from_codigo(0)

        def test_codigo_negativo_lanca_value_error(self):
            """Codigos negativos sao invalidos."""
            with pytest.raises(ValueError):
                TipoInterrupcao.from_codigo(-1)

    class TestIsProgramada:
        """Testes para metodo is_programada()."""

        def test_programada_retorna_true(self):
            """TipoInterrupcao.PROGRAMADA.is_programada() == True."""
            assert TipoInterrupcao.PROGRAMADA.is_programada() is True

        def test_nao_programada_retorna_false(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_programada() == False."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_programada() is False

    class TestIsNaoProgramada:
        """Testes para metodo is_nao_programada()."""

        def test_nao_programada_retorna_true(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_nao_programada() == True."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_nao_programada() is True

        def test_programada_retorna_false(self):
            """TipoInterrupcao.PROGRAMADA.is_nao_programada() == False."""
            assert TipoInterrupcao.PROGRAMADA.is_nao_programada() is False

    class TestToCodigo:
        """Testes para metodo to_codigo()."""

        def test_programada_retorna_1(self):
            """PROGRAMADA converte para codigo 1."""
            assert TipoInterrupcao.PROGRAMADA.to_codigo() == 1

        def test_nao_programada_retorna_2(self):
            """NAO_PROGRAMADA converte para codigo 2."""
            assert TipoInterrupcao.NAO_PROGRAMADA.to_codigo() == 2

    class TestEnumValues:
        """Testes para valores do Enum."""

        def test_enum_tem_apenas_dois_valores(self):
            """Enum deve ter exatamente 2 valores."""
            assert len(TipoInterrupcao) == 2

        def test_valores_sao_strings_corretas(self):
            """Valores do enum sao strings descritivas."""
            assert TipoInterrupcao.PROGRAMADA.value == "PROGRAMADA"
            assert TipoInterrupcao.NAO_PROGRAMADA.value == "NAO_PROGRAMADA"
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Enum com 2 valores
- [ ] Factory from_plan_id()
- [ ] Factory from_codigo()
- [ ] Metodos is_programada() e is_nao_programada()
- [ ] Metodo to_codigo() para resposta ANEEL
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED - devem falhar primeiro)
pytest tests/unit/domain/value_objects/test_tipo_interrupcao.py -v

# Apos implementacao (GREEN)
pytest tests/unit/domain/value_objects/test_tipo_interrupcao.py -v --tb=short

# Com cobertura
pytest tests/unit/domain/value_objects/test_tipo_interrupcao.py --cov=shared/domain/value_objects/tipo_interrupcao --cov-report=term-missing
```
