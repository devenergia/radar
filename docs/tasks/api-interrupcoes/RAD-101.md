# RAD-101: Value Object TipoInterrupcao

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** Existente
**Dependencias:** -

## Objetivo

Criar Enum Value Object para tipo de interrupcao (PROGRAMADA/NAO_PROGRAMADA).

## Localizacao

`backend/shared/domain/value_objects/tipo_interrupcao.py`

## Especificacao

### Regras de Negocio

1. **PROGRAMADA:** Interrupcao com PLAN_ID no banco (manutencao preventiva, obras)
2. **NAO_PROGRAMADA:** Interrupcao sem PLAN_ID (falhas, acidentes, eventos climaticos)

### Determinacao do Tipo

A determinacao e feita baseada na existencia de PLAN_ID na tabela `SWITCH_PLAN_TASKS`:
- Se `PLAN_ID IS NOT NULL` -> PROGRAMADA
- Se `PLAN_ID IS NULL` -> NAO_PROGRAMADA

> **ANEEL Spec:** Conforme Oficio Circular 14/2025-SFE/ANEEL

## Implementacao

```python
# shared/domain/value_objects/tipo_interrupcao.py
from __future__ import annotations

from enum import Enum


class TipoInterrupcao(str, Enum):
    """
    Value Object para Tipo de Interrupcao.

    Herda de str para facilitar serializacao JSON.

    Regras de negocio:
    - PROGRAMADA: Quando existe PLAN_ID na tabela SWITCH_PLAN_TASKS
    - NAO_PROGRAMADA: Quando NAO existe PLAN_ID

    Fonte: Oficio Circular 14/2025-SFE/ANEEL
    """

    PROGRAMADA = "PROGRAMADA"
    NAO_PROGRAMADA = "NAO_PROGRAMADA"

    @classmethod
    def from_plan_id(cls, plan_id: int | None) -> TipoInterrupcao:
        """
        Factory method baseado na regra de negocio do PLAN_ID.

        Se PLAN_ID existe (nao e None) -> PROGRAMADA
        Se PLAN_ID nao existe (e None) -> NAO_PROGRAMADA

        Args:
            plan_id: ID do plano de interrupcao

        Returns:
            TipoInterrupcao
        """
        return cls.PROGRAMADA if plan_id is not None else cls.NAO_PROGRAMADA

    @classmethod
    def from_codigo(cls, codigo: int) -> TipoInterrupcao:
        """
        Factory method a partir do codigo numerico.

        Args:
            codigo: 1 para PROGRAMADA, 2 para NAO_PROGRAMADA

        Returns:
            TipoInterrupcao

        Raises:
            ValueError: Se codigo invalido
        """
        if codigo == 1:
            return cls.PROGRAMADA
        if codigo == 2:
            return cls.NAO_PROGRAMADA
        raise ValueError(f"Codigo de tipo de interrupcao invalido: {codigo}")

    @property
    def codigo(self) -> int:
        """Retorna o codigo numerico do tipo (1 = PROGRAMADA, 2 = NAO_PROGRAMADA)."""
        return 1 if self == TipoInterrupcao.PROGRAMADA else 2

    def is_programada(self) -> bool:
        """Verifica se e programada."""
        return self == TipoInterrupcao.PROGRAMADA

    def is_nao_programada(self) -> bool:
        """Verifica se e nao programada."""
        return self == TipoInterrupcao.NAO_PROGRAMADA
```

## Mapeamento ANEEL

| Tipo | Codigo | Descricao |
|------|--------|-----------|
| PROGRAMADA | 1 | Manutencao preventiva, obras, expansao |
| NAO_PROGRAMADA | 2 | Falhas, acidentes, eventos climaticos |

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/value_objects/test_tipo_interrupcao.py
import pytest
from backend.shared.domain.value_objects.tipo_interrupcao import TipoInterrupcao


class TestTipoInterrupcao:
    """Testes para Value Object TipoInterrupcao."""

    class TestFromPlanId:
        """Testes para factory from_plan_id()."""

        def test_deve_retornar_programada_quando_plan_id_existe(self):
            """PLAN_ID presente indica interrupcao programada."""
            tipo = TipoInterrupcao.from_plan_id(12345)

            assert tipo == TipoInterrupcao.PROGRAMADA

        def test_deve_retornar_programada_para_qualquer_plan_id_valido(self):
            """Qualquer PLAN_ID nao-nulo indica programada."""
            for plan_id in [1, 100, 99999, 1000000]:
                tipo = TipoInterrupcao.from_plan_id(plan_id)
                assert tipo == TipoInterrupcao.PROGRAMADA

        def test_deve_retornar_programada_quando_plan_id_zero(self):
            """PLAN_ID = 0 ainda e um valor valido (programada)."""
            tipo = TipoInterrupcao.from_plan_id(0)

            assert tipo == TipoInterrupcao.PROGRAMADA

        def test_deve_retornar_nao_programada_quando_plan_id_e_none(self):
            """PLAN_ID None indica interrupcao nao programada."""
            tipo = TipoInterrupcao.from_plan_id(None)

            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

    class TestFromCodigo:
        """Testes para factory from_codigo()."""

        def test_codigo_1_retorna_programada(self):
            """Codigo 1 = PROGRAMADA (padrao ANEEL)."""
            tipo = TipoInterrupcao.from_codigo(1)

            assert tipo == TipoInterrupcao.PROGRAMADA

        def test_codigo_2_retorna_nao_programada(self):
            """Codigo 2 = NAO_PROGRAMADA (padrao ANEEL)."""
            tipo = TipoInterrupcao.from_codigo(2)

            assert tipo == TipoInterrupcao.NAO_PROGRAMADA

        def test_codigo_invalido_lanca_value_error(self):
            """Codigos diferentes de 1 ou 2 lancam erro."""
            with pytest.raises(ValueError) as exc_info:
                TipoInterrupcao.from_codigo(3)

            assert "invalido" in str(exc_info.value).lower()

        def test_codigo_zero_lanca_value_error(self):
            """Codigo 0 e invalido."""
            with pytest.raises(ValueError):
                TipoInterrupcao.from_codigo(0)

        def test_codigo_negativo_lanca_value_error(self):
            """Codigos negativos sao invalidos."""
            with pytest.raises(ValueError):
                TipoInterrupcao.from_codigo(-1)

    class TestIsProgramada:
        """Testes para metodo is_programada()."""

        def test_programada_retorna_true(self):
            """TipoInterrupcao.PROGRAMADA.is_programada() == True."""
            assert TipoInterrupcao.PROGRAMADA.is_programada() is True

        def test_nao_programada_retorna_false(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_programada() == False."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_programada() is False

    class TestIsNaoProgramada:
        """Testes para metodo is_nao_programada()."""

        def test_nao_programada_retorna_true(self):
            """TipoInterrupcao.NAO_PROGRAMADA.is_nao_programada() == True."""
            assert TipoInterrupcao.NAO_PROGRAMADA.is_nao_programada() is True

        def test_programada_retorna_false(self):
            """TipoInterrupcao.PROGRAMADA.is_nao_programada() == False."""
            assert TipoInterrupcao.PROGRAMADA.is_nao_programada() is False

    class TestCodigo:
        """Testes para property codigo."""

        def test_programada_retorna_1(self):
            """PROGRAMADA.codigo == 1."""
            assert TipoInterrupcao.PROGRAMADA.codigo == 1

        def test_nao_programada_retorna_2(self):
            """NAO_PROGRAMADA.codigo == 2."""
            assert TipoInterrupcao.NAO_PROGRAMADA.codigo == 2

    class TestEnumValues:
        """Testes para valores do Enum."""

        def test_enum_tem_apenas_dois_valores(self):
            """Enum deve ter exatamente 2 valores."""
            assert len(TipoInterrupcao) == 2

        def test_valores_sao_strings_corretas(self):
            """Valores do enum sao strings descritivas."""
            assert TipoInterrupcao.PROGRAMADA.value == "PROGRAMADA"
            assert TipoInterrupcao.NAO_PROGRAMADA.value == "NAO_PROGRAMADA"

    class TestStrEnum:
        """Testes para verificar heranca de str."""

        def test_enum_herda_de_str(self):
            """TipoInterrupcao deve herdar de str (para serializacao JSON)."""
            assert isinstance(TipoInterrupcao.PROGRAMADA, str)

        def test_pode_ser_comparado_com_string(self):
            """Enum pode ser comparado diretamente com string."""
            assert TipoInterrupcao.PROGRAMADA == "PROGRAMADA"
            assert TipoInterrupcao.NAO_PROGRAMADA == "NAO_PROGRAMADA"
```

## Criterios de Aceite

- [x] Testes escritos e passando
- [x] Enum (str, Enum) com 2 valores (serializacao JSON nativa)
- [x] Factory `from_plan_id(int | None)` para determinar tipo
- [x] Factory `from_codigo(int)` para converter codigo numerico
- [x] Metodos `is_programada()` e `is_nao_programada()`
- [x] Property `codigo` para codigo numerico ANEEL
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED - devem falhar primeiro)
pytest tests/unit/domain/value_objects/test_tipo_interrupcao.py -v

# Apos implementacao (GREEN)
pytest tests/unit/domain/value_objects/test_tipo_interrupcao.py -v --tb=short

# Com cobertura
pytest tests/unit/domain/value_objects/test_tipo_interrupcao.py --cov=shared/domain/value_objects/tipo_interrupcao --cov-report=term-missing
```
