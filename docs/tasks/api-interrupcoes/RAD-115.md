# RAD-115: Error Handling Middleware

**Fase:** 4 - Interfaces Layer
**Tipo:** Middleware
**Prioridade:** Alta
**Status:** Pendente
**Dependencias:** RAD-112

## Objetivo

Implementar middleware para tratamento global de erros e logging de requisicoes.

## Localizacao

`backend/apps/api_interrupcoes/middleware.py`

## Especificacao

### Requisitos

1. Captura todas as exceptions nao tratadas
2. Formata respostas de erro no padrao ANEEL
3. Log estruturado de todas as requisicoes
4. Correlacao de requests (request_id)
5. Metricas de tempo de resposta

### Formato de Erro ANEEL

```json
{
  "idcStatusRequisicao": 2,
  "desStatusRequisicao": "Erro interno",
  "emailIndisponibilidade": "radar@roraimaenergia.com.br",
  "mensagem": "Descricao do erro",
  "interrupcaoFornecimento": []
}
```

## Implementacao

```python
# apps/api_interrupcoes/middleware.py
import time
import uuid
from typing import Callable

from fastapi import Request, Response
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
import structlog

from .schemas import ErrorResponse


logger = structlog.get_logger()


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """
    Middleware para logging de requisicoes.

    Adiciona request_id e loga inicio/fim de cada requisicao.
    """

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        # Gerar request_id
        request_id = str(uuid.uuid4())[:8]
        request.state.request_id = request_id

        # Extrair info da requisicao
        client_ip = request.client.host if request.client else "unknown"
        method = request.method
        path = request.url.path
        api_key = request.headers.get("x-api-key", "")[:8] + "..."

        # Log inicio
        log = logger.bind(
            request_id=request_id,
            client_ip=client_ip,
            method=method,
            path=path,
        )
        log.info("request_started")

        # Medir tempo
        start_time = time.perf_counter()

        try:
            response = await call_next(request)

            # Calcular duracao
            duration_ms = (time.perf_counter() - start_time) * 1000

            # Log sucesso
            log.info(
                "request_completed",
                status_code=response.status_code,
                duration_ms=round(duration_ms, 2),
            )

            # Adicionar headers de correlacao
            response.headers["X-Request-ID"] = request_id
            response.headers["X-Response-Time"] = f"{duration_ms:.2f}ms"

            return response

        except Exception as e:
            # Log erro
            duration_ms = (time.perf_counter() - start_time) * 1000
            log.exception(
                "request_failed",
                error=str(e),
                duration_ms=round(duration_ms, 2),
            )
            raise


class ErrorHandlingMiddleware(BaseHTTPMiddleware):
    """
    Middleware para tratamento global de erros.

    Converte todas as exceptions em respostas JSON no formato ANEEL.
    """

    async def dispatch(
        self,
        request: Request,
        call_next: Callable,
    ) -> Response:
        try:
            return await call_next(request)

        except Exception as e:
            return self._handle_exception(request, e)

    def _handle_exception(
        self,
        request: Request,
        exc: Exception,
    ) -> JSONResponse:
        """Trata exception e retorna resposta JSON."""
        request_id = getattr(request.state, "request_id", "unknown")

        # Determinar status code
        status_code = self._get_status_code(exc)

        # Criar resposta de erro
        error_response = ErrorResponse(
            desStatusRequisicao=self._get_error_description(exc),
            mensagem=self._get_error_message(exc, request_id),
        )

        return JSONResponse(
            status_code=status_code,
            content=error_response.model_dump(),
            headers={"X-Request-ID": request_id},
        )

    def _get_status_code(self, exc: Exception) -> int:
        """Retorna status code apropriado para o tipo de erro."""
        from fastapi import HTTPException
        from sqlalchemy.exc import SQLAlchemyError

        if isinstance(exc, HTTPException):
            return exc.status_code
        elif isinstance(exc, SQLAlchemyError):
            return 503  # Service Unavailable
        elif isinstance(exc, ValueError):
            return 400  # Bad Request
        else:
            return 500  # Internal Server Error

    def _get_error_description(self, exc: Exception) -> str:
        """Retorna descricao do erro."""
        from fastapi import HTTPException
        from sqlalchemy.exc import SQLAlchemyError

        if isinstance(exc, HTTPException):
            return exc.detail if isinstance(exc.detail, str) else "Erro de requisicao"
        elif isinstance(exc, SQLAlchemyError):
            return "Servico temporariamente indisponivel"
        elif isinstance(exc, ValueError):
            return "Dados invalidos"
        else:
            return "Erro interno do servidor"

    def _get_error_message(self, exc: Exception, request_id: str) -> str:
        """Retorna mensagem de erro para o usuario."""
        from fastapi import HTTPException

        if isinstance(exc, HTTPException):
            return str(exc.detail)
        else:
            # Nao expor detalhes internos
            return f"Entre em contato com o suporte. ID: {request_id}"


class CorsMiddleware:
    """
    Middleware CORS customizado (se necessario).

    Nota: Preferir usar CORSMiddleware do FastAPI/Starlette.
    """

    def __init__(self, app, allow_origins: list[str]) -> None:
        self.app = app
        self.allow_origins = allow_origins

    async def __call__(self, scope, receive, send):
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return

        # Verificar origin
        headers = dict(scope.get("headers", []))
        origin = headers.get(b"origin", b"").decode()

        if origin in self.allow_origins:
            # Adicionar headers CORS
            pass

        await self.app(scope, receive, send)


def setup_middlewares(app) -> None:
    """Configura todos os middlewares na aplicacao."""
    # Ordem importa: primeiro registrado = ultimo executado
    app.add_middleware(ErrorHandlingMiddleware)
    app.add_middleware(RequestLoggingMiddleware)
```

## Configuracao de Logging

```python
# shared/infrastructure/logger.py
import structlog
from structlog.types import Processor


def setup_logging(debug: bool = False) -> None:
    """Configura logging estruturado."""
    processors: list[Processor] = [
        structlog.contextvars.merge_contextvars,
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
    ]

    if debug:
        processors.append(structlog.dev.ConsoleRenderer())
    else:
        processors.append(structlog.processors.JSONRenderer())

    structlog.configure(
        processors=processors,
        wrapper_class=structlog.make_filtering_bound_logger(
            logging.INFO if not debug else logging.DEBUG
        ),
        context_class=dict,
        logger_factory=structlog.PrintLoggerFactory(),
        cache_logger_on_first_use=True,
    )
```

## Exemplo de Log

```json
{
  "event": "request_completed",
  "request_id": "a1b2c3d4",
  "client_ip": "192.168.1.100",
  "method": "GET",
  "path": "/api/v1/interrupcoes/quantitativointerrupcoesativas",
  "status_code": 200,
  "duration_ms": 45.23,
  "timestamp": "2025-01-15T10:30:45.123Z",
  "level": "info"
}
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/middleware/test_middleware.py
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from fastapi import FastAPI, Request, HTTPException
from fastapi.testclient import TestClient
from starlette.responses import JSONResponse

from apps.api_interrupcoes.middleware import (
    RequestLoggingMiddleware,
    ErrorHandlingMiddleware,
)


class TestRequestLoggingMiddleware:
    """Testes para middleware de logging."""

    @pytest.fixture
    def app(self):
        """App de teste com middleware."""
        app = FastAPI()
        app.add_middleware(RequestLoggingMiddleware)

        @app.get("/test")
        async def test_endpoint():
            return {"status": "ok"}

        return app

    @pytest.fixture
    def client(self, app):
        """Client de teste."""
        return TestClient(app)

    def test_deve_adicionar_request_id_no_header(self, client):
        """Response tem header X-Request-ID."""
        response = client.get("/test")

        assert "X-Request-ID" in response.headers
        assert len(response.headers["X-Request-ID"]) == 8

    def test_deve_adicionar_tempo_de_resposta_no_header(self, client):
        """Response tem header X-Response-Time."""
        response = client.get("/test")

        assert "X-Response-Time" in response.headers
        assert "ms" in response.headers["X-Response-Time"]

    def test_deve_logar_inicio_da_requisicao(self, client):
        """Loga inicio da requisicao."""
        with patch('apps.api_interrupcoes.middleware.logger') as mock_logger:
            mock_logger.bind.return_value = mock_logger

            client.get("/test")

            mock_logger.info.assert_called()

    def test_deve_logar_fim_da_requisicao_com_status(self, client):
        """Loga fim com status code e duracao."""
        with patch('apps.api_interrupcoes.middleware.logger') as mock_logger:
            mock_logger.bind.return_value = mock_logger

            client.get("/test")

            # Verifica que log foi chamado com status_code
            calls = mock_logger.info.call_args_list
            assert any("completed" in str(c) or "status_code" in str(c) for c in calls)


class TestErrorHandlingMiddleware:
    """Testes para middleware de tratamento de erros."""

    @pytest.fixture
    def app(self):
        """App de teste com middleware."""
        app = FastAPI()
        app.add_middleware(ErrorHandlingMiddleware)

        @app.get("/error")
        async def error_endpoint():
            raise ValueError("Erro de teste")

        @app.get("/http-error")
        async def http_error_endpoint():
            raise HTTPException(status_code=400, detail="Bad request")

        @app.get("/success")
        async def success_endpoint():
            return {"status": "ok"}

        return app

    @pytest.fixture
    def client(self, app):
        """Client de teste."""
        return TestClient(app, raise_server_exceptions=False)

    def test_deve_retornar_sucesso_quando_sem_erro(self, client):
        """Requisicao bem sucedida passa normalmente."""
        response = client.get("/success")

        assert response.status_code == 200

    def test_deve_capturar_exception_generica(self, client):
        """Captura exceptions genericas."""
        response = client.get("/error")

        assert response.status_code == 500

    def test_deve_retornar_formato_aneel_em_erro(self, client):
        """Erro retorna formato ANEEL."""
        response = client.get("/error")
        data = response.json()

        assert "idcStatusRequisicao" in data
        assert data["idcStatusRequisicao"] == 2
        assert "emailIndisponibilidade" in data
        assert "mensagem" in data

    def test_deve_incluir_request_id_no_erro(self, client):
        """Erro inclui request_id na mensagem."""
        response = client.get("/error")
        data = response.json()

        # Mensagem deve mencionar contato com suporte e ID
        assert "suporte" in data["mensagem"].lower() or "ID" in data["mensagem"]

    def test_nao_deve_expor_detalhes_internos(self, client):
        """Nao expoe stacktrace ou detalhes internos."""
        response = client.get("/error")
        data = response.json()

        assert "Erro de teste" not in data["mensagem"]
        assert "Traceback" not in str(data)

    def test_deve_retornar_status_400_para_value_error(self, client):
        """ValueError retorna 400."""
        response = client.get("/error")

        # ValueError pode retornar 400 ou 500 dependendo da implementacao
        assert response.status_code in [400, 500]

    def test_deve_manter_status_de_http_exception(self, client):
        """HTTPException mantem status code original."""
        response = client.get("/http-error")

        assert response.status_code == 400


class TestErrorResponse:
    """Testes para formato de resposta de erro."""

    def test_erro_401_deve_ter_formato_aneel(self):
        """Erro 401 segue formato ANEEL."""
        from apps.api_interrupcoes.schemas import ErrorResponse

        error = ErrorResponse(
            desStatusRequisicao="API Key invalida",
            mensagem="Header x-api-key nao fornecido",
        )

        assert error.idcStatusRequisicao == 2
        assert error.emailIndisponibilidade == "radar@roraimaenergia.com.br"
        assert error.interrupcaoFornecimento == []

    def test_erro_429_deve_ter_formato_aneel(self):
        """Erro 429 segue formato ANEEL."""
        from apps.api_interrupcoes.schemas import ErrorResponse

        error = ErrorResponse(
            desStatusRequisicao="Rate limit excedido",
            mensagem="Maximo 12 requisicoes por minuto",
        )

        assert error.idcStatusRequisicao == 2
        assert "radar@roraimaenergia.com.br" in error.emailIndisponibilidade
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] RequestLoggingMiddleware implementado
- [ ] ErrorHandlingMiddleware implementado
- [ ] Request ID em todas as requisicoes
- [ ] Erros no formato ANEEL
- [ ] Logging estruturado (JSON em producao)
- [ ] Tempo de resposta nos headers
- [ ] Nao expoe detalhes internos em erros
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/middleware/test_middleware.py -v

# Com cobertura
pytest tests/unit/middleware/test_middleware.py --cov=apps/api_interrupcoes/middleware --cov-report=term-missing
```

## Testes Relacionados

- RAD-121: Testes E2E - API
