# RAD-103: Result Pattern

**Fase:** 1 - Domain Layer
**Tipo:** Domain
**Prioridade:** Alta
**Status:** Existente
**Dependencias:** -

## Objetivo

Implementar Result Pattern generico para tratamento de erros sem exceptions.

## Localizacao

`backend/shared/domain/result.py`

## Especificacao

### Motivacao

O Result Pattern permite:
1. Tratamento explicito de erros sem exceptions
2. Composicao de operacoes que podem falhar
3. Tipagem estatica de erros
4. Fluxo de controle mais previsivel

### API

| Metodo | Descricao |
|--------|-----------|
| `Result.ok(value)` | Cria resultado de sucesso |
| `Result.fail(error)` | Cria resultado de falha |
| `is_success` | True se sucesso |
| `is_failure` | True se falha |
| `value` | Valor em caso de sucesso |
| `error` | Mensagem de erro em caso de falha |

## Implementacao

```python
# shared/domain/result.py
from typing import TypeVar, Generic
from dataclasses import dataclass

T = TypeVar("T")


@dataclass(frozen=True)
class Result(Generic[T]):
    """
    Padrao Result para tratamento de erros sem exceptions.

    Permite encapsular o resultado de operacoes que podem
    falhar de forma explicita e type-safe.

    Example:
        >>> result = CodigoIBGE.create("1400100")
        >>> if result.is_success:
        ...     print(result.value)
        >>> else:
        ...     print(result.error)
    """

    _value: T | None
    _error: str | None

    @classmethod
    def ok(cls, value: T) -> "Result[T]":
        """
        Cria um Result de sucesso.

        Args:
            value: Valor do resultado

        Returns:
            Result com sucesso
        """
        return cls(_value=value, _error=None)

    @classmethod
    def fail(cls, error: str) -> "Result[T]":
        """
        Cria um Result de falha.

        Args:
            error: Mensagem de erro

        Returns:
            Result com falha
        """
        return cls(_value=None, _error=error)

    @property
    def is_success(self) -> bool:
        """Retorna True se o resultado e sucesso."""
        return self._error is None

    @property
    def is_failure(self) -> bool:
        """Retorna True se o resultado e falha."""
        return self._error is not None

    @property
    def value(self) -> T:
        """
        Retorna o valor do resultado.

        Raises:
            ValueError: Se o resultado e falha
        """
        if self._value is None:
            raise ValueError(f"Result is failure: {self._error}")
        return self._value

    @property
    def error(self) -> str:
        """
        Retorna a mensagem de erro.

        Raises:
            ValueError: Se o resultado e sucesso
        """
        if self._error is None:
            raise ValueError("Result is success")
        return self._error

    def map(self, func) -> "Result":
        """
        Aplica funcao ao valor se sucesso.

        Args:
            func: Funcao a aplicar

        Returns:
            Novo Result com valor transformado
        """
        if self.is_failure:
            return self
        try:
            return Result.ok(func(self.value))
        except Exception as e:
            return Result.fail(str(e))

    def flat_map(self, func) -> "Result":
        """
        Aplica funcao que retorna Result ao valor.

        Args:
            func: Funcao que retorna Result

        Returns:
            Result da funcao aplicada
        """
        if self.is_failure:
            return self
        return func(self.value)

    @classmethod
    def combine(cls, results: list["Result"]) -> "Result[list]":
        """
        Combina lista de Results em um unico Result.

        Args:
            results: Lista de Results

        Returns:
            Result.ok com lista de valores ou Result.fail com primeiro erro
        """
        values = []
        for result in results:
            if result.is_failure:
                return Result.fail(result.error)
            values.append(result.value)
        return Result.ok(values)

    def get_or_default(self, default: T) -> T:
        """
        Retorna valor ou default se falha.

        Args:
            default: Valor padrao

        Returns:
            Valor ou default
        """
        return self._value if self.is_success else default

    def __repr__(self) -> str:
        if self.is_success:
            return f"Result.ok({self._value})"
        return f"Result.fail({self._error})"
```

## Uso

```python
# Criando resultados
result_ok = Result.ok(42)
result_fail = Result.fail("Erro de validacao")

# Verificando resultado
if result_ok.is_success:
    print(result_ok.value)  # 42

if result_fail.is_failure:
    print(result_fail.error)  # "Erro de validacao"

# Encadeando operacoes
result = (
    CodigoIBGE.create("1400100")
    .map(lambda ibge: ibge.valor)
    .map(lambda v: int(v))
)

# Combinando resultados
results = [Result.ok(1), Result.ok(2), Result.ok(3)]
combined = Result.combine(results)  # Result.ok([1, 2, 3])
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/domain/test_result.py
import pytest
from shared.domain.result import Result


class TestResult:
    """Testes para Result Pattern."""

    class TestOk:
        """Testes para Result.ok()."""

        def test_deve_criar_result_de_sucesso(self):
            """Result.ok cria resultado de sucesso."""
            result = Result.ok(42)

            assert result.is_success is True
            assert result.is_failure is False

        def test_deve_armazenar_valor(self):
            """Result.ok armazena o valor."""
            result = Result.ok("valor")

            assert result.value == "valor"

        def test_deve_aceitar_none_como_valor(self):
            """None e um valor valido para sucesso."""
            result = Result.ok(None)

            assert result.is_success is True

    class TestFail:
        """Testes para Result.fail()."""

        def test_deve_criar_result_de_falha(self):
            """Result.fail cria resultado de falha."""
            result = Result.fail("erro")

            assert result.is_failure is True
            assert result.is_success is False

        def test_deve_armazenar_mensagem_de_erro(self):
            """Result.fail armazena a mensagem de erro."""
            result = Result.fail("Erro de validacao")

            assert result.error == "Erro de validacao"

    class TestValue:
        """Testes para property value."""

        def test_deve_retornar_valor_em_sucesso(self):
            """value retorna o valor em caso de sucesso."""
            result = Result.ok(42)

            assert result.value == 42

        def test_deve_lancar_erro_em_falha(self):
            """value lanca ValueError em caso de falha."""
            result = Result.fail("erro")

            with pytest.raises(ValueError) as exc_info:
                _ = result.value

            assert "failure" in str(exc_info.value).lower()

    class TestError:
        """Testes para property error."""

        def test_deve_retornar_erro_em_falha(self):
            """error retorna a mensagem em caso de falha."""
            result = Result.fail("mensagem de erro")

            assert result.error == "mensagem de erro"

        def test_deve_lancar_erro_em_sucesso(self):
            """error lanca ValueError em caso de sucesso."""
            result = Result.ok(42)

            with pytest.raises(ValueError) as exc_info:
                _ = result.error

            assert "success" in str(exc_info.value).lower()

    class TestMap:
        """Testes para metodo map()."""

        def test_deve_aplicar_funcao_em_sucesso(self):
            """map aplica funcao ao valor de sucesso."""
            result = Result.ok(10).map(lambda x: x * 2)

            assert result.is_success
            assert result.value == 20

        def test_deve_ignorar_funcao_em_falha(self):
            """map nao aplica funcao em caso de falha."""
            result = Result.fail("erro").map(lambda x: x * 2)

            assert result.is_failure
            assert result.error == "erro"

        def test_deve_capturar_excecao_na_funcao(self):
            """map captura excecao e retorna falha."""
            result = Result.ok(10).map(lambda x: x / 0)

            assert result.is_failure

    class TestFlatMap:
        """Testes para metodo flat_map()."""

        def test_deve_aplicar_funcao_que_retorna_result(self):
            """flat_map aplica funcao que retorna Result."""
            def double_if_positive(x):
                if x > 0:
                    return Result.ok(x * 2)
                return Result.fail("Valor deve ser positivo")

            result = Result.ok(10).flat_map(double_if_positive)

            assert result.is_success
            assert result.value == 20

        def test_deve_propagar_falha_da_funcao(self):
            """flat_map propaga falha da funcao."""
            def double_if_positive(x):
                if x > 0:
                    return Result.ok(x * 2)
                return Result.fail("Valor deve ser positivo")

            result = Result.ok(-5).flat_map(double_if_positive)

            assert result.is_failure

        def test_deve_ignorar_em_falha_inicial(self):
            """flat_map nao aplica funcao em falha inicial."""
            result = Result.fail("erro inicial").flat_map(
                lambda x: Result.ok(x * 2)
            )

            assert result.is_failure
            assert result.error == "erro inicial"

    class TestCombine:
        """Testes para metodo combine()."""

        def test_deve_combinar_lista_de_sucessos(self):
            """combine retorna lista de valores se todos sucesso."""
            results = [Result.ok(1), Result.ok(2), Result.ok(3)]

            combined = Result.combine(results)

            assert combined.is_success
            assert combined.value == [1, 2, 3]

        def test_deve_retornar_primeiro_erro(self):
            """combine retorna primeiro erro encontrado."""
            results = [
                Result.ok(1),
                Result.fail("erro 1"),
                Result.fail("erro 2"),
            ]

            combined = Result.combine(results)

            assert combined.is_failure
            assert combined.error == "erro 1"

        def test_deve_retornar_lista_vazia_para_entrada_vazia(self):
            """combine de lista vazia retorna ok com lista vazia."""
            combined = Result.combine([])

            assert combined.is_success
            assert combined.value == []

    class TestGetOrDefault:
        """Testes para metodo get_or_default()."""

        def test_deve_retornar_valor_em_sucesso(self):
            """get_or_default retorna valor em sucesso."""
            result = Result.ok(42)

            assert result.get_or_default(0) == 42

        def test_deve_retornar_default_em_falha(self):
            """get_or_default retorna default em falha."""
            result = Result.fail("erro")

            assert result.get_or_default(0) == 0

    class TestRepr:
        """Testes para representacao string."""

        def test_repr_sucesso(self):
            """__repr__ de sucesso mostra valor."""
            result = Result.ok(42)

            assert "ok" in repr(result).lower()
            assert "42" in repr(result)

        def test_repr_falha(self):
            """__repr__ de falha mostra erro."""
            result = Result.fail("erro")

            assert "fail" in repr(result).lower()
            assert "erro" in repr(result)
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] Dataclass frozen (imutavel)
- [ ] Factory methods ok() e fail()
- [ ] Properties is_success e is_failure
- [ ] Properties value e error com validacao
- [ ] Metodos map() e flat_map()
- [ ] Metodo combine() para listas
- [ ] Cobertura >= 90%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/domain/test_result.py -v

# Com cobertura
pytest tests/unit/domain/test_result.py --cov=shared/domain/result --cov-report=term-missing
```
