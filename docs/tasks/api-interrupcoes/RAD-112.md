# RAD-112: FastAPI App Factory

**Fase:** 4 - Interfaces Layer
**Tipo:** Interface/HTTP
**Prioridade:** Alta
**Status:** Existente (necessita refatoracao)
**Dependencias:** RAD-108

## Objetivo

Criar factory de aplicacao FastAPI com configuracao modular e lifespan events.

## Localizacao

`backend/apps/api_interrupcoes/main.py`

## Especificacao

### Requisitos

1. App factory pattern para testabilidade
2. Lifespan events (startup/shutdown)
3. Configuracao de middlewares
4. Registro de rotas
5. Configuracao OpenAPI/Swagger
6. CORS configuravel

### Estrutura da API

```
/api/v1/interrupcoes/
├── /quantitativointerrupcoesativas  GET - Consulta interrupcoes ativas
├── /health                          GET - Health check
└── /docs                            GET - Swagger UI
```

## Implementacao

```python
# apps/api_interrupcoes/main.py
from contextlib import asynccontextmanager
from typing import AsyncGenerator

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from shared.infrastructure.config import Settings, get_settings
from shared.infrastructure.database.oracle_connection import (
    get_connection_manager,
    OracleConnectionManager,
)
from shared.infrastructure.cache.memory_cache import (
    get_cache_service,
    MemoryCacheService,
)

from .routes import router
from .middleware import (
    RequestLoggingMiddleware,
    ErrorHandlingMiddleware,
)


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncGenerator[None, None]:
    """
    Gerencia ciclo de vida da aplicacao.

    Startup:
    - Inicializa conexao Oracle
    - Inicializa cache
    - Testa conectividade

    Shutdown:
    - Fecha conexoes
    - Para cache cleanup
    """
    settings = get_settings()

    # Startup
    try:
        # Inicializar Oracle
        connection_manager = await get_connection_manager(settings)
        app.state.db = connection_manager

        # Verificar conectividade
        if not await connection_manager.health_check():
            raise RuntimeError("Falha na conexao com Oracle")

        # Testar DBLinks
        for dblink in ["DBLINK_INSERVICE", "DBLINK_INDICADORES"]:
            if not await connection_manager.test_dblink(dblink):
                raise RuntimeError(f"Falha no DBLink: {dblink}")

        # Inicializar cache
        cache = get_cache_service()
        await cache.start()
        app.state.cache = cache

        yield

    finally:
        # Shutdown
        if hasattr(app.state, "cache"):
            await app.state.cache.stop()

        if hasattr(app.state, "db"):
            await app.state.db.close()


def create_app(settings: Settings | None = None) -> FastAPI:
    """
    Factory para criar instancia da aplicacao FastAPI.

    Args:
        settings: Configuracoes (opcional, usa padrao se None)

    Returns:
        Aplicacao FastAPI configurada
    """
    if settings is None:
        settings = get_settings()

    app = FastAPI(
        title="API Interrupcoes - RADAR",
        description="""
        API de Quantitativo de Interrupcoes Ativas.

        Fornece dados agregados de interrupcoes de fornecimento
        de energia eletrica conforme especificacao ANEEL.

        ## Autenticacao
        Todas as requisicoes exigem header `x-api-key`.

        ## Rate Limiting
        Maximo de 12 requisicoes por minuto.
        """,
        version="1.0.0",
        docs_url="/docs" if settings.debug else None,
        redoc_url="/redoc" if settings.debug else None,
        openapi_url="/openapi.json" if settings.debug else None,
        lifespan=lifespan,
    )

    # CORS
    if settings.cors_origins:
        app.add_middleware(
            CORSMiddleware,
            allow_origins=settings.cors_origins,
            allow_credentials=True,
            allow_methods=["GET"],
            allow_headers=["x-api-key"],
        )

    # Middlewares customizados
    app.add_middleware(ErrorHandlingMiddleware)
    app.add_middleware(RequestLoggingMiddleware)

    # Rotas
    app.include_router(
        router,
        prefix="/api/v1/interrupcoes",
        tags=["Interrupcoes"],
    )

    return app


# Instancia para uvicorn
app = create_app()


# Entry point alternativo
def main() -> None:
    """Entry point para execucao direta."""
    import uvicorn

    settings = get_settings()
    uvicorn.run(
        "apps.api_interrupcoes.main:app",
        host=settings.host,
        port=settings.port,
        reload=settings.debug,
        workers=settings.workers if not settings.debug else 1,
    )


if __name__ == "__main__":
    main()
```

## Configuracao

```python
# shared/infrastructure/config.py (adicionar campos)
class Settings(BaseSettings):
    # Server
    host: str = "0.0.0.0"
    port: int = 8001
    workers: int = 4
    debug: bool = False

    # CORS
    cors_origins: list[str] = []

    # Oracle
    oracle_user: str = "radar"
    oracle_password: str
    oracle_dsn: str = "localhost:1521/XEPDB1"
    oracle_pool_size: int = 5

    # API Key
    api_key: str

    class Config:
        env_file = ".env"
        env_prefix = "RADAR_"
```

## Comando de Execucao

```bash
# Desenvolvimento
uvicorn apps.api_interrupcoes.main:app --reload --port 8001

# Producao
uvicorn apps.api_interrupcoes.main:app --host 0.0.0.0 --port 8001 --workers 4

# Via script
python -m apps.api_interrupcoes.main
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/unit/app/test_main.py
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from fastapi import FastAPI
from fastapi.testclient import TestClient

from apps.api_interrupcoes.main import create_app


class TestCreateApp:
    """Testes para factory de aplicacao."""

    def test_deve_criar_instancia_fastapi(self):
        """Factory cria instancia FastAPI."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            assert isinstance(app, FastAPI)

    def test_deve_ter_titulo_correto(self):
        """App tem titulo da API RADAR."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            assert "RADAR" in app.title

    def test_deve_ter_versao_definida(self):
        """App tem versao definida."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            assert app.version == "1.0.0"

    def test_deve_registrar_rotas_com_prefixo_correto(self):
        """Rotas registradas com prefixo /api/v1/interrupcoes."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            routes = [route.path for route in app.routes]
            assert any("/api/v1/interrupcoes" in route for route in routes)

    def test_deve_desabilitar_docs_em_producao(self):
        """Swagger desabilitado quando debug=False."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=False,
                cors_origins=[],
            )

            app = create_app()

            assert app.docs_url is None
            assert app.redoc_url is None

    def test_deve_habilitar_docs_em_desenvolvimento(self):
        """Swagger habilitado quando debug=True."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            assert app.docs_url == "/docs"


@pytest.mark.asyncio
class TestLifespan:
    """Testes para lifespan events."""

    async def test_deve_inicializar_oracle_no_startup(self):
        """Oracle inicializado no startup."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings, \
             patch('apps.api_interrupcoes.main.get_connection_manager') as mock_db, \
             patch('apps.api_interrupcoes.main.get_cache_service') as mock_cache:

            mock_settings.return_value = MagicMock(debug=True, cors_origins=[])
            mock_db.return_value = AsyncMock(
                health_check=AsyncMock(return_value=True),
                test_dblink=AsyncMock(return_value=True),
            )
            mock_cache.return_value = MagicMock(
                start=AsyncMock(),
                stop=AsyncMock(),
            )

            app = create_app()

            async with app.router.lifespan_context(app):
                mock_db.assert_called()

    async def test_deve_verificar_dblinks_no_startup(self):
        """DBLinks verificados no startup."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings, \
             patch('apps.api_interrupcoes.main.get_connection_manager') as mock_db, \
             patch('apps.api_interrupcoes.main.get_cache_service') as mock_cache:

            mock_manager = AsyncMock()
            mock_manager.health_check.return_value = True
            mock_manager.test_dblink.return_value = True

            mock_settings.return_value = MagicMock(debug=True, cors_origins=[])
            mock_db.return_value = mock_manager
            mock_cache.return_value = MagicMock(
                start=AsyncMock(),
                stop=AsyncMock(),
            )

            app = create_app()

            async with app.router.lifespan_context(app):
                # Verifica que test_dblink foi chamado para ambos DBLinks
                calls = [str(c) for c in mock_manager.test_dblink.call_args_list]
                assert len(calls) >= 2


class TestMiddlewares:
    """Testes para configuracao de middlewares."""

    def test_deve_ter_middleware_de_erros(self):
        """ErrorHandlingMiddleware registrado."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=[],
            )

            app = create_app()

            middleware_types = [type(m.cls).__name__ for m in app.user_middleware]
            # Verifica que algum middleware de erro esta registrado
            assert len(app.user_middleware) > 0


class TestCORS:
    """Testes para configuracao CORS."""

    def test_deve_configurar_cors_quando_origins_definidas(self):
        """CORS configurado com origins especificadas."""
        with patch('apps.api_interrupcoes.main.get_settings') as mock_settings:
            mock_settings.return_value = MagicMock(
                debug=True,
                cors_origins=["http://localhost:3000"],
            )

            app = create_app()

            # CORS middleware deve estar registrado
            assert len(app.user_middleware) > 0
```

## Criterios de Aceite

- [ ] Testes escritos e passando
- [ ] App factory pattern implementado
- [ ] Lifespan events configurados
- [ ] Inicializacao do Oracle no startup
- [ ] Inicializacao do cache no startup
- [ ] Shutdown graceful implementado
- [ ] Middlewares registrados
- [ ] Rotas com prefixo /api/v1/interrupcoes
- [ ] OpenAPI configurado
- [ ] CORS configuravel
- [ ] Cobertura >= 80%

## Comando de Execucao

```bash
# Executar testes (RED)
pytest tests/unit/app/test_main.py -v

# Com cobertura
pytest tests/unit/app/test_main.py --cov=apps/api_interrupcoes/main --cov-report=term-missing
```

## Testes Relacionados

- RAD-121: Testes E2E - API
