# RAD-128: Criar View VW_INTERRUPCAO_FORNECIMENTO

**Fase:** 7 - Infraestrutura de Dados
**Tipo:** Database
**Prioridade:** Alta
**Status:** Concluido
**Dependencias:** RAD-126, RAD-127

## Objetivo

Criar view otimizada para agregacao de interrupcoes de fornecimento, melhorando performance do endpoint principal (RAD-115) ao fazer agregacao no banco via CTEs.

## Localizacao

`backend/shared/infrastructure/database/migrations/versions/20251219_002_create_view_interrupcao.py`

## Especificacao

### Contexto

A view VW_INTERRUPCAO_FORNECIMENTO agrega dados de interrupcoes de fornecimento por municipio e conjunto eletrico, simplificando a consulta e melhorando performance.

**Complementa:**
- **RAD-109** (Oracle Repository): Pode usar esta view ao inves de query complexa
- **RAD-105** (Domain Service Aggregator): Agregacao feita no banco, nao em memoria

### Colunas de Saida

| Coluna | Tipo | Descricao |
|--------|------|-----------|
| IDE_CONJUNTO_UC | NUMBER | Identificador do conjunto |
| IDE_MUNICIPIO | NUMBER | Codigo IBGE (7 digitos) |
| QTD_UCS_ATENDIDAS | NUMBER | Total de UCs atendidas |
| QTD_OCORRENCIA_PROGRAMADA | NUMBER | UCs com interrupcao programada |
| QTD_OCORRENCIA_NAO_PROGRAMADA | NUMBER | UCs com interrupcao nao programada |

### DBLinks Utilizados

| DBLink | Schema | Tabelas |
|--------|--------|---------|
| DBLINK_INSERVICE | INSERVICE | AGENCY_EVENT, SWITCH_PLAN_TASKS, OMS_CONNECTIVITY, CISPERSL |

## Implementacao

```sql
CREATE OR REPLACE VIEW RADAR_API.VW_INTERRUPCAO_FORNECIMENTO AS
WITH
-- CTE 1: Tasks Programadas
Tasks_Programadas AS (
    SELECT DISTINCT spt.OUTAGE_NUM
    FROM INSERVICE.SWITCH_PLAN_TASKS@DBLINK_INSERVICE spt
    WHERE spt.OUTAGE_NUM IS NOT NULL
),

-- CTE 2: Mapeamento Dispositivo -> Municipio
Device_Municipio_Map AS (
    SELECT DISTINCT oc.DEV_NAME, oc.CONJ, c.HXGN_COD_MUNICIPIO_IBGE
    FROM INSERVICE.CISPERSL@DBLINK_INSERVICE c
    JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc ON oc.DEV_NAME = c.XFMR
    WHERE oc.DIST = '370' AND c.XFMR IS NOT NULL
),

-- CTE 3: UCs Atendidas
UCs_Atendidas AS (
    SELECT oc.CONJ, c.HXGN_COD_MUNICIPIO_IBGE, COUNT(DISTINCT c.PREMISE) AS Qtd
    FROM INSERVICE.CISPERSL@DBLINK_INSERVICE c
    JOIN INSERVICE.OMS_CONNECTIVITY@DBLINK_INSERVICE oc ON oc.DEV_NAME = c.XFMR
    WHERE oc.DIST = '370' AND c.XFMR IS NOT NULL
    GROUP BY oc.CONJ, c.HXGN_COD_MUNICIPIO_IBGE
),

-- CTE 4: Ocorrencias
Ocorrencias AS (
    SELECT Mapa.CONJ, Mapa.HXGN_COD_MUNICIPIO_IBGE,
           SUM(CASE WHEN T.OUTAGE_NUM IS NULL THEN ae.NUM_CUST ELSE 0 END) AS NaoProg,
           SUM(CASE WHEN T.OUTAGE_NUM IS NOT NULL THEN ae.NUM_CUST ELSE 0 END) AS Prog
    FROM INSERVICE.AGENCY_EVENT@DBLINK_INSERVICE ae
    JOIN Device_Municipio_Map Mapa ON ae.DEV_NAME = Mapa.DEV_NAME
    LEFT JOIN Tasks_Programadas T ON ae.NUM_1 = T.OUTAGE_NUM
    WHERE ae.AG_ID = 370 AND ae.IS_OPEN = 'T'
    GROUP BY Mapa.CONJ, Mapa.HXGN_COD_MUNICIPIO_IBGE
)

SELECT
    COALESCE(UCs.CONJ, Ocs.CONJ) AS IDE_CONJUNTO_UC,
    COALESCE(UCs.HXGN_COD_MUNICIPIO_IBGE, Ocs.HXGN_COD_MUNICIPIO_IBGE) AS IDE_MUNICIPIO,
    NVL(UCs.Qtd, 0) AS QTD_UCS_ATENDIDAS,
    NVL(Ocs.Prog, 0) AS QTD_OCORRENCIA_PROGRAMADA,
    NVL(Ocs.NaoProg, 0) AS QTD_OCORRENCIA_NAO_PROGRAMADA
FROM UCs_Atendidas UCs
FULL OUTER JOIN Ocorrencias Ocs ON UCs.CONJ = Ocs.CONJ
WHERE NVL(Ocs.Prog, 0) > 0 OR NVL(Ocs.NaoProg, 0) > 0;
```

## Testes TDD (Escrever PRIMEIRO)

```python
# tests/integration/database/test_view_interrupcao.py
import pytest
from sqlalchemy import text


@pytest.mark.integration
class TestViewInterrupcao:
    """Testes para view de interrupcoes."""

    def test_deve_existir_view(self, db_session):
        """View VW_INTERRUPCAO_FORNECIMENTO deve existir."""
        result = db_session.execute(text(
            "SELECT COUNT(*) FROM user_views WHERE view_name = 'VW_INTERRUPCAO_FORNECIMENTO'"
        ))
        assert result.scalar() == 1

    def test_deve_retornar_colunas_esperadas(self, db_session):
        """View deve ter colunas no formato ANEEL."""
        result = db_session.execute(text(
            "SELECT * FROM RADAR_API.VW_INTERRUPCAO_FORNECIMENTO WHERE ROWNUM = 1"
        ))
        if result.rowcount > 0:
            row = result.fetchone()
            assert hasattr(row, 'IDE_CONJUNTO_UC')
            assert hasattr(row, 'IDE_MUNICIPIO')
            assert hasattr(row, 'QTD_UCS_ATENDIDAS')

    def test_performance_deve_ser_adequada(self, db_session):
        """Query deve executar em menos de 5 segundos."""
        import time
        start = time.time()
        db_session.execute(text("SELECT * FROM RADAR_API.VW_INTERRUPCAO_FORNECIMENTO"))
        elapsed = time.time() - start
        assert elapsed < 5.0
```

## Criterios de Aceite

- [x] View criada no schema RADAR_API
- [x] Usa DBLinks para INSERVICE
- [x] Filtra apenas eventos abertos (is_open = 'T')
- [x] Filtra apenas agencia 370 (Roraima)
- [x] Retorna colunas no formato ANEEL
- [ ] Performance adequada (< 5s)

## Comando de Execucao

```bash
# Aplicar migracao
alembic upgrade head

# Testar view
SELECT * FROM RADAR_API.VW_INTERRUPCAO_FORNECIMENTO;

# Verificar performance
EXPLAIN PLAN FOR SELECT * FROM RADAR_API.VW_INTERRUPCAO_FORNECIMENTO;
SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

## Relacionamento com Outras Tasks

- **RAD-109** (Oracle Repository): Pode usar esta view para simplificar
- **RAD-105** (Aggregator Service): View faz agregacao no banco
- **RAD-126** (Alembic): Usa infraestrutura de migracoes
- **RAD-115** (Routes): Endpoint pode usar dados desta view
